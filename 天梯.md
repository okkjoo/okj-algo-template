之前写过的还没有整理上来...会慢慢复习并整理上来的。

# 天梯学习笔记

## L2-001 紧急救援 (25 分)|Dijkstra

**注释：**

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e8;
// N<500
int saveTeam[505];  //各点的存储的救援人数
int st[505];        //按路径能召集到的最多人数
int mm[505][505];   //地图
int number[505];    //到该点最短路径的数量
int vis[505];       //是否标记为node过
int dis[505];       //起点到该点的距离
int father[505];    //最短路径中，该点的上一个节点
int n, m, s, d;     //城市数量、路线数量、起点、终点

void Dijkstra() {
  //初始化
  fill(dis, dis + n, INF);
  fill(vis, vis + n, 0);
  fill(number, number + n, 0);
  dis[s] = 0;
  st[s] = saveTeam[s];
  number[s] = 1;
  for (int i = 0; i < n; i++) {
    int minn = INF, node = -1;
    for (int j = 0; j < n; j++) {
      if (!vis[j] && dis[j] < minn) {
        minn = dis[j];
        node = j;
      }
    }
    vis[node] = 1;
    if (node == -1) return;
    for (int j = 0; j < n; j++) {
      if (vis[j] == 0 && mm[node][j] != -1 &&
          (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        father[j] = node;
        number[j] = number[node];
      } else if (vis[j] == 0 && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j]) == dis[j]) {
        if ((st[node] + saveTeam[j]) > st[j]) {
          st[j] = st[node] + saveTeam[j];
          father[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  for (int i = 0; i < n; i++) {
    cin >> saveTeam[i];
  }
  //初始化地图
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      mm[i][j] = -1;
    }
  }
  //读入地图
  for (int i = 0; i < m; i++) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val;
    mm[n2][n1] = val;
  }
  Dijkstra();
  int p = d;
  while (1) {
    if (father[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = father[p];  //在这里使得起点 father[p] == p
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1) {
      cout << pathV[i];
    } else {
      cout << " " << pathV[i];
    }
  }
```

**无注释：**

```cpp


#include <bits/stdc++.h>
using namespace std;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 505, INF = 1e8;
int st[N], saveTeam[N], vis[N], dis[N], number[N], mm[N][N], fa[N], n, m, s, d;
void dj() {
  fill(vis, vis + N, 0), fill(dis, dis + N, INF), fill(number, number + N, 0);
  dis[s] = 0, st[s] = saveTeam[s];
  number[s] = 1;
  FOR(i, 0, n) {
    int minn = INF, node = -1;
    FOR(j, 0, n) {
      if (!vis[j] && dis[j] < minn) minn = dis[j], node = j;
    }
    if (node == -1) return;
    vis[node] = 1;
    FOR(j, 0, n) {
      if (!vis[j] && mm[node][j] != -1 && (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        fa[j] = node;
        number[j] = number[node];
      } else if (!vis[j] && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j] == dis[j])) {
        if ((st[node] + saveTeam[j] > st[j])) {
          st[j] = st[node] + saveTeam[j];
          fa[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  FOR(i, 0, n) { cin >> saveTeam[i]; }
  FOR(i, 0, n) FOR(j, 0, n) mm[i][j] = -1;
  FOR(i, 0, m) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val, mm[n2][n1] = val;
  }
  dj();
  int p = d;
  while (1) {
    if (fa[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = fa[p];
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1)
      cout << pathV[i];
    else
      cout << " " << pathV[i];
  }
}
```



## **L2-002 链表去重** 

- 主要在于用结构体存储
- 两个数组充当两个链表 ， `t1 t2`分别作为两个指针下标并且代表链表的长度，数组中存储对应的地址
- ` ad1 = node[ad1].nxt;`通过访问结构体中nxt 进行指针跳转

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5 + 10;
struct Node {
  int key, nxt;
} node[N];         // node[i]:地址为i，键值为node[i].key
int p1[N], p2[N];  //去重后的链表、被删除的链表
int flag[N];       //记录其绝对值是否出现过
int main() {
  int ad1, n;  // ad1:头地址
  cin >> ad1 >> n;
  int a, b, c;
  FOR(i, 0, n) {
    cin >> a >> b >> c;
    node[a].key = b, node[a].nxt = c;
  }
  int t1 = 0, t2 = 0;            //分别是两个链表的指针
  while (n--) {                  //枚举每个节点
    int k = abs(node[ad1].key);  // ad1开始充当头指针
    if (!flag[k]) {
      flag[k] = 1, p1[t1++] = ad1;
    } else
      p2[t2++] = ad1;
    ad1 = node[ad1].nxt;
    if (ad1 == -1) break;
  }
  FOR(i, 0, t1) {
    ad1 = p1[i];
    if (i == t1 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p1[i + 1]);
  }
  FOR(i, 0, t2) {
    ad1 = p2[i];
    if (i == t2 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p2[i + 1]);
  }
}
```



## L2-003 月饼 (25 分)|简单模拟

根据月饼的总价和数量计算出每一种月饼的单价，然后将月饼数组按照单价从大到小排序，根据需求量need的大小，从单价最大的月饼开始售卖，将销售掉这种月饼的价格累加到result

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

struct node {
  double num, price;
} a[1005];
bool cmp(node a, node b) { return a.price / a.num > b.price / b.num; }
int n, d;
int main() {
  while (cin >> n >> d) {
    FOR(i, 0, n) { cin >> a[i].num; }
    FOR(i, 0, n) { cin >> a[i].price; }
    sort(a, a + n, cmp);
    double res = 0;
    FOR(i, 0, n) {
      if (a[i].num < d) {
        res += a[i].price;
      } else {
        res += a[i].price / a[i].num * d;
        break;
      }
      d = d - a[i].num;
    }
    printf("%.2f", res);
  }
  return 0;
}
```

## L2-004 这是二叉搜索树吗？ (25 分)|二叉搜索树性质：前序遍历->后序遍历

- 其左子树中所有结点的键值小于该结点的键值；
- 其右子树中所有结点的键值大于等于该结点的键值；
- 其左右子树都是二叉搜索树。

相关笔记：https://www.yuque.com/qzhou/learning/sw1t80

> 假设它是二叉搜索树，一开始`isMirror`为FALSE，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设`isMirror`为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出NO否则输出YES
>
> 原文链接：https://blog.csdn.net/liuchuo/article/details/52160484

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, pre[1005];
vector<int> resv;
bool is_mir = 0;

void solve(int root, int tail) {
  if (root > tail) return;
  int i = root + 1, j = tail;  // 用双指针是因为不能确定他是二叉搜索树，单指针可能误判
  if (!is_mir) {
    while (i <= tail && pre[i] < pre[root]) i++;  //找该节点的左子树
    while (j > root && pre[j] >= pre[root]) j--;  //找该节点的右子树
  } else {
    while (i <= tail && pre[i] >= pre[root]) i++;
    while (j > root && pre[j] < pre[root]) j--;
  }
  solve(root + 1, i - 1);
  solve(j + 1, tail);
  resv.push_back(pre[root]);
}

int main() {
  cin >> n;
  FOR(i, 0, n) cin >> pre[i];
  solve(0, n - 1);
  if (resv.size() != n) {
    resv.clear();
    is_mir = 1;
    solve(0, n - 1);
  }
  if (resv.size() != n) {
    cout << "NO" << endl;
  } else {
    cout << "YES" << endl;
    FOR(i, 0, resv.size()) {
      if (i != 0) cout << " ";
      cout << resv[i];
    }
  }
  return 0;
}
```



## L2-006 树的遍历 (25 分)|二叉树：后序+中序 => 层序

层序遍历利用 map 的有序性来完成。

递归传入左孩子、右孩子下标即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post, in;
map<int, int> level;
void pre(int root, int start, int end, int index) {
  if (start > end) return;
  int i = start;
  while (i < end && in[i] != post[root]) i++;
  level[index] = post[root];
  pre(root - 1 - end + i, start, i - 1, 2 * index + 1);
  pre(root - 1, i + 1, end, 2 * index + 2);
}
int main() {
  int n;
  cin >> n;
  post.resize(n);
  in.resize(n);
  FOR(i, 0, n) cin >> post[i];
  FOR(i, 0, n) cin >> in[i];
  pre(n - 1, 0, n - 1, 0);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
  return 0;
}
```





## L2-8 最长对称子串|马拉车算法

使用到马拉车算法，算法主要思想就是利用回文的特性——知道左边的回文长度一定程度上就能知道右边的回文长度

以前记过[笔记](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8) 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

// string expendS(string s) {
//   string Str = "*#";
//   FOR(i, 0, s.size()) {
//     Str += s[i];
//     Str += '#';
//   }
//   return Str;
// }

// string mnc(string s) {
//   string s1 = expendS(s);
//   int idd = 0, maxx = 0, Len[10000], maxLen = 0, start = 0;
//   FOR(i, 0, s1.size()) {
//     if (i < maxx)
//       Len[i] = min(Len[2 * idd - i], maxx);
//     else
//       Len[i] = 1;
//     while (i + Len[i] < s1.size() && i - Len[i] > 0 &&
//            s1[i + Len[i]] == s1[i - Len[i]])
//       Len[i]++;
//     if (Len[i] + 1 > maxx) maxx = Len[i] + i, idd = i;
//     if (Len[i] - 1 > maxLen) maxLen = Len[i] - 1, start = (idd - maxLen) / 2;
//   }
//   return s.substr(start, maxLen);
// }
string expendS(string x) {
  string s = "*#";
  FOR(i, 0, x.size()) { s += x[i], s += "#"; }
  return s;
}
string mnc(string x) {
  string s = expendS(x);
  int Len[10000], idd = 0, maxx = 0, maxLen = 0, start = 0;
  FOR(i, 0, s.size()) {
    if (i < maxx)
      Len[i] = min(Len[2 * idd - i], maxx);
    else
      Len[i] = 1;
    while (i + Len[i] < s.size() && i - Len[i] > 0 &&
           s[i + Len[i]] == s[i - Len[i]]) {
      Len[i]++;
    }
    if (Len[i] + i > maxx) maxx = Len[i] + i, idd = i;
    if (Len[i] - 1 > maxLen) maxLen = Len[i] - 1, start = (idd - maxLen) / 2;
  }
  return s.substr(start, maxLen);
}
int main() {
  ios::sync_with_stdio(false);
  string s;
  getline(cin, s);
  cout << mnc(s).size();
  return 0;
}
```

## [L2-011 玩转二叉树 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784)|二叉树|前序+中序=>层序

关于镜面反转一棵树，只需要在记录 下标时，**左孩子为2 \* index + 2， 右孩子为2 \* index + 1** 

递归完成后level数组中非-1的数就是按照下标排列的层序遍历的顺序

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> pre, in;
//level(10000, -1);
map<int ,int>le;

void levelorder(int root, int start, int end, int index) {
  if (start > end) return;
  int i = start;
  while (i < end && in[i] != pre[root]) i++;
//  level[index] = pre[root];
    le[index]  =pre[root];
  levelorder(root + 1, start, i - 1, 2 * index + 2);
  levelorder(root + 1 + i - start, i + 1, end, 2 * index + 1);
}

int main() {
  int n, cnt = 0;
  cin >> n;
  pre.resize(n);
  in.resize(n);
  FOR(i, 0, n) { cin >> in[i]; }
  FOR(i, 0, n) { cin >> pre[i]; }
  levelorder(0, 0, n - 1, 0);
//   for (int i = 0; i < level.size(); i++) {
//     if (level[i] != -1 && cnt != n - 1) {
//       cout << level[i] << " ";
//       cnt++;
//     } else if (level[i] != -1) {
//       cout << level[i];
//       break;
//     }
//   }
  auto it = le.begin();
  cout << it->second;
  while (++it != le.end()) cout << " " << it->second;
  return 0;
}
```





## [L2-030 冰岛人](https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858887)|模拟|map、pair

孩子的姓等于父亲的名加后缀;输入格式：` 名 姓`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

#define pis pair<int, string>

int N, M;
string fName, sName, tmp;
map<string, pis> record;  //<名字,<性别1男 0女, 姓氏> >
string check(string a, string b) {
  int cnt1 = 0, cnt2;
  while (a != "") {
    cnt2 = 0;
    string b2 = b;
    while (b2 != "") {
      //共同祖先在五代之内
      // 只有嵌套才能找到共同祖先的情况
      if (a == b2 && (cnt1 < 4 || cnt2 < 4)) return "No\n";  //找到共同祖先
      if (cnt1 >= 4 && cnt2 >= 4) return "Yes\n";
      b2 = record[b2].second;  //搜他的姓氏，即他的父亲
      cnt2++;
    }
    a = record[a].second;  //搜他的姓氏，即他的父亲
    cnt1++;
  }
  //搜到最后祖宗还是没满足退出条件 就说明可行
  return "Yes\n";
}
int main() {
  cin >> N;
  while (N--) {
    cin >> fName >> sName;  //名 姓
    if (sName.back() == 'n')
      record[fName] = {1, sName.substr(0, sName.size() - 4)};
    else if (sName.back() == 'r')
      record[fName] = {0, sName.substr(0, sName.size() - 7)};
    else if (sName.back() == 'm')
      record[fName].first = 1;
    else
      record[fName].first = 0;
  }
  cin >> M;
  while (M--) {
    cin >> fName >> tmp >> sName >> tmp;  //姓没用，名有；只读名
    if (!record.count(fName) || !record.count(sName))
      cout << "NA\n";
    else if (record[fName].first == record[sName].first)
      cout << "Whatever\n";
    else
      cout << check(fName, sName);
  }
  return 0;
}
```

## **L2-035 完全二叉树的层序遍历 (25 分)**|后序遍历->层序

详细注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post;
map<int, int> level;
int n, idx;
//后序遍历
void dfs(int levIt) {  //传入的其实是 层序数组 的指针
  if (levIt > n) return;  //层序遍历和后序遍历得到的数组大小肯定都是n
  dfs(2 * levIt);              //左, 递
  dfs(2 * levIt + 1);          //右, 递
  level[levIt] = post[idx++];  //中, 归到这里时 idx 已经到了后面
}
int main() {
  cin >> n;
  post.resize(n);
  FOR(i, 0, n) cin >> post[i];
  dfs(1);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
}
```



## **L3-007 天梯地图 (30 分)**

> 题目： https://pintia.cn/problem-sets/994805046380707840/problems/994805051153825792

- 给图招路，图中有单向边
- 一条最快中最短
- 一条最短中节点最少
- 有上面两条为一条的情况
- 数据量： 点数[2,500]

- 两个 Dijkstra：最快、最短
- 用一个二维数组存储所有结点的最短路径，DFS 求出结点最少的那条

[代码+注释](./code/L3-007.cpp)

## **L3-008 喊山 (30 分)**

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050709229568

- `n`（≤10000）是总的山头数
- 一个山头呼喊的声音可以被临近的山头同时听到，每个山头最多有两个能听到它的临近山头
- 给出起点山头，找出最远能传到的地方
- 如果不止一个最远山头，就输出编号最小的
- 广度优先搜索

[代码+注释](./code/L3-008.cpp)

## **L3-009 长城 (30 分)**

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050277216256

- 长城，烽火台。烽火台在其折线点上
- 接收 n 个长城边缘折线点坐标——从南到北给
- 坐标 ∈[-10^9, 10^9]
- 总部在最南
- 要保证每个位置都能有南侧的烽火台能观望到
- 求烽火台最少数目

- 假设当前点为 A，他的右边有相邻点 B，C，此时若是 AC\*AB<0，即 AB 在 AC 上方，此时 B 为凸点。

![image-20211110110250589](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110110250589.png)

- 但并不是单纯的凸点记入，凹点舍弃，比如下图的情况

  ![image-20211110204916475](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110204916475.png)

  这情况明显只需要中间蓝色的圈和右边红色的圈即可

  (_其实一开始是想右边两个圈蓝色的，但是画错了，不想重新画了)_

  但是只判断凹凸的话，就会把左边红圈点也记入。

  明显用多了一个

  也就是说，每个烽火台观察的点不是连续的——那么就要用到栈来辅助判断。

- 从南到北——即从右到左依次入栈，判断栈顶点是否为凸点。是则记入，不是则舍弃。**凸点会继续参与比较，凹点会被弹出。**

- 当栈中存在大于 2 个的点时，表示 b 点为烽火

- 用 set 去重

[代码+注释](./code/L3-009.cpp)

## L3-010 是否完全二叉搜索树

- 给定二叉搜索树（定义左子树大、右子树小）

- 给出层序遍历结果

- 判断是否为完全二叉搜索树

- 根据二叉树性质即可：i 节点左孩子为 i<<1 右孩子为 i<<1|1
- 判断是否完全：输出完 n 个点前，出现空节点就不是完全

[代码+注释](./code/L3-010.cpp)

## L3-011 直捣黄龙

- 三个条件：最快>城镇最多>有效杀伤最多
- 存储：最合适路径、最快路数、最短进攻距离、歼敌总数
- 数据量：城镇数 ∈[2, 200]

- 将字符串与数字做映射，方便操作
- Dijskra

[代码+注释](./code/L3-011.cpp)
