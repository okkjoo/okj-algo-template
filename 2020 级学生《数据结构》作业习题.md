# 这个学期需要完成以下的全部作业习题。
作业习题列表：

## 第2章

1. 设线性表存储在数组A[1..arrsize]的前elenum个分量中，且递增有序。试编写一个算法：将线性表中的元素x删除，以保持线性表的有序性，并且分析算法的时间复杂度。

   ```cpp
   //没有就返回 -1
   int deletex(int A[],int &elenum, int x){
   	int del_idx = -1;
       for(int i = 0; i < elenum; i++){
           if(A[i] == x){
               del_idx = i;
               break;
           }
       }
       if(del_idx == -1) return -1;
       for(int i = del_idx; i < elenum; i++){
           A[i] = A[i + 1];
       }
       elenum--;
       return 1;
   }
   ```

   

2. 已知单链表L中的结点是按值非递减有序排列的，试编写一算法将链表L中值为X的结点删除，使得L仍然有序。

   ```cpp
   int deleteXinL(LNode* head, int x){
   	if(head == nullptr) return -1;
       LNOde *cur = head, *tmp;
       while(cur->next != nullptr && cur->next->val != x){
           cur = cur->next;
       }
       if(cur->next == nullptr) return -1;
       tmp = cur->next;
       cur->next = cur->next->next;
       delete tmp;
       return 1;
   }
   ```

   

3. 用单链表作存储结构，编写一个实现线性表中元素逆置的算法。

   ```cpp
   LNode* reverseL(LNode* head){
       LNode* cur = head, nxt, pre;
       while(cur!= nullptr){
           nxt = cur->next;
           cur->next = pre;
           pre = cur;
           cur = nxt;
       }
       return pre;
   }
   ```

4. 已知一个单链表中的数据元素含有三类字符（即字母字符，数字字符和其它字符），试编写算法，构造三个循环链表，使每个循环链表中只含有同一类的字符，且利用原表中的结点空间作为这三个表的结点空间。

   ```cpp
   ```

   

5. 试编写一个算法，找出一个循环链表中的最小值并删除。

   ```cpp
   LNode* deleteMin(LNode* head){
       LNode *cur = head->next, *pre = head,
       	  *minp = head->next, *minPre = head;
       while(cur != head){
           if(cur->val < minp->val){
               minp = cur;
               minPre = pre;
           }
           pre = cur;
           cur = cur->next;
       }
       minpre->next = minp->next;
       return minp;
   }
   ```

   

## 第5章

1. 以二叉链表作存储结构，编写一个算法将二叉树左、右子树进行交换的算法。

   ```cpp
   typedef struct BiTNode{
       char data;
       struct BiTNode *lchild,*rchild;
   }BiTNode,*BiTree;
   
   void exchange(BiTree &T){
   	if(T){
           if(T->lchild == nullptr && T->rchild == nullptr)return;
           else {
               BiTree tmp;
               tmp = T->lchild;
               T->lchild =T->rchild;
               T->rchild = tmp;
           }
           exchange(T->lchild);
           exchange(T->rchild);
       }    
   }
   ```

   

2. 一棵具有n个结点的**完全二叉树**存放在二叉树的**顺序存储**结构中，试编写**非递归**算法对该树进行**中序**遍历。

   前序：方法一，用栈来模拟递归——**递归是左递归，右递归。但是利用栈要相反**,先放右节点进栈，再放左节点进栈——取节点时就会先取到左节点，达到与递归一样的效果。

   ```cpp
   //前序 迭代
   void preOrd(int T[], int n){
       stack<int> st;
       int root = 0, lchild, rchild;
       s.push(root);
       while(!s.empty()){
           root = s.top();
           s.pop();
           cout<<T[root]<<" ";
           lchild = root * 2 + 1;
           rchild = root * 2 + 2;
           if(rchild < n) s.push(rchild);
           if(lchild < n) s.push(lchild);
       }
   }
   //另一种写法 : 与中序同样写法
   void preOrd(int T[], int n){
       stack<int> st;
       int root = 0;
       while(!st.empty() || root < n){
        	if(root < n){
               cout<<T[root]<<" ";.//根
               st.push(root);
               root = root * 2 + 1;//左
           }else{
               root = st.top();
               st.pop();
               root = root * 2 + 2;//右
           }        
       }
   }
   ```

   中序：中序排列的顺序是：`左节点，根节点，右节点`。那么我们在经过根节点的前面节点 不能释放

   - 栈`依次存入左节点所有点`，直到最左侧在栈顶。
   - 开始`抛出栈顶并访问`。(例如第一个抛出2)。如果有右节点。那么将`右节点加入栈中`，然后右节点一致左下遍历直到尾部。

   ```cpp
   void inOrd(int T[], int n){
       stack<int> st;
       int root = 0;
       while(!st.empty() || root < n){
           if(root < n){
               st.psuh(root);
               root = root * 2 + 1;//左
           }else{
               root = st.top();
               st.pop();
               cout<<T[root]<<" ";//根
               root = root * 2 + 2; //右
           }
       }
   }
   ```

   后序也有和前面差不多的方法，但需要额外的标记——一个节点访问第二次时才能输出——访问：

   - 第一次是入栈时
   - 第二次是子树解决完毕，**即将**出栈时。

   ```cpp
   void postOrd(int T[], int n){
       stack<int> st;
       map<int, int> mp;
       int root = 0;
       while(!st.empty() || root < n){
           if(root < n){
               st.push(root);
               map[root]++;
               root = root * 2 + 1;
           }else{
               root = st.top();
               if(map[root] == 2){//第二次访问时，抛出
                   st.pop();
                   cout<<T[root]<<" ";
                   root = n;//为了下个循环往上走
               }else{
                   map[root]++;
                   root = root * 2 + 2;
               }
           }
       }
   }
   ```

   

   **总结：**

   - 前序: 

     - `中入栈`——>`左入栈`——>左出栈——>中出栈——>`右入栈`——>右孩子入出——>右出栈 ,在**入栈**时候操作即可

   - 中序: 

     - 中入栈——>左入栈——>`左出栈`——>`中出栈`——>右入栈 ——>右孩子入出——>`右出栈`,按照**出栈**顺序即可

   - 后序：

     - 入栈，第一次访问
     - `即将出栈`。第二次访问，
     - 如果有右孩子，先不出栈把右孩子压入栈。**如果没右孩子，输出并从栈中弹出。**
     - 循环重复，直到栈为空

     

3. 试编写算法判别两棵二叉树是否等价。如果T1和T2都是空二叉树，或T1和T2的根结点的值相同，并且T1的左子树与T2的左子树是等价的；T1的右子树与T2的右子树是等价的。

   ### 递归写法：

   非常简单

   ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       //递归
       bool isSameTree(TreeNode* p, TreeNode* q) {
           if(p == nullptr && q == nullptr) return true;
           if(p == nullptr || q == nullptr) return false;
           if(p->val != q->val) return  false;
           return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
       }
   };
   ```

   ### 迭代写法： 借助栈

   ```cpp
   bool isSameTree(TreeNode* p, TreeNode* q) {
           stack<TreeNode*> st; //与队列差不多，但是用栈处理指针的顺序和队列相反
           st.push(p);
           st.push(q);
           while(!st.empty()){
               TreeNode* root1 = st.top();st.pop();
               TreeNode* root2 = st.top();st.pop();
               
               if(root1 == nullptr && root2 == nullptr) continue;            
               if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
               
               st.push(root1->left);
               st.push(root2->left);
               st.push(root1->right);
               st.push(root2->right);
           }
           return true;
       }
   ```

   ### 用队列也是一样的

   ```cpp
    bool isSameTree(TreeNode* p, TreeNode* q) {
       queue<TreeNode*> que;  
       que.push(p);
       que.push(q);
       while(!que.empty()){
           TreeNode* root1 = que.front();que.pop();
           TreeNode* root2 = que.front();que.pop();
           
           if(root1 == nullptr && root2 == nullptr)continue;
           if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
    
           que.push(root1->left);
           que.push(root2->left);
           que.push(root1->right);
           que.push(root2->right);
       }
       return true;
   }
   
   ```

   

4. 设计一个实现一棵二叉树复制的算法。

   ```cpp
   TNode* copyBitTree(TNode* head){
       TNode* ansHead;
       if(head == nullptr){
           return nullptr;
       }
       TNode* leftc = copyBitTree(head->left);
       TNode* rightc = copyBitTree(head->right);
       ansHead->left = leftc;
       ansHead->right = rightc;
       return ansHead;
   }
   ```

   

5. 编写一个将二叉树的所有叶子结点从左向右链接成单链表的算法。

   ```cpp
   void leafLink(TNode* root, TNode*&first, TNode*&pre){
       if(root == nullptr)return;
       if(root->right == nullptr && root->left == nullptr){
           if(first == nullptr){
               first = root; //保存的第一个叶子节点
               pre = first;
           }else{
    			pre->right = root;
               pre = pre->right;
           }
       }
       if(root->left) leafLink(root->left);
       if(root->right) leafLink(root->right);
   }
   ```

   

6. 设具有n个结点的完全二叉树采用顺序存储结构，试写一个算法将该顺序存储结构转换为二叉链式存储结构。

   ```cpp
   TNode* seqToBit(int &t[], int root, int tSize){
       if(root < tSize) return nullptr;
       TNode* head;head->val = t[root];
       head->left = seqToBit(t, root*2+1);
       head->righgt = seqToBit(t, root*2+2);
       return head;
   }
   ```

   

7. 设具有n个结点的二叉树采用二叉链式存储结构，试写出一个算法将该二叉链式存储结构转换为顺序存储结构。

   ```cpp
   void BitToSeq(int &t[], TNode* node, int i){
       if(node){
           t[i] = node->val;
           BitToSeq(t, node->left, i*2+1);
           BitToSeq(t, node->right, i*2+2);
       }else{
           t[i] = '/';
       }
   }
   ```

   

## 第7章

1. 设二叉树采用二叉链式结构存储，试写出一个算法判断该二叉树是否为二叉查找树。

   ```cpp
   class Solution {
   public:
       //辅助函数
       bool isValidBST(TreeNode*root, TreeNode*min, TreeNode*max){
           if(root == nullptr) return true;
           //必须是在(min,max)
           if(min != nullptr && root->val <= min->val) return false;
           if(max != nullptr && root->val >= max->val) return false;
           //递归判断左右子树并传递范围
           return isValidBST(root->left,min,root) & isValidBST(root->right, root, max);
       }
       bool isValidBST(TreeNode* root) {
           return isValidBST(root, nullptr, nullptr);
       }
   };
   ```

2. 编写一个采用二叉链式结构做存储结构的二叉排序树建立和查找算法。

   ```cpp
   //插入操作
   TreeNode* insertIntoBST(TreeNode* root, int val) {
       //找到空处
       if(root == nullptr) return new TreeNode(val);
       if(root->val < val) root->right = insertIntoBST(root->right, val);
       if(root->val > val) root->left = insertIntoBST(root->left, val);
       return root;
   }
   //建立树
   TreeNode* createTree(int sz){
       TreeNode* root = new TreeNode();
       for(int i = 0;i<sz;i++){
           //调用插入函数进行建树
           int v;cin>>v;
           insertIntoBST(root, v);
       }
       return root;//返回该节点
   }
   //查找算法
   TreeNode* searchBST(TreeNode* root, int val) {
       if(root == nullptr)return nullptr;
       int v = root->val;    
       if(v == val) return root;
       else if(v < val) return searchBST(root->right, val);
       else if(v > val) return searchBST(root->left, val);
       return nullptr;//这步其实是不会走到的。
   }
   
   ```

   

3. 用线性探测方法解决冲突的散列存储、查找以及删除操作。【散列函数自定义】

   > 线性探测（Linear Probing）：当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，                              存储位置已经被占用，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 
   >
   > ps：采用线性探测方法解决冲突时，删除操作不能单存地把删除地元素设置为空，否则查找操作将可能失败。

   ```cpp
   class HashNode {
   public:
   	int value;
   	int key;
   	HashNode(int key, int value) : value(value), key(key) {}
   };
   
   int hash(int key) {
       return key % capacity;
   }
   int get(int key) {    //查询方法
       for(int i = hash(key);keys[i]!=null;i=(i+1)%M)
           if(keys[i] == key)
               return vals[i];
       return null;
   }
   void insert(int key,int val) {    //插入方法
       int i;
       for(i=hash(key); keys[i]!=null; i=(i+1)%M)
           if(keys[i] == key)	{    //已存在键，更新值
               vals[i]=val; 
               return;
           }
       //查询键无果，插入键值对
       keys[i] = key;
       vals[i] = val;
       N++;
   }
   void delete(Key key) {
       if(!contains(key))	return;
       int i = hash(key);
       //找到键值对在散列表中的位置
       while(!key == keys[i])
           i = (i+1)%M;
       //将键值对删除
       keys[i] = null;
       vals[i] = null;
       //将具有相同散列值的排在已删除键值对之后的键值对前移，方法是取出重新插入
       i = (i+1)%M;
       while(keys[i]!=null) {
           //取出后续键值对
           Key keyTo = keys[i];
           Value valTo = vals[i];
           keys[i] = null;
           vals[i] = null;
           N--;
           //重新插入
           put(keyTo,valTo);
           i = (i+1)%M;
       }
       N--;
   }
   
   
   ```

   

4. 用拉链方法解决冲突的散列存储、查找以及删除操作。【散列函数自定义】

   ```cpp
   int get(Key key) {                       //获取符号表中的指定键
       int i = hash(key);
       return st[i].get(key);
   } 
   void put(Key key, Value val) {             //存放一个键值对到符号表
       if (val == null) {
           delete(key);
           return;
       }
       //临界时，则将表大小增加一倍
       if (n >= m) resize(2*m);
       int i = hash(key);
       if (!st[i].contains(key)) n++;
       st[i].put(key, val);
   } 
   void delete(Key key) {
       if (key == null) throw error();
   
       int i = hash(key);
       if (st[i].contains(key)) n--;
       st[i].delete(key);
   
       // 如果列表的平均长度<= 2，则将表大小减半
       if (m > INIT_CAPACITY && n <= 2*m) resize(m/2);
   } 
   ```

   

## 第8章

1. 分别写出用邻接矩阵和邻接表做图的存储结构，并分别实施广度优先遍历和深度优先遍历。

   邻接矩阵

   ```cpp
   queue<int>Q;
   const int maxn = 105;
   int adj[maxn][maxn] = { 0 };    //定义邻接矩阵
   int m;//m个点
   void BFS(int head) {
   	Q.push(head);
   	int p;
   	while (!Q.empty()) {
   		p = Q.front();
   		cout << p << " ";
   		Q.pop();
   		for (int i = 1; i <= m; i++) {
   			if (adj[p][i]) {
   				Q.push(i);
   			}
   		}
   	}
   	cout << endl;
   }
   
   void DFS(int p) {
   	cout << p << " ";
   	for (int i = 1; i <= m; i++) {
   		if (adj[p][i]) {
   			DFS(i);
   		}
   	}
   	return;
   }
   ```

   邻接表

   ```cpp
   struct node {
   	int data;
   	node* next;
   };
   node graph[N];
   queue<node *>Q;
   
   void BFS(node *head) {
   	Q.push(head);
   	node* p;
   	while (!Q.empty()) {
   		p = Q.front();
   		Q.pop();
   		cout << p->data << " ";
   		while (p->next != NULL) {
   			Q.push(p->next);
   			p = p->next;
   		}
   	}
   }
   
   void DFS(node* head) {
   	if (head == NULL) {
   		return;
   	}
   	node* p=head;
   	cout << p->data << " ";
   	while (p->next != NULL) {
   		DFS(p->next);
   		p = p->next;
   	}
   	return;
   }
   ```

   

2. 写出求最小生成树的算法。

   > 连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树。
   >
   > 构造最小生成树，要解决以下两个问题：
   > (1).尽可能选取权值小的边，但不能构成回路（也就是环）。
   > (2).选取n-1条恰当的边以连接网的 n个顶点。

   > 有Prim算法和Krusal算法等。
   >
   > 普里姆算法的基本思想：
   > 1）清空生成树，任取一个顶点加入生成树；
   > 2）在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树；
   > 3）重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树。

   ```cpp
   int Prim(int graph[][MAX], int n)//二维数组作为参数如何使用？
   {
       int sta[MAX];//存放某一条边的起点值
       int lowcost[MAX];//存放以i为终点的的边的最小的权值
       int min,minid,sum=0;//min用来存放最小权值，minid用来存放权值最小的边所对应的终点
       for(int i=2;i<=n;i++)
       {
           lowcost[i]=graph[1][i];//初始化lowcost[i]，并把他们的初始值都看作是从节点1出发到i的权值
           sta[i]=1;//起点赋值为1
       }
       sta[1]=0;//节点1进入最小生成树
       for(int h=2;h<=n;h++)
       {
           min=MAXCOST;//找到最小的，先来个较大值
           for(int j=2;j<=n;j++)
           {
               if(lowcost[j]<min&&lowcost[j]!=0)//如果找到权值较小的就赋值给min，并把终点j赋值给minid。
               {    min=lowcost[j]; minid=j;}
           }
           lowcost[minid]=0;//这条边已经进入最小生成树，所以把值置为0
           sum+=min;
           for(int s=2;s<=n;s++)
           {
               if(lowcost[s]<graph[minid][s])//如果原先的lowcost[j]的值大于以minid为起点到终点j的权值，则更新它，并把起点更新为minid
               {
                   lowcost[s]=graph[minid][s];
                   sta[s]=minid;
               }
           }
       }
       return sum;
   
   }
   ```

   > Kruskal算法的步骤：
   >
   > 1.对所有边进行从小到大的排序。
   >
   > 2.每次选一条边（最小的边），如果如果形成环，就不加入(u,v)中，否则加入。那么加入的(u,v)一定是最佳的。

   ```CPP
   struct edge{
   	int u, v;
   	int cost;	
   }E[maxE];
   bool cmp(edge a, edge b){
   	return a.cost < b.cost;
   }
    
   //并查集 
   int father[maxV];
   int findFather(int x){
   	int a = x;
   	while(x != father[x]){
   		x = father[x];
   	}
   	//路径压缩
   	while(a != father[a]){
   		int z = a;
   		a = father[a];
   		father[z] = a;
   	} 
   	return x;
   }
    
   //kruskal算法部分赶回最小生成树的边权之和,参数n为顶点的个数,m为图的边数
   int kruskal(int n, int m){
   	int ans = 0, Num_Edge = 0;
   	for(int i = 0; i < n; ++i){
   		father[i] = i;
   	} 
   	sort(E, E + m, cmp);
   	for(int i = 0; i < m; ++i){
   		int faU = findFather(E[i].u);
   		int faV = findFather(E[i].v);
   		if(faU != faV){
   			father[faU] = faV;
   			ans += E[i].cost;
   			Num_Edge++;
   			if(Num_Edge == n - 1) break;
   		}
   	}
   	if(Num_Edge != n - 1){
   		return -1;
   	}else{
   		return ans;
   	}
   }  
   
   ```

   

3. 写出求一点顶点到其余各个顶点的最短路径的算法 

   > 总结一下，Dijkstra算法的流程就是，不断取出**离顶点最近**而**没有被访问过**的点，松弛它和它能到达的所有点。
   >
   > 如何取出离顶点最近的点？如果暴力寻找，那就是朴素的Dijkstra算法，时间复杂度是O^2
   >
   > 但我们可以采取**堆优化**。具体而言，我们可以用一个**优先队列**（或手写堆，那样更快）来维护所有节点。这样可以实现 mlogm 的算法

   二维矩阵存图+堆优化Dijkstra算法

   ```cpp
   int dis[maxn], vis[maxn] = {0};
   vector<pair<int, int>> E[maxn];//存图 <u, d> E[i]到u点距离为d
   typeof pair<int ,int> PAIR; //<起点到x点的距离, x>
   #define MP make_pair 
   priority_queue<PAIR, vector<PAIR>, greater<PAIR>> Q;//距离短的优先级高，也就是 Q.top()
   void Dij(int s){
   	fill(dis, dis + maxn, INT_MAX);
       fill(vis, vis + maxn, 0);
       dis[s] = 0;
       Q.push(MP(0,s));
       while(!Q.empty()){
       	int u = Q.top().second;Q.pop();
           if(vis[u])continue;
           vis[u] = 1;
           for(auto it : E[u]){
           	if(dis[it.first] > it.second + dis[u]){
               	dis[it.first] = it.second + dis[u];//更新dis
                   //或许还有其他的操作
               }else if(){}//有时还有其他的判断条件
               if(!vis[it.first]) Q.push(MP(dis[it.first], it.first));
           }
       }    
   }
   ```

   

4. 写出求有向图拓扑序列的算法。

   ```cpp
   // deg是入度，在存图的时候需要录入数据
   // A是排序后的数组
   int deg[MAXN], A[MAXN];
   bool toposort(int n)
   {
       int cnt = 0;
       queue<int> q;
       for (int i = 1; i <= n; ++i)
           if (deg[i] == 0)
               q.push(i);
       while (!q.empty())
       {
           int t = q.front();
           q.pop();
           A[cnt++] = t;
           for (auto to : edges[t])
           {
               deg[to]--;
               if (deg[to] == 0) // 出现了新的入度为0的点
                   q.push(to);
           }
       }
       return cnt == n;
   }
   ```

   

## 第9章

1. 写出以单链表做存储结构的直接插入排序算法。

   ```cpp
   struct node {
   	int data;
   	node* next;
   };
   
   void insert(node *head,int a) {
   	if (head == NULL) {
   		node* p = new node;
   		p->data = a;
   		head = p;
   		return;
   	}
   	while (head->next->data<a&&head->next!=NULL) {
   		head = head->next;
   	}
   	if (head->next == NULL) {
   		node* p = new node;
   		p->data = a;
   		head ->next= p;
   	}
   	else {
   		node *temp=head->next;
   		node* p = new node;
   		p->data = a;
   		head->next = p;
   		head->next->next = temp;
   	}
   }
   
   void iii(node *head,int *a,int n){
   	for (int i = 0; i < n; i++) {
   		insert(head, a[i]);
   	}
   	return;
   }
   ```

   

2. 写出快速排序算法。

   ```cpp
   void Sort(int* a,int l,int r) {
   	if (l<r) {
   		int key = a[l];//基准
   		int i = l, j = r;
   		while (i < j) {
   			while (i < j && a[j] > key) {
   				j--;
   			}
   			if (i < j) {
   				a[i] = a[j];
   				i++;
   			}
   			while (i < j && a[i] < key) {
   				i++;
   			}
   			if (i < j) {
   				a[j] = a[i];
   				j--;
   			}
   		}
   		Sort(a, l, i - 1);
   		Sort(a, i + 1, r);
   	}
   }
   ```

   

3. 写出堆排序算法。

   > 堆排序的基本思想是利用heap这种数据结构(可看成一个完全二叉树)，使在排序中比较的次数明显减少。
   >
   > 堆排序的时间复杂度为O(n*log(n))， 非稳定排序，原地排序(空间复杂度O(1))。
   >
   > 堆排序的关键在于建堆和调整堆，下面简单介绍一下建堆的过程：
   >
   > 第1趟将索引0至n-1处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的最后一个节点交换，就使的这组数据中最大(最小)值排在了最后。
   >
   > 第2趟将索引0至n-2处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第二个节点交换，就使的这组数据中最大(最小)值排在了倒数第2位。
   >
   > …
   >
   > 第k趟将索引0至n-k处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第k个节点交换，就使的这组数据中最大(最小)值排在了倒数第k位。
   >
   > 其实整个堆排序过程中, 我们只需重复做两件事：
   >
   > 建堆(初始化+调整堆, 时间复杂度为O(n));
   >
   > 拿堆的根节点和最后一个节点交换(siftdown, 时间复杂度为O(n*log n) ).
   >
   > 因而堆排序整体的时间复杂度为O(n*log n).

   ```cpp
   void adjust(int arr[], int len, int index)
   {
       int left = 2*index + 1;
       int right = 2*index + 2;
       int maxIdx = index;
       if(left<len && arr[left] > arr[maxIdx]) maxIdx = left;
       if(right<len && arr[right] > arr[maxIdx]) maxIdx = right;  // maxIdx是3个数中最大数的下标
       if(maxIdx != index)                 // 如果maxIdx的值有更新
       {
           swap(arr[maxIdx], arr[index]);
           adjust(arr, len, maxIdx);       // 递归调整其他不满足堆性质的部分
       }
   
   }
   void heapSort(int arr[], int size)
   {
       for(int i=size/2 - 1; i >= 0; i--)  // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)
       {
           adjust(arr, size, i);
       }
       for(int i = size - 1; i >= 1; i--)
       {
           swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
           adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
       }
   }
   ```

   