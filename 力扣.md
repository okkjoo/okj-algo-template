# åŠ›æ‰£åˆ·é¢˜ç¬”è®°

## å•é“¾è¡¨

### [206. åè½¬é“¾è¡¨]å•é“¾è¡¨åè½¬|é€’å½’|é€’æ¨å†™æ³•

#### é€’å½’å†™æ³•

reverseList å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹headï¼Œå°†ã€Œä»¥headä¸ºèµ·ç‚¹ã€çš„é“¾è¡¨åè½¬ï¼Œå¹¶è¿”å›åè½¬ä¹‹åçš„å¤´ç»“ç‚¹ã€‚

é‚£ä¹ˆåœ¨é€’å½’ä¸­`ListNode* last = reverseList(head->next);` è¿”å›çš„ last ä¹Ÿå°±æ˜¯ åé¢é‚£ä¸€æ®µçš„åè½¬åçš„å¤´ç»“ç‚¹ã€‚

`head->next->next = head;` åˆ™æ˜¯å°†åŸå…ˆheadæŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„nextæŒ‡äº†å›æ¥ï¼Œä¹Ÿå°±æ˜¯ åä¸€æ®µç¿»è½¬è¿‡æ¥åçš„å°¾éƒ¨æŒ‡å‘ head

`head->next = nullptr;` åˆ™æ˜¯å°†åŸå…ˆå¤´ç»“ç‚¹æŒ‡å‘ null ï¼Œå› ä¸ºæ­¤æ—¶ä»–å·²ç»æ˜¯å°¾éƒ¨äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //base case
        if(head == nullptr || head->next == nullptr)return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};

```

#### è¿­ä»£å†™æ³•

```cpp
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		ListNode *temp; // ä¿å­˜åŸæœ¬curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ ç”¨nxtæŒ‡é’ˆæˆ–è®¸æ›´ä¸ºåˆé€‚
		ListNode *cur = head;
		ListNode *pre = NULL; //æ›´æ–°åçš„å¤´
		while (cur)
		{
			temp = cur->next; // ä¿å­˜ä¸€ä¸‹ curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºæ¥ä¸‹æ¥è¦æ”¹å˜cur->next
			cur->next = pre;  // ç¿»è½¬æ“ä½œ
			//æ›´æ–°ä¸€ä¸‹pre å’Œ curæŒ‡é’ˆ
			pre = cur;	//preç§»åˆ°ç°åœ¨curæ‰€åœ¨
			cur = temp; //curç§»åˆ°tempå³åŸå…ˆçš„cur->next;
		}
		return pre;
	}
};
```

é€’æ¨åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šéƒ½ç¢¾å‹é€’å½’ï¼Œä½†æˆ‘è§‰å¾—é€’å½’çš„æ–¹æ³•éå¸¸ç²¾å¦™â€”â€”é€’å½’çš„é­…åŠ›ã€‚

### [92.åè½¬é“¾è¡¨ â…¡]é€’å½’

åè½¬ä¸€ä¸ªåŒºé—´çš„é“¾è¡¨ã€‚æ€ä¹ˆåšå‘¢ã€‚

æˆ‘ä»¬å¯ä»¥å…ˆæ¢ä¸ªæ€è€ƒæ–¹å‘â€”â€”**åè½¬å‰nä¸ª**

```cpp
ListNode* successor = nullptr; // åé©±èŠ‚ç‚¹
ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            //è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head->next;
            return head;
        }
    	// ä»¥ head->next ä¸ºèµ·ç‚¹ï¼Œ åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        ListNode* last = reverseN(head->next, n-1);
        
        head->next->next = head;
    	// è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head->next = successor;
        return last;        
    }
```

![image-20211115151904252](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211115151904252.png)

é‚£ä¹ˆå°±å¯ä»¥å¼€å§‹å®ç°åè½¬é“¾è¡¨çš„ä¸€éƒ¨åˆ†äº†

` ListNode* reverseBetween(ListNode* head, int left, int right) `åè½¬ [left, right], é‚£ä¹ˆå½“ left == 1 æ—¶ï¼Œä¹Ÿå°±ç›¸å½“äºå‰é¢çš„ åè½¬å‰nä¸ªå…ƒç´ â€”â€”ä¸è¿‡è¿™é‡Œæ˜¯åè½¬å‰ right ä¸ªå…ƒç´ ç½¢äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next,n-1);
        
        head->next->next = head;
        head->next = successor;
        return last;
        
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1){
            //ç›¸å½“äºåè½¬å‰ right ä¸ªå…ƒç´ 
            return  reverseN(head,right);
        }
		//å‰ç§»åè½¬èµ·ç‚¹æ¥è§¦å‘ left == 1 çš„æƒ…å†µ
        head->next = reverseBetween(head->next,left-1,right-1);
        return head;
    }
};
```

é€’å½’æ–¹æ³•éå¸¸ç²¾å¦™ï¼Œä½†æ˜¯æ•ˆç‡ç¡®å®ä½ï¼Œä¸è®ºæ˜¯æ—¶é—´è¿˜æ˜¯ç©ºé—´å¤æ‚åº¦å‡ä¸º O(N)

è¿­ä»£çš„è¯ï¼Œè‡³å°‘ç©ºé—´æ˜¯O(1)ã€‚

#### è¿­ä»£æ³•åè½¬åŒºé—´

ä¸ ç¬¬206é¢˜ ç±»ä¼¼

```cpp
//åè½¬åŒºé—´ [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //è¿”å›åè½¬åçš„èŠ‚ç‚¹ç”¨äºè¿æ¥
        return pre;
    }
```

### [[25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)]é€’å½’

è¯¥é—®é¢˜å…·æœ‰æ˜æ˜¾çš„é€’å½’æ€§è´¨ã€‚

å¦‚ä¸‰ä¸ªä¸€ç»„åè½¬ï¼Œé‚£ä¹ˆå°†å‰ä¸‰ä¸ªåè½¬åï¼Œåé¢çš„ä¸å°±åˆæ˜¯ä¸€æ¡é•¿åº¦çŸ­ä¸‰çš„é“¾è¡¨ï¼Ÿ

1. åè½¬ head å¼€å¤´çš„ k ä¸ªå…ƒç´ 
2. å°†ç¬¬ k+1 ä¸ªå…ƒç´ ä½œä¸º head å‚æ•°ä¼ å…¥é€’å½’å‡½æ•°
3. å°†ç»“æœè¿æ¥èµ·æ¥
4. ...é‡å¤

base case: åé¢å…ƒç´ ä¸è¶³ k ä¸ª äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //åè½¬åŒºé—´ [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //è¿”å›åè½¬åçš„èŠ‚ç‚¹ç”¨äºè¿æ¥
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)return nullptr;
        ListNode *a, *b;
        a = head, b = head;
        for(int i = 0; i < k; i++){
            //base case 
            if(b == nullptr) return head;
            b = b->next;
        }
        //åè½¬å‰kä¸ª
        ListNode* newHead  =  reverse(a, b);
        //é€’å½’åè½¬ååºé“¾è¡¨å¹¶ä¸å‰é¢èŠ‚ç‚¹ç›¸è¿
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```

### [234. å›æ–‡é“¾è¡¨](https://leetcode-cn.com/problems/palindrome-linked-list/)

å•é“¾è¡¨æ— æ³•å€’ç€éå†ï¼Œæ— æ³•ä½¿ç”¨åŒæŒ‡é’ˆæŠ€å·§ã€‚

ç›´æ¥åè½¬å•é“¾è¡¨åå†è¿›è¡Œæ¯”è¾ƒ...ä¹Ÿå¯è¡Œ

ä½†è¿˜æ˜¯æ¥ç‚¹ä¸åŒçš„â€”â€”åƒäºŒå‰æ ‘éå†æ€æƒ³ä¸€æ ·å€’åºéå†

> æ ‘ç»“æ„ä¸è¿‡æ˜¯é“¾è¡¨çš„è¡ç”Ÿã€‚é‚£ä¹ˆï¼Œ**é“¾è¡¨å…¶å®ä¹Ÿå¯ä»¥æœ‰å‰åºéå†å’Œååºéå†** â€”â€”labuladong

å®é™…ä¸Šå°±æ˜¯è½®æµå°†é“¾è¡¨èŠ‚ç‚¹è½®æµæ”¾å…¥ä¸€ä¸ªæ ˆä¸­ï¼Œå†ä¾æ¬¡æ‹¿å‡ºæ¥ï¼Œé¡ºåºè‡ªç„¶å°±æ˜¯åçš„ã€‚

ä½†æ˜¯è¿™æ ·çš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ä¸ç›´æ¥é€ ä¸€æ¡åè½¬é“¾è¡¨ä¸€æ ·éƒ½æ˜¯O(N)ã€‚

---

æ›´å¥½çš„æ€è·¯ï¼š

- ç”¨å¿«æ…¢æŒ‡é’ˆæ³•æ¥å…ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹

  ```cpp
  while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
  }
  // slow æŒ‡é’ˆç°åœ¨æŒ‡å‘é“¾è¡¨ä¸­ç‚¹
  ```

  

  - fast æŒ‡å‘ null å°±è¯´æ˜é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼Œslowè¿˜è¦æ›´è¿›ä¸€èŠ‚

    ```cpp
    if(fast != nullptr){
        slow = slow->next;
    }
    ```

  - å¦åˆ™è¯´æ˜ä¸ºå¶æ•°ï¼Œæ— éœ€å¤šä½™æ“ä½œ

- å†åè½¬slowä¸ºå¤´çš„ååºé“¾è¡¨

- æ¯”è¾ƒä¸¤è¾¹çš„é“¾è¡¨

æ—¶é—´å¤æ‚åº¦ä¸ºO(N)ã€ç©ºé—´å¤æ‚åº¦ä¸ºO(N)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //åè½¬é“¾è¡¨
    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, *cur = head, *next;
        while(cur!=nullptr){
            next = cur->next;
            cur->next  = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        ListNode *fast, *slow;
        fast= slow = head;
        while(fast != nullptr &&fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        if(fast != nullptr) slow = slow->next;
        //æ­¤æ—¶slowå°±æ˜¯ä¸­ç‚¹
        ListNode *left = head, *right = reverse(slow);
        while(right != nullptr){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }
};
```





## äºŒå‰æ ‘

### [100.ç›¸åŒçš„æ ‘] | äºŒå‰æ ‘

#### é€’å½’å†™æ³•ï¼š

éå¸¸ç®€å•

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //é€’å½’
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr) return true;
        if(p == nullptr || q == nullptr) return false;
        if(p->val != q->val) return  false;
        return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
    }
};
```

#### è¿­ä»£å†™æ³•ï¼š å€ŸåŠ©æ ˆ

```cpp
bool isSameTree(TreeNode* p, TreeNode* q) {
        stack<TreeNode*> st; //ä¸é˜Ÿåˆ—å·®ä¸å¤šï¼Œä½†æ˜¯ç”¨æ ˆå¤„ç†æŒ‡é’ˆçš„é¡ºåºå’Œé˜Ÿåˆ—ç›¸å
        st.push(p);
        st.push(q);
        while(!st.empty()){
            TreeNode* root1 = st.top();st.pop();
            TreeNode* root2 = st.top();st.pop();
            
            if(root1 == nullptr && root2 == nullptr) continue;            
            if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
            
            st.push(root1->left);
            st.push(root2->left);
            st.push(root1->right);
            st.push(root2->right);
        }
        return true;
    }
```

#### ç”¨é˜Ÿåˆ—ä¹Ÿæ˜¯ä¸€æ ·çš„

```cpp
 bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<TreeNode*> que;  
    que.push(p);
    que.push(q);
    while(!que.empty()){
        TreeNode* root1 = que.front();que.pop();
        TreeNode* root2 = que.front();que.pop();
        
        if(root1 == nullptr && root2 == nullptr)continue;
        if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
 
        que.push(root1->left);
        que.push(root2->left);
        que.push(root1->right);
        que.push(root2->right);
    }
    return true;
}

```

## å­—ç¬¦ä¸²

### [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

æ‰¾æœ€é•¿å›æ–‡å­ä¸²ä¹‹å‰ï¼Œå…ˆæ€è€ƒï¼šæ€ä¹ˆæ‰¾å›æ–‡å­ä¸²ï¼Ÿ

**ä»ä¸­é—´å¾€ä¸¤è¾¹æ‰©æ•£æ¥åˆ¤æ–­**,è¿˜æœ‰å¥‡å¶åˆæ€ä¹ˆåŒºåˆ†å‘¢...

```cpp
class Solution {
public:
    //ä¼ å…¥ä¸¤ä¸ªæŒ‡é’ˆå°±ä¸ç”¨åˆ†è¾¨å­—ç¬¦ä¸²é•¿åº¦å¥‡å¶æƒ…å†µ
        //ä¸­å¿ƒä¸ºs[l]ã€s[r],å¦‚æœé•¿åº¦ä¸ºå¥‡æ•°ï¼Œl==r
    string palindrome(string&s, int l, int r){
        while(l >= 0 && r < s.size() && s[l] == s[r]){
            l--;r++;
        }
        return s.substr(l + 1, r - 1 - l);
    }
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++){
            string s1 = palindrome(s, i, i);
            string s2 = palindrome(s, i, i + 1);
            res = res.size() > s1.size()? res: s1;
            res = res.size() > s2.size()? res: s2;
        }
        return res;
    }
};
```

æ—¶é—´å¤æ‚åº¦ O(N^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚

è¿˜æœ‰ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(N)çš„ç®—æ³•ï¼Œä½†æ˜¯åŠ›æ‰£è¿™é‡Œå¹¶ä¸éœ€è¦ï¼Œå¦‚æœæ˜¯ç«èµ›å¯èƒ½å°±éœ€è¦äº†â€”â€”é©¬æ‹‰è½¦ç®—æ³•ï¼Œæˆ‘ä¹Ÿå†™è¿‡[ä¸€ç¯‡ç¬”è®°](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8)ã€‚

## äºŒå‰æœç´¢æ ‘BST



#### BST çš„ç‰¹æ€§ï¼šå·¦å°å³å¤§

1. å¯¹äº BST çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹`node`ï¼Œå·¦å­æ ‘èŠ‚ç‚¹çš„å€¼éƒ½æ¯”`node`çš„å€¼è¦å°ï¼Œå³å­æ ‘èŠ‚ç‚¹çš„å€¼éƒ½æ¯”`node`çš„å€¼å¤§ã€‚
2. å¯¹äº BST çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹`node`ï¼Œå®ƒçš„å·¦ä¾§å­æ ‘å’Œå³ä¾§å­æ ‘éƒ½æ˜¯ BSTã€‚
3. **ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼šBST çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼ˆå‡åºï¼‰**ã€‚

### 230. BSTç¬¬Kå°çš„å…ƒç´ |**Medium**

æœ€æ˜æ˜¾çš„æ€è·¯å°±æ˜¯å‡åºæ’åºâ€”â€”ä¸­åºéå†ï¼Œç„¶åæ‰¾ç¬¬`k`ä¸ªå…ƒç´ ï¼Œä½†è¿™å¹¶ä¸æ˜¯æœ€å¥½çš„è§£æ³•ã€‚

åƒçº¢é»‘æ ‘è¿™ç§æ”¹è‰¯çš„è‡ªå¹³è¡¡ BSTï¼Œå¢åˆ æŸ¥æ”¹éƒ½æ˜¯`O(logN)`çš„å¤æ‚åº¦ï¼Œè®¡ç®—ç¬¬`k`å°å…ƒç´ ï¼Œæœ€å¥½çš„ç®—æ³•è‚¯å®šä¹Ÿæ˜¯å¯¹æ•°çº§åˆ«çš„å¤æ‚åº¦ã€‚

å…¨æ ‘éå†å¿…ç„¶æ˜¯å¤æ‚åº¦éå¸¸é«˜çš„ï¼Œè€Œå€ŸåŠ©äºŒå‰æœç´ æ ‘çš„æ€§è´¨â€”â€”æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥é€šè¿‡å¯¹æ¯”è‡ªèº«çš„å€¼åˆ¤æ–­å»å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘æœç´¢ç›®æ ‡å€¼ï¼Œä»è€Œ**é¿å…äº†å…¨æ ‘éå†**ï¼Œè¾¾åˆ°å¯¹æ•°çº§å¤æ‚åº¦ã€‚

æ‰¾åˆ°ä¸€ä¸ªç‚¹ï¼Œå…¶æ’åä¸ºmï¼š

1. m==k,ç»“æŸ
2. k<m,è¯´æ˜ç¬¬kä¸ªåœ¨å…¶å·¦å­æ ‘
3. k>m,è¯´æ˜ç¬¬kä¸ªåœ¨å³å­æ ‘

æ­¤æ—¶æ—¶é—´å¤æ‚åº¦å°±é™ä¸ºå¯¹æ•°çº§åˆ«äº†ã€‚

é‚£ä¹ˆé—®é¢˜å°±æ˜¯è®¿é—®æ¯ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè¯¥èŠ‚ç‚¹è¦çŸ¥é“è‡ªå·±çš„æ’ä½â€”â€”èŠ‚ç‚¹ç»“æ„ä½“ä¸­æœ‰é¢å¤–è®°å½•è‡ªèº«æ’ä½çš„æ ‡è®°ã€‚**ä½†æ˜¯è¿™é¢˜æ²¡æœ‰ã€‚**æ‰€ä»¥è¿™é¢˜æ–¹æ³•ä¹Ÿå°±åªæœ‰æ™®æ™®é€šé€šçš„ä¸­åºéå†æ’åºäº†~ä½†æ˜¯è¿™ä¸ªä¼˜åŒ–æ‰‹æ®µéå¸¸å¸¸è§ä»¥åŠå®ç”¨ã€‚

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 å¦‚æœè¦ä¼˜åŒ–è¿™é‡Œè¦æœ‰ä¸€ä¸ªæ ‡è®°
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;//è®°å½•ç»“æœ
    int rank = 0;//è®°å½•å½“å‰å…ƒç´ çš„æ’å
    void traverse(TreeNode* root, int k){
        if(root == nullptr)return;        
        traverse(root->left, k);
        //ä¸­åºéå†
        rank++;
        if(k==rank){//æ‰¾åˆ°ç¬¬kå°çš„å…ƒç´ 
            res = root->val;
            return;
        }
        traverse(root->right, k);
    }
    int kthSmallest(TreeNode* root, int k) {
        traverse(root, k);
        return res;
    }
};
```

### [538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

>  ä½¿æ¯ä¸ªèŠ‚ç‚¹ `node` çš„æ–°å€¼ç­‰äºåŸæ ‘ä¸­å¤§äºæˆ–ç­‰äº `node.val` çš„å€¼ä¹‹å’Œã€‚

é‚£ä¹ˆå°±æ˜¯éœ€è¦é™åºæ’åºï¼Œå¹¶å°†æ¯ä¸ªç‚¹çš„å‰é¢ä¹‹å’Œï¼ˆåŒ…æ‹¬è¿™ä¸ªç‚¹ï¼‰ä½œä¸ºè¯¥ç‚¹æ–°çš„å€¼ã€‚

æ™®é€šçš„ä¸­åºéå†å°±å¯ä»¥åšåˆ°å‡åºæ’åºï¼Œè€Œåå‘çš„ä¸­åºéå†å°±å¯ä»¥åšåˆ°é™åºæ’åºï¼ˆå³ä¸­å·¦ï¼‰ã€‚

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }
    //è®°å½•åˆ°æŸç‚¹ä¹‹å‰çš„ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode* root){
        if(root == nullptr)return;
        traverse(root->right);
        //ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root->val;
        //å°†BSTè½¬åŒ–ä¸ºç´¯åŠ æ ‘
        root->val = sum;
        traverse(root->left);
    }
};
```

### 98. éªŒè¯äºŒå‰æœç´¢æ ‘

**æ ¹æ® BST çš„å®šä¹‰ï¼Œ`root`çš„æ•´ä¸ªå·¦å­æ ‘éƒ½è¦å°äº`root.val`ï¼Œæ•´ä¸ªå³å­æ ‘éƒ½è¦å¤§äº`root.val`**ã€‚æ‰€ä»¥è¿˜è¦æŠŠrootçš„çº¦æŸä¹Ÿä¼ é€’ç»™å·¦å³å­æ ‘ï¼Œé€šè¿‡ä½¿ç”¨è¾…åŠ©å‡½æ•°ï¼Œå¢åŠ å‡½æ•°å‚æ•°åˆ—è¡¨ï¼Œåœ¨å‚æ•°ä¸­æ·»åŠ é¢å¤–ä¿¡æ¯ï¼Œå°†çº¦æŸä¼ é€’ç»™å…¶å­æ ‘çš„æ‰€æœ‰ç»“ç‚¹ã€‚

```cpp
class Solution {
public:
    //è¾…åŠ©å‡½æ•°
    bool isValidBST(TreeNode*root, TreeNode*min, TreeNode*max){
        if(root == nullptr) return true;
        //å¿…é¡»æ˜¯åœ¨(min,max)
        if(min != nullptr && root->val <= min->val) return false;
        if(max != nullptr && root->val >= max->val) return false;
        //é€’å½’åˆ¤æ–­å·¦å³å­æ ‘å¹¶ä¼ é€’èŒƒå›´
        return isValidBST(root->left,min,root) & isValidBST(root->right, root, max);
    }
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, nullptr, nullptr);
    }
};
```

### 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

å•çº¯çš„é€’å½’ç©·ä¸¾å½“ç„¶å¯è¡Œï¼Œä½†è¿™å¹¶æ²¡ç”¨ä¸ŠBST çš„ç‰¹æ€§ã€‚å…¶å®åªè¦åƒäºŒåˆ†æœç´¢çš„ä¸€æ ·é€’å½’æœç´¢ä¸¤è¾¹å³å¯ã€‚

è¦æ³¨æ„çš„æ˜¯ï¼Œ`nullptr`çš„æƒ…å†µã€‚

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr)return nullptr;
        int v = root->val;    
        if(v == val) return root;
        else if(v < val) return searchBST(root->right, val);
        else if(v > val) return searchBST(root->left, val);
        return nullptr;//è¿™æ­¥å…¶å®æ˜¯ä¸ä¼šèµ°åˆ°çš„ã€‚
    }
};
```

### 701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ

éå†å°±æ˜¯æ‰¾ï¼Œè®¿é—®å°±æ˜¯æ”¹ã€‚æ’å…¥å°±æ˜¯è¦å…ˆæ‰¾åˆ°æ’å…¥ä½ç½®ï¼Œç„¶åè¿›è¡Œæ’å…¥æ“ä½œã€‚

è®¾è®¡äº†æ”¹çš„æ“ä½œï¼Œé€’å½’çš„è¿”å›å€¼å°±è¦æ˜¯èŠ‚ç‚¹ã€‚

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        //æ‰¾åˆ°ç©ºå¤„
        if(root == nullptr) return new TreeNode(val);
        if(root->val < val) root->right = insertIntoBST(root->right, val);
        if(root->val > val) root->left = insertIntoBST(root->left, val);
        return root;
    }
};
```

### 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ï¼ˆ**Medium**ï¼‰

å’Œæ’å…¥æ“ä½œç±»ä¼¼ï¼Œå…ˆæ‰¾åˆ°å†æ”¹ã€‚

ä½†æ˜¯æ‰¾åˆ°åæ€ä¹ˆåˆ å‘¢ï¼Ÿ
 

1. è¦åˆ çš„æœ¬èº«å°±æ²¡æœ‰å­èŠ‚ç‚¹äº†ï¼Œç›´æ¥åˆ äº†
2. æœ‰ä¸€ä¸ªéç©ºå­èŠ‚ç‚¹ï¼Œé‚£å°±è®©å­èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®
3. æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå°±æ¯”è¾ƒéº»çƒ¦ï¼Œæœ‰ä¸¤ç§åŠæ³•
   1. æ‰¾å·¦å­æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®
   2. æ‰¾å³å­æ ‘ä¸­æœ€å°çš„èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®ï¼Œè¿™é‡Œç”¨è¿™ç§è§£å†³æ–¹æ³•ã€‚

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return nullptr;
        if(root->val == key){
            //å‰ä¸¤ä¸ªç®€å•æƒ…å†µ
            if(root->left == nullptr) return root->right;
            if(root->right == nullptr) return root->left;
            //å¤æ‚ä¸€ç‚¹çš„ç¬¬ä¸‰ç§æƒ…å†µ
            TreeNode *minNode = getMin(root->right);
            root->val = minNode->val;//è¿™é‡Œç›´æ¥å€¼æ›¿æ¢ï¼Œå®é™…æœ€å¥½æ˜¯æ§åˆ¶æŒ‡é’ˆ
            //å†å°†å³å­æ ‘ä¸­æ‹¿æ¥æ›¿æ¢çš„å€¼åˆ äº†
            root->right = deleteNode(root->right, minNode->val);
        }else if(root->val < key){
            root->right = deleteNode(root->right, key);
        }else if(root->val > key){
            root->left = deleteNode(root->left, key);
        }
        return root;
    }
    TreeNode* getMin(TreeNode* root){
        //BSTä¸­æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
        while(root->left != nullptr) root = root->left;
        return root;
    }
};
```

###  96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘ï¼ˆEasyï¼‰

> ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œæ±‚æ°ç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» `1` åˆ° `n` äº’ä¸ç›¸åŒçš„ **äºŒå‰æœç´¢æ ‘** æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚

å…³é”®å°±æ˜¯å¦‚ä½•ç©·ä¸¾ã€‚

- æ‰¾åˆ°ä¸€ä¸ªç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹
- ä¸¤è¾¹é€’å½’æ±‚å‡ºåŒºé—´ç»„åˆæ•°

```cpp
class Solution {
public:
    //è®¡ç®—é—­åŒºé—´ [lo, hi] ç»„æˆçš„ BST ä¸ªæ•°
    int count(int lo, int hi){
        if(lo > hi) return 1;
        int res = 0;
        for(int i = lo; i <= hi; i++){
            //içš„å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹root,é€’å½’è®¡ç®—ä¸¤è¾¹
            int left = count(lo, i - 1);
            int right = count(i + 1, hi);
            //å·¦å³å­æ ‘ç»„åˆæ•°ä¹˜ç§¯æ˜¯BSTçš„æ€»æ•°
            res += left * right;
        }
        return res;
    }
    int numTrees(int n) {
        return count(1, n);
    }
};
```

ä½†æ­¤æ—¶æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼Œå› ä¸ºæœ‰å¾ˆå¤šé‡å å­é—®é¢˜â€”â€”æœ‰äº›åŒºé—´åœ¨å‰é¢ç®—è¿‡äº†ï¼Œåé¢è°ƒç”¨countæ—¶å´å†ç®—äº†ä¸€éã€‚æ‰€ä»¥å¯ä»¥åŠ ä¸ªå¤‡å¿˜å½•ã€‚

```cpp
class Solution {
public:
    vector<vector<int>> memo;
    //è®¡ç®—é—­åŒºé—´ [lo, hi] ç»„æˆçš„ BST ä¸ªæ•°
    int count(int lo, int hi){
        if(lo > hi) return 1;
        //å…ˆæŸ¥å¤‡å¿˜å½•
        if(memo[lo][hi]!=0) return memo[lo][hi];
        int res = 0;
        for(int i = lo; i <= hi; i++){
            //içš„å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹root,é€’å½’è®¡ç®—ä¸¤è¾¹
            int left = count(lo, i - 1);
            int right = count(i + 1, hi);
            //å·¦å³å­æ ‘ç»„åˆæ•°ä¹˜ç§¯æ˜¯BSTçš„æ€»æ•°
            res += left * right;
        }
        //å­˜å…¥å¤‡å¿˜å½•
        memo[lo][hi] = res;
        return res;
    }
    int numTrees(int n) {
        memo.resize(n+1,vector<int>(n+1, 0));//å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º0
        return count(1, n);
    }
};
```

### 95.ä¸åŒçš„äºŒå‰æœç´¢æ ‘IIï¼ˆMediumï¼‰

å¦‚æœä¸ä»…ä»…æ˜¯è®¡ç®—æœ‰å¤šå°‘ç§ï¼Œæ›´æ˜¯æ„å»ºå‡ºæ‰€æœ‰åˆæ³•çš„BST...

1. ç©·ä¸¾rootèŠ‚ç‚¹æ‰€æœ‰å¯èƒ½
2. é€’å½’æ„é€ å¤„å·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³•BST
3. ç»™rootèŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆ

```cpp
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n==0) return vector<TreeNode*>();
        //è¿”å›[1,n]æ„é€ çš„BST
        return build(1, n);
    }
    //æ„é€ [l,r]æ„é€ çš„BST
    vector<TreeNode*> build(int l, int r){
        vector<TreeNode*> res;
        if(l > r){
            res.push_back(nullptr);//ç©ºèŠ‚ç‚¹ä¹Ÿè¦åŠ åˆ°æœ€åé¢
            return res;
        }
        //ç©·ä¸¾
        for(int i = l;i<=r;i++){
            //é€’å½’æ„é€ å·¦å³å­æ ‘
            vector<TreeNode*> leftTree = build(l, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, r);
            //å·¦å³ç»„åˆ
            for(TreeNode* left: leftTree){
                for(TreeNode* right: rightTree){
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }        
        }
        return res;
    }
};
```

### 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ï¼ˆ**Medium**ï¼‰

1. è¦åˆ çš„æœ¬èº«å°±æ²¡æœ‰å­èŠ‚ç‚¹äº†ï¼Œç›´æ¥åˆ äº†
2. æœ‰ä¸€ä¸ªéç©ºå­èŠ‚ç‚¹ï¼Œé‚£å°±è®©å­èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®
3. æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå°±æ¯”è¾ƒéº»çƒ¦ï¼Œæœ‰ä¸¤ç§åŠæ³•
   1. æ‰¾å·¦å­æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®
   2. æ‰¾å³å­æ ‘ä¸­æœ€å°çš„èŠ‚ç‚¹æ¥ä»£æ›¿è‡ªå·±çš„ä½ç½®ï¼Œè¿™é‡Œç”¨è¿™ç§è§£å†³æ–¹æ³•ã€‚

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return nullptr;
        if(root->val == key){
            //å‰ä¸¤ä¸ªç®€å•æƒ…å†µ
            if(root->left == nullptr) return root->right;
            if(root->right == nullptr) return root->left;
            //å¤æ‚ä¸€ç‚¹çš„ç¬¬ä¸‰ç§æƒ…å†µ
            TreeNode *minNode = getMin(root->right);
            root->val = minNode->val;//è¿™é‡Œç›´æ¥å€¼æ›¿æ¢ï¼Œå®é™…æœ€å¥½æ˜¯æ§åˆ¶æŒ‡é’ˆ
            //å†å°†å³å­æ ‘ä¸­æ‹¿æ¥æ›¿æ¢çš„å€¼åˆ äº†
            root->right = deleteNode(root->right, minNode->val);
        }else if(root->val < key){
            root->right = deleteNode(root->right, key);
        }else if(root->val > key){
            root->left = deleteNode(root->left, key);
        }
        return root;
    }
    TreeNode* getMin(TreeNode* root){
        //BSTä¸­æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
        while(root->left != nullptr) root = root->left;
        return root;
    }
};
```





## åŠ¨æ€è§„åˆ’

### [516. æœ€é•¿å›æ–‡å­åºåˆ—](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)|åŠ¨æ€è§„åˆ’

> å­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚

> ä¸€æ—¦æ¶‰åŠåˆ°å­åºåˆ—å’Œæœ€å€¼ï¼Œé‚£å‡ ä¹å¯ä»¥è‚¯å®šï¼Œ**è€ƒå¯Ÿçš„æ˜¯åŠ¨æ€è§„åˆ’æŠ€å·§ï¼Œæ—¶é—´å¤æ‚åº¦ä¸€èˆ¬éƒ½æ˜¯ O(n^2)**ã€‚
>
> åŸå› å¾ˆç®€å•ï¼Œä½ æƒ³æƒ³ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„å­åºåˆ—æœ‰å¤šå°‘ç§å¯èƒ½ï¼Ÿèµ·ç æ˜¯æŒ‡æ•°çº§çš„å§ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œä¸ç”¨åŠ¨æ€è§„åˆ’æŠ€å·§ï¼Œè¿˜æƒ³æ€ä¹ˆç€å‘¢ï¼Ÿ--labuladong

**åœ¨å­æ•°ç»„`array[i..j]`ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—ï¼ˆæœ€é•¿å›æ–‡å­åºåˆ—ï¼‰çš„é•¿åº¦ä¸º`dp[i][j]`**ã€‚

#### çŠ¶æ€è½¬ç§»

å­é—®é¢˜`dp[i+1][j-1]`çš„ç»“æœï¼ˆ`s[i+1..j-1]`ä¸­æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦ï¼‰ --> 

`dp[i][j]`çš„å€¼ï¼ˆ`s[i..j]`ä¸­ï¼Œæœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦ï¼‰

s[i] ä¸ s[j] ç›¸ç­‰ï¼Œé‚£å°±å¯ä»¥ç›´æ¥ `dp[i][j] = dp[i+1][j-1] + 2`

å¦‚æœä¸ç›¸ç­‰ï¼Œå°±åˆ†åˆ«åŠ å…¥`s[i+1][j-1]`ï¼Œçœ‹äº§ç”Ÿçš„å“ªä¸ªå­ä¸²å›æ–‡å­åºåˆ—æ›´é•¿

**ä¹Ÿå°±æ˜¯è¯´`d[i][j]`ä¸`d[i+1][j-1]ã€d[i+1][j]ã€d[i][j-1]`æœ‰å…³**

#### åˆå§‹åŒ–

- åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„`d[i][i]==1`
- iä¸å¯èƒ½å¤§äºj `d[i][j] = 0`(i>j)

#### å¦‚ä½•éå†

å°†dpäºŒç»´æ•°ç»„ç”»å‡ºæ¥ï¼Œè§‚å¯Ÿ DP Table æ ‡è®°å“ªé‡Œåˆå§‹åŒ–äº†ï¼Œæœ€ç»ˆç­”æ¡ˆ`d[0][n-1]`åœ¨å“ªé‡Œï¼Œæ¯ä¸ªå­é—®é¢˜çš„å­é—®é¢˜æ¥è‡ªå“ªä¸‰ä¸ªæ–¹å‘ï¼Œè¦ä¿è¯é€šè¿‡å·²è®¡ç®—å‡ºæ¥çš„ç»“æœå¯ä»¥è§£å†³æ–°çš„é—®é¢˜â€”â€”å¦‚æ­¤å°±èƒ½æ‰¾åˆ°éå†æ–¹å‘çš„å¥¥ç§˜ğŸ˜œ  

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        //åˆå§‹åŒ–
        for(int i = 0; i < n; i++)dp[i][i] = 1;
        //iåç€ã€jæ­£ç€éå†æ‰èƒ½æ‰¾åˆ°ç­”æ¡ˆâ€”â€”â€”â€”ä¸æ¯ä¸ªå­é—®é¢˜ç­”æ¡ˆæ¥æºæ–¹å‘æœ‰å…³
        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                if(s[i] == s[j])dp[i][j] =dp[i+1][j-1] + 2;
                else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }
        }
        //æ•´ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦å°±åœ¨dp[0][n-1]
        return dp[0][n-1];
    }
};
```

### [1143. æœ€é•¿å…¬å…±å­åºåˆ—](https://leetcode-cn.com/problems/longest-common-subsequence/)|åŠ¨æ€è§„åˆ’

æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLongest Common Subsequenceï¼Œç®€ç§° LCS

å…ˆè®©ç´¢å¼•ä»1 å¼€å§‹

`dp[i][j]`çš„å«ä¹‰æ˜¯ï¼šå¯¹äº`s1[1..i]`å’Œ`s2[1..j]`ï¼Œå®ƒä»¬çš„ LCS é•¿åº¦æ˜¯`dp[i][j]`ã€‚

#### åˆå§‹åŒ–

ç´¢å¼•ä¸º 0 çš„è¡Œå’Œåˆ—è¡¨ç¤ºç©ºä¸²ï¼Œ`dp[0][..]`å’Œ`dp[..][0]`éƒ½åº”è¯¥åˆå§‹åŒ–ä¸º 0ï¼Œè¿™å°±æ˜¯ base caseã€‚  ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå…¶ä¸­ä¸€ä¸ªä¸ºç©ºä¸²`""`ï¼Œä»–ä»¬çš„LCSé•¿åº¦è‡ªç„¶æ˜¯0ã€‚

#### çŠ¶æ€è½¬ç§»

**ç”¨ä¸¤ä¸ªæŒ‡é’ˆ`i`å’Œ`j`éå†`s1`å’Œ`s2`ï¼Œå¦‚æœ`s1[i]==s2[j]`ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸€å®šåœ¨`lcs`ä¸­ï¼›å¦åˆ™çš„è¯ï¼Œ`s1[i]`å’Œ`s2[j]`è¿™ä¸¤ä¸ªå­—ç¬¦è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨`lcs`ä¸­ï¼Œéœ€è¦ä¸¢å¼ƒä¸€ä¸ªã€‚**

**ä¹Ÿå°±æ˜¯`d[i][j]`ä¸`d[i-1][j-1] d[i][j-1] d[i-1][j]`æœ‰å…³**

**é€’å½’dp**+memo

```cpp
class Solution {
public:
    vector<vector<int>> memo;//å¤‡å¿˜å½•ä¼˜åŒ–æ€§èƒ½
    int dp(string&s1, int i, string&s2, int j){
        if(i == s1.size() || j == s2.size()) return 0;
        if(memo[i][j] != -1) return memo[i][j];
        if(s1[i] == s2[j]) return memo[i][j] = 1 + dp(s1, i+1, s2, j+1);//æ‰¾åˆ°ä¸€ä¸ªlcså­—ç¬¦ï¼Œç»§ç»­å¾€å‰æ‰¾
        else return memo[i][j] = max(dp(s1, i+1, s2, j), dp(s1, i, s2, j+1));//çœ‹è°çš„é•¿
    }
    int longestCommonSubsequence(string text1, string text2) {
        //åˆå§‹åŒ–å¤‡å¿˜å½•
        for(int i = 0; i < text1.size(); i++) memo.emplace_back(vector<int>(text2.size(), -1));
        return dp(text1, 0, text2, 0);//å¼€å§‹é€’å½’
    }
};
```

**DP Table**

```cpp
class Solution {
public:
    vector<vector<int>> dp;//å¤‡å¿˜å½•ä¼˜åŒ–æ€§èƒ½
 
    int longestCommonSubsequence(string text1, string text2) {
        //åˆå§‹åŒ–å¤‡å¿˜å½•
        int m = text1.size(), n = text2.size();
        for(int i = 0; i < m + 1; i++) dp.emplace_back(vector<int>(n + 1, 0));
        for(int i = 1; i < m + 1; i++){
            for(int j = 1; j < n + 1; j++){
                if(text1[i - 1] == text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];
                else dp [i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m][n];
        
    }
};
```

ç”¨DP Table åœ¨åŠ›æ‰£åˆ¤é¢˜ç³»ç»Ÿä¸Šä¼šæ¯”é€’å½’ä¼šå¿«å¾ˆå¤šã€‚

### [72. ç¼–è¾‘è·ç¦»](https://leetcode-cn.com/problems/edit-distance/)| dp

ä¸¤ä¸ªæŒ‡é’ˆåœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸Šï¼Œè¿›è¡Œæ¯”è¾ƒï¼š

#### çŠ¶æ€è½¬ç§»

- å­—ç¬¦ç›¸ç­‰ï¼Œskipï¼Œä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶ç§»åŠ¨
- ä¸ç›¸ç­‰ï¼šä¸‰ç§æ–¹æ³•éƒ½è¯•ä¸€éï¼Œæ‰¾æœ€ç¼–è¾‘è·ç¦»æœ€çŸ­çš„
  - æ’å…¥
  - åˆ é™¤
  - æ›¿æ¢
- å…¶ä¸­æœ‰ä¸€ä¸ªæŒ‡é’ˆèµ°å®Œäº†ï¼Œé‚£å°±æ˜¯æŠŠå‰©ä¸‹çš„å…¨éƒ¨æ’å…¥â€”â€”è¿”å›å‰©ä½™çš„é•¿åº¦

`dp[i-1][j-1]` å­˜å‚¨ s1[0..i] å’Œ s2[0..j] çš„æœ€å°ç¼–è¾‘è·ç¦»

#### åˆå§‹åŒ–

`d[i][j]`ä¸­ï¼Œiï¼Œjæœ‰ä¸€ä¸ªä¸º0å°±è¯´æ˜ æœ‰ä¸€ä¸ªå•è¯ä¸º`""`ï¼Œå…¶æ“ä½œæ¬¡æ•°è‡ªç„¶ç­‰äºå¦ä¸€ä¸ªå•è¯çš„é•¿åº¦ã€‚

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m =word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        //åˆå§‹åŒ–dp Table
        for(int i = 1; i <= m; i++) dp[i][0] = i;
        for(int j = 1; j <= n; j++) dp[0][j] = j;
        //çŠ¶æ€è½¬ç§»
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];//ä¸éœ€è¦ä»»ä½•æ“ä½œ å‰ç§»å³å¯
                else dp[i][j] = min(dp[i-1][j-1],
                             min(dp[i-1][j], //æŠŠ s[i] è¿™ä¸ªå­—ç¬¦åˆ æ‰ å‰ç§» iï¼Œç»§ç»­è·Ÿ j å¯¹æ¯”
                              dp[i][j-1]))//åœ¨ s1[i] æ’å…¥ä¸€ä¸ªå’Œ s2[j] ä¸€æ ·çš„å­—ç¬¦,s2[j] å°±è¢«åŒ¹é…äº†ï¼Œå‰ç§» jï¼Œç»§ç»­è·Ÿ i å¯¹æ¯”
                               + 1;
            }
        }
        return dp[m][n];
    }
};
```

### 64.æœ€å°è·¯å¾„å’Œï¼ˆMediumï¼‰

æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚

 æ¯æ¬¡åªèƒ½**å‘ä¸‹æˆ–è€…å‘å³**ç§»åŠ¨ä¸€æ­¥ã€‚

> äºŒç»´çŸ©é˜µæ±‚æœ€ä¼˜åŒ–é—®é¢˜è‡ªç„¶å°±æ˜¯DP

```cpp
class Solution {
public:
    vector<vector<int>> memo;//å¤‡å¿˜å½•
    //ä»å·¦ä¸Šè§’ä½ç½®(0, 0)èµ°åˆ°ä½ç½®(i, j)çš„æœ€å°è·¯å¾„å’Œä¸ºdp(grid, i, j)
    int dp(vector<vector<int>>& grid, int i, int j){
        if(i == 0 && j == 0) return grid[0][0];
        //ç´¢å¼•å‡ºç•Œ
        if(i <0 || j < 0){
            return INT_MAX;//é˜²æ­¢å»minæ—¶å–é”™
        }
        //çœ‹ä¸‹å¤‡å¿˜å½•
        if(memo[i][j] != -1){
            return memo[i][j];
        }

        //ä»å·¦è¾¹æˆ–è€…å³è¾¹æ¥ï¼ˆé€‰æœ€å°çš„ï¼‰
        int minn =  min(
            dp(grid, i-1, j),
            dp(grid, i, j-1)
        );        
        //å†åŠ ä¸Šè¿™æ­¥çš„æ•°å€¼å°±æ˜¯åˆ°è¯¥ç‚¹æœ€ä¼˜çš„å’Œ
        //å¹¶å­˜å…¥å¤‡å¿˜å½•ä¸­
        memo[i][j] = minn + grid[i][j];
        return memo[i][j];
    }
    int minPathSum(vector<vector<int>>& grid) {
        //åˆå§‹åŒ–å¤‡å¿˜å½•
        int m = grid.size(),
            n = grid[0].size();
        memo.resize(m, vector<int>(n, -1));
        return dp(grid, m-1, n-1);
    }
};
```

æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯`O(MN)`

## æ•°æ®æµ

### 295.æ•°æ®æµçš„ä¸­ä½æ•°|Hard

æ•°æ®è§„æ¨¡å°çš„æ—¶å€™ï¼Œå–ä¸­ä½æ•°å¯ä»¥ç›´æ¥æ’åºåå–å¾—ã€‚ä½†æ˜¯è§„æ¨¡éå¸¸å·¨å¤§æ—¶ï¼Œå°±éœ€è¦æ¦‚ç‡ç®—æ³•ã€‚

æœ¬é¢˜è¦æ±‚è®¾è®¡ä¸¤ä¸ªæ–¹æ³•ï¼š

1. æ·»åŠ æ•°å­—
2. å–å¾—å½“å‰æ‰€æœ‰æ•°å­—çš„ä¸­ä½æ•°

å¸¸è§„æ€è·¯ï¼šç”¨æ•°ç»„å­˜å‚¨æ‰€æœ‰è¢« æ·»åŠ çš„æ•°å­—ï¼Œå¹¶ä¸”é€šè¿‡æ’å…¥æ’åºä¿è¯æ•°ç»„ä¸­çš„å…ƒç´ æœ‰åºã€‚ä½†æ˜¯å¾ˆæ˜æ˜¾æ’å…¥æ“ä½œä¸­æ•°ç»„æ¬ç§»æ•°æ®éœ€è¦çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(N)ï¼Œè¿™æ˜¯ä¸å¤Ÿå¥½çš„ã€‚

é‚£é€‰ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„å‘¢ï¼Ÿå¾ˆæ˜æ˜¾ï¼Œæ²¡å­¦è¿‡çš„æˆ‘å°±æ˜¯æƒ³ä¸å‡ºæ¥ã€‚ç›´æ¥çœ‹**å¤§ä½¬ï¼ˆlabuladongï¼‰**çš„æ€è·¯ï¼š

ä½¿ç”¨ä¸¤ä¸ªä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œä¸€ä¸ªä¸ºå¤§é¡¶å †ç»´æŠ¤ç€æœ€ä¸Šé¢çš„å…ƒç´ ä¸ºsmallï¼Œä¸€ä¸ªä¸ºå°é¡¶å †ç»´æŠ¤æœ€ä¸Šé¢çš„å…ƒç´ ä¸ºbigâ€”â€”è¿™é‡Œçš„å‘½åå°±è¯´æ˜ï¼Œå°é¡¶å †çš„æœ€å°å€¼å¤§äºå¤§é¡¶å †çš„æœ€å¤§å€¼ã€‚æœ€åæ±‚ä¸­ä½æ•°æ—¶ï¼Œå°±é bigå’Œsmalæ¥è·å¾—æœ€åç­”æ¡ˆã€‚

é‚£ä¹ˆå¾ˆæ˜æ˜¾ï¼Œä¸¤ä¸ªå †ä¸­çš„å…ƒç´ æ•°é‡ä¹‹å·®ä¸èƒ½å¤§äº1ã€‚å‡è®¾æ€»æ•°ä¸ºnï¼š

1. nä¸ºå¶æ•°ï¼Œä¹Ÿå°±æ˜¯ç›´æ¥æ‹¿å‡ºä¸¤ä¸ªå †é¡¶å…ƒç´ æ±‚å¹³å‡æ•°
2. nä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆå †ä¸­æ•°é‡åˆ†åˆ«ä¸º n/2+1ã€n/2ï¼Œå¤šçš„é‚£ä¸ªå †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°ã€‚

æ‰€ä»¥å–ä¸­ä½æ•°çš„æ–¹æ³•ä¸ºï¼š

```cpp
double findMedian() {
        if(small.size() == big.size())return (small.top() + big.top())/2.0;
        else return small.size() > big.size() small.top(): big.top();
    }
```

è€Œæ·»åŠ å…ƒç´ çš„æ–¹æ³•ä¸­ä¸»è¦ä¸¤ä¸ªåŸåˆ™ï¼š

1. å…ƒç´ ä¸ªæ•°ä¹‹å·®ä¸è¶…è¿‡1
2. **bigå †é¡¶å…ƒç´ è¦å¤§äºsmallå †é¡¶**

å¯¹äºç¬¬äºŒä¸ªåŸåˆ™ï¼ŒæŠ€å·§ä¸»è¦å°±æ˜¯ï¼š

> **æƒ³è¦å¾€`big`é‡Œæ·»åŠ å…ƒç´ ï¼Œä¸èƒ½ç›´æ¥æ·»åŠ ï¼Œè€Œæ˜¯è¦å…ˆå¾€`small`é‡Œæ·»åŠ ï¼Œç„¶åå†æŠŠ`small`çš„å †é¡¶å…ƒç´ åŠ åˆ°`big`ä¸­ï¼›å‘`small`ä¸­æ·»åŠ å…ƒç´ åŒç†**ã€‚
>
> - å¦‚æœæ’å…¥çš„`num`å°äº`small`çš„å †é¡¶å…ƒç´ ï¼Œé‚£ä¹ˆ`num`å°±ä¼šç•™åœ¨`small`å †é‡Œï¼Œä¸ºäº†ä¿è¯ä¸¤ä¸ªå †çš„å…ƒç´ æ•°é‡ä¹‹å·®ä¸å¤§äº 1ï¼Œä½œä¸ºäº¤æ¢ï¼ŒæŠŠ`small`å †é¡¶éƒ¨çš„å…ƒç´ å†æ’åˆ°`large`å †é‡Œã€‚
>
> - å¦‚æœæ’å…¥çš„`num`å¤§äº`small`çš„å †é¡¶å…ƒç´ ï¼Œé‚£ä¹ˆ`num`å°±ä¼šæˆä¸º`samll`çš„å †é¡¶å…ƒç´ ï¼Œæœ€åè¿˜æ˜¯ä¼šè¢«æ’å…¥`large`å †ä¸­ã€‚

```cpp
class MedianFinder {
    priority_queue<int, vector<int>, greater<int>> big;//å°é¡¶å †
    priority_queue<int, vector<int>, less<int>> small;//å¤§é¡¶å †
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if(small.size() < big.size()){//è¦å¾€smallé‡ŒåŠ 
            big.emplace(num);//å…ˆåŠ åˆ°bigé‡Œ
            small.emplace(big.top());//å°†bigæ ˆé¡¶åŠ å…¥small
            big.pop();//å¼¹å‡ºbigæ ˆé¡¶
        }else{//åä¹‹ä¸€æ ·
            small.emplace(num);
            big.emplace(small.top());
            small.pop();
        }
    }
    
    double findMedian() {
        if(small.size() == big.size())return (small.top() + big.top())/2.0;
        else return small.size() > big.size()? small.top(): big.top();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

`addNum`æ–¹æ³•æ—¶é—´å¤æ‚åº¦ O(logN)ï¼Œ`findMedian`æ–¹æ³•æ—¶é—´å¤æ‚åº¦ O(1)ã€‚
