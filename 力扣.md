# åŠ›æ‰£åˆ·é¢˜ç¬”è®°

## [206. åè½¬é“¾è¡¨]å•é“¾è¡¨åè½¬|é€’å½’|é€’æ¨å†™æ³•

### é€’å½’å†™æ³•

reverseList å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹headï¼Œå°†ã€Œä»¥headä¸ºèµ·ç‚¹ã€çš„é“¾è¡¨åè½¬ï¼Œå¹¶è¿”å›åè½¬ä¹‹åçš„å¤´ç»“ç‚¹ã€‚

é‚£ä¹ˆåœ¨é€’å½’ä¸­`ListNode* last = reverseList(head->next);` è¿”å›çš„ last ä¹Ÿå°±æ˜¯ åé¢é‚£ä¸€æ®µçš„åè½¬åçš„å¤´ç»“ç‚¹ã€‚

`head->next->next = head;` åˆ™æ˜¯å°†åŸå…ˆheadæŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„nextæŒ‡äº†å›æ¥ï¼Œä¹Ÿå°±æ˜¯ åä¸€æ®µç¿»è½¬è¿‡æ¥åçš„å°¾éƒ¨æŒ‡å‘ head

`head->next = nullptr;` åˆ™æ˜¯å°†åŸå…ˆå¤´ç»“ç‚¹æŒ‡å‘ null ï¼Œå› ä¸ºæ­¤æ—¶ä»–å·²ç»æ˜¯å°¾éƒ¨äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //base case
        if(head == nullptr || head->next == nullptr)return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};

```

### è¿­ä»£å†™æ³•

```cpp
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		ListNode *temp; // ä¿å­˜åŸæœ¬curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ ç”¨nxtæŒ‡é’ˆæˆ–è®¸æ›´ä¸ºåˆé€‚
		ListNode *cur = head;
		ListNode *pre = NULL; //æ›´æ–°åçš„å¤´
		while (cur)
		{
			temp = cur->next; // ä¿å­˜ä¸€ä¸‹ curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºæ¥ä¸‹æ¥è¦æ”¹å˜cur->next
			cur->next = pre;  // ç¿»è½¬æ“ä½œ
			//æ›´æ–°ä¸€ä¸‹pre å’Œ curæŒ‡é’ˆ
			pre = cur;	//preç§»åˆ°ç°åœ¨curæ‰€åœ¨
			cur = temp; //curç§»åˆ°tempå³åŸå…ˆçš„cur->next;
		}
		return pre;
	}
};
```

é€’æ¨åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šéƒ½ç¢¾å‹é€’å½’ï¼Œä½†æˆ‘è§‰å¾—é€’å½’çš„æ–¹æ³•éå¸¸ç²¾å¦™â€”â€”é€’å½’çš„é­…åŠ›ã€‚



## [92.åè½¬é“¾è¡¨ â…¡]é€’å½’

åè½¬ä¸€ä¸ªåŒºé—´çš„é“¾è¡¨ã€‚æ€ä¹ˆåšå‘¢ã€‚

æˆ‘ä»¬å¯ä»¥å…ˆæ¢ä¸ªæ€è€ƒæ–¹å‘â€”â€”**åè½¬å‰nä¸ª**

```cpp
ListNode* successor = nullptr; // åé©±èŠ‚ç‚¹
ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            //è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head->next;
            return head;
        }
    	// ä»¥ head->next ä¸ºèµ·ç‚¹ï¼Œ åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        ListNode* last = reverseN(head->next, n-1);
        
        head->next->next = head;
    	// è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head->next = successor;
        return last;        
    }
```

![image-20211115151904252](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211115151904252.png)

é‚£ä¹ˆå°±å¯ä»¥å¼€å§‹å®ç°åè½¬é“¾è¡¨çš„ä¸€éƒ¨åˆ†äº†

` ListNode* reverseBetween(ListNode* head, int left, int right) `åè½¬ [left, right], é‚£ä¹ˆå½“ left == 1 æ—¶ï¼Œä¹Ÿå°±ç›¸å½“äºå‰é¢çš„ åè½¬å‰nä¸ªå…ƒç´ â€”â€”ä¸è¿‡è¿™é‡Œæ˜¯åè½¬å‰ right ä¸ªå…ƒç´ ç½¢äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next,n-1);
        
        head->next->next = head;
        head->next = successor;
        return last;
        
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1){
            //ç›¸å½“äºåè½¬å‰ right ä¸ªå…ƒç´ 
            return  reverseN(head,right);
        }
		//å‰ç§»åè½¬èµ·ç‚¹æ¥è§¦å‘ left == 1 çš„æƒ…å†µ
        head->next = reverseBetween(head->next,left-1,right-1);
        return head;
    }
};
```

é€’å½’æ–¹æ³•éå¸¸ç²¾å¦™ï¼Œä½†æ˜¯æ•ˆç‡ç¡®å®ä½ï¼Œä¸è®ºæ˜¯æ—¶é—´è¿˜æ˜¯ç©ºé—´å¤æ‚åº¦å‡ä¸º O(N)

è¿­ä»£çš„è¯ï¼Œè‡³å°‘ç©ºé—´æ˜¯O(1)ã€‚

### è¿­ä»£æ³•åè½¬åŒºé—´

ä¸ ç¬¬206é¢˜ ç±»ä¼¼

```cpp
//åè½¬åŒºé—´ [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //è¿”å›åè½¬åçš„èŠ‚ç‚¹ç”¨äºè¿æ¥
        return pre;
    }
```



## [[25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)]é€’å½’

è¯¥é—®é¢˜å…·æœ‰æ˜æ˜¾çš„é€’å½’æ€§è´¨ã€‚

å¦‚ä¸‰ä¸ªä¸€ç»„åè½¬ï¼Œé‚£ä¹ˆå°†å‰ä¸‰ä¸ªåè½¬åï¼Œåé¢çš„ä¸å°±åˆæ˜¯ä¸€æ¡é•¿åº¦çŸ­ä¸‰çš„é“¾è¡¨ï¼Ÿ

1. åè½¬ head å¼€å¤´çš„ k ä¸ªå…ƒç´ 
2. å°†ç¬¬ k+1 ä¸ªå…ƒç´ ä½œä¸º head å‚æ•°ä¼ å…¥é€’å½’å‡½æ•°
3. å°†ç»“æœè¿æ¥èµ·æ¥
4. ...é‡å¤

base case: åé¢å…ƒç´ ä¸è¶³ k ä¸ª äº†ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //åè½¬åŒºé—´ [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //è¿”å›åè½¬åçš„èŠ‚ç‚¹ç”¨äºè¿æ¥
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)return nullptr;
        ListNode *a, *b;
        a = head, b = head;
        for(int i = 0; i < k; i++){
            //base case 
            if(b == nullptr) return head;
            b = b->next;
        }
        //åè½¬å‰kä¸ª
        ListNode* newHead  =  reverse(a, b);
        //é€’å½’åè½¬ååºé“¾è¡¨å¹¶ä¸å‰é¢èŠ‚ç‚¹ç›¸è¿
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```

## [100.ç›¸åŒçš„æ ‘] | äºŒå‰æ ‘

### é€’å½’å†™æ³•ï¼š

éå¸¸ç®€å•

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //é€’å½’
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr) return true;
        if(p == nullptr || q == nullptr) return false;
        if(p->val != q->val) return  false;
        return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
    }
};
```

### è¿­ä»£å†™æ³•ï¼š å€ŸåŠ©æ ˆ

```cpp
bool isSameTree(TreeNode* p, TreeNode* q) {
        stack<TreeNode*> st; //ä¸é˜Ÿåˆ—å·®ä¸å¤šï¼Œä½†æ˜¯ç”¨æ ˆå¤„ç†æŒ‡é’ˆçš„é¡ºåºå’Œé˜Ÿåˆ—ç›¸å
        st.push(p);
        st.push(q);
        while(!st.empty()){
            TreeNode* root1 = st.top();st.pop();
            TreeNode* root2 = st.top();st.pop();
            
            if(root1 == nullptr && root2 == nullptr) continue;            
            if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
            
            st.push(root1->left);
            st.push(root2->left);
            st.push(root1->right);
            st.push(root2->right);
        }
        return true;
    }
```

### ç”¨é˜Ÿåˆ—ä¹Ÿæ˜¯ä¸€æ ·çš„

```cpp
 bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<TreeNode*> que;  
    que.push(p);
    que.push(q);
    while(!que.empty()){
        TreeNode* root1 = que.front();que.pop();
        TreeNode* root2 = que.front();que.pop();
        
        if(root1 == nullptr && root2 == nullptr)continue;
        if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
 
        que.push(root1->left);
        que.push(root2->left);
        que.push(root1->right);
        que.push(root2->right);
    }
    return true;
}

```

## [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

æ‰¾æœ€é•¿å›æ–‡å­ä¸²ä¹‹å‰ï¼Œå…ˆæ€è€ƒï¼šæ€ä¹ˆæ‰¾å›æ–‡å­ä¸²ï¼Ÿ

**ä»ä¸­é—´å¾€ä¸¤è¾¹æ‰©æ•£æ¥åˆ¤æ–­**,è¿˜æœ‰å¥‡å¶åˆæ€ä¹ˆåŒºåˆ†å‘¢...

```cpp
class Solution {
public:
    //ä¼ å…¥ä¸¤ä¸ªæŒ‡é’ˆå°±ä¸ç”¨åˆ†è¾¨å­—ç¬¦ä¸²é•¿åº¦å¥‡å¶æƒ…å†µ
        //ä¸­å¿ƒä¸ºs[l]ã€s[r],å¦‚æœé•¿åº¦ä¸ºå¥‡æ•°ï¼Œl==r
    string palindrome(string&s, int l, int r){
        while(l >= 0 && r < s.size() && s[l] == s[r]){
            l--;r++;
        }
        return s.substr(l + 1, r - 1 - l);
    }
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++){
            string s1 = palindrome(s, i, i);
            string s2 = palindrome(s, i, i + 1);
            res = res.size() > s1.size()? res: s1;
            res = res.size() > s2.size()? res: s2;
        }
        return res;
    }
};
```

æ—¶é—´å¤æ‚åº¦ O(N^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚

è¿˜æœ‰ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(N)çš„ç®—æ³•ï¼Œä½†æ˜¯åŠ›æ‰£è¿™é‡Œå¹¶ä¸éœ€è¦ï¼Œå¦‚æœæ˜¯ç«èµ›å¯èƒ½å°±éœ€è¦äº†â€”â€”é©¬æ‹‰è½¦ç®—æ³•ï¼Œæˆ‘ä¹Ÿå†™è¿‡[ä¸€ç¯‡ç¬”è®°](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8)ã€‚

##  [516. æœ€é•¿å›æ–‡å­åºåˆ—](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)|åŠ¨æ€è§„åˆ’

> å­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚

> ä¸€æ—¦æ¶‰åŠåˆ°å­åºåˆ—å’Œæœ€å€¼ï¼Œé‚£å‡ ä¹å¯ä»¥è‚¯å®šï¼Œ**è€ƒå¯Ÿçš„æ˜¯åŠ¨æ€è§„åˆ’æŠ€å·§ï¼Œæ—¶é—´å¤æ‚åº¦ä¸€èˆ¬éƒ½æ˜¯ O(n^2)**ã€‚
>
> åŸå› å¾ˆç®€å•ï¼Œä½ æƒ³æƒ³ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„å­åºåˆ—æœ‰å¤šå°‘ç§å¯èƒ½ï¼Ÿèµ·ç æ˜¯æŒ‡æ•°çº§çš„å§ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œä¸ç”¨åŠ¨æ€è§„åˆ’æŠ€å·§ï¼Œè¿˜æƒ³æ€ä¹ˆç€å‘¢ï¼Ÿ--labuladong

**åœ¨å­æ•°ç»„`array[i..j]`ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—ï¼ˆæœ€é•¿å›æ–‡å­åºåˆ—ï¼‰çš„é•¿åº¦ä¸º`dp[i][j]`**ã€‚

### çŠ¶æ€è½¬ç§»

å­é—®é¢˜`dp[i+1][j-1]`çš„ç»“æœï¼ˆ`s[i+1..j-1]`ä¸­æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦ï¼‰ --> 

`dp[i][j]`çš„å€¼ï¼ˆ`s[i..j]`ä¸­ï¼Œæœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦ï¼‰

s[i] ä¸ s[j] ç›¸ç­‰ï¼Œé‚£å°±å¯ä»¥ç›´æ¥ `dp[i][j] = dp[i+1][j-1] + 2`

å¦‚æœä¸ç›¸ç­‰ï¼Œå°±åˆ†åˆ«åŠ å…¥`s[i+1][j-1]`ï¼Œçœ‹äº§ç”Ÿçš„å“ªä¸ªå­ä¸²å›æ–‡å­åºåˆ—æ›´é•¿

**ä¹Ÿå°±æ˜¯è¯´`d[i][j]`ä¸`d[i+1][j-1]ã€d[i+1][j]ã€d[i][j-1]`æœ‰å…³**

### åˆå§‹åŒ–

- åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„`d[i][i]==1`
- iä¸å¯èƒ½å¤§äºj `d[i][j] = 0`(i>j)

### å¦‚ä½•éå†

å°†dpäºŒç»´æ•°ç»„ç”»å‡ºæ¥ï¼Œè§‚å¯Ÿ DP Table æ ‡è®°å“ªé‡Œåˆå§‹åŒ–äº†ï¼Œæœ€ç»ˆç­”æ¡ˆ`d[0][n-1]`åœ¨å“ªé‡Œï¼Œæ¯ä¸ªå­é—®é¢˜çš„å­é—®é¢˜æ¥è‡ªå“ªä¸‰ä¸ªæ–¹å‘ï¼Œè¦ä¿è¯é€šè¿‡å·²è®¡ç®—å‡ºæ¥çš„ç»“æœå¯ä»¥è§£å†³æ–°çš„é—®é¢˜â€”â€”å¦‚æ­¤å°±èƒ½æ‰¾åˆ°éå†æ–¹å‘çš„å¥¥ç§˜ğŸ˜œ  

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        //åˆå§‹åŒ–
        for(int i = 0; i < n; i++)dp[i][i] = 1;
        //iåç€ã€jæ­£ç€éå†æ‰èƒ½æ‰¾åˆ°ç­”æ¡ˆâ€”â€”â€”â€”ä¸æ¯ä¸ªå­é—®é¢˜ç­”æ¡ˆæ¥æºæ–¹å‘æœ‰å…³
        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                if(s[i] == s[j])dp[i][j] =dp[i+1][j-1] + 2;
                else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }
        }
        //æ•´ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦å°±åœ¨dp[0][n-1]
        return dp[0][n-1];
    }
};
```

##  [1143. æœ€é•¿å…¬å…±å­åºåˆ—](https://leetcode-cn.com/problems/longest-common-subsequence/)|åŠ¨æ€è§„åˆ’

æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLongest Common Subsequenceï¼Œç®€ç§° LCS

å…ˆè®©ç´¢å¼•ä»1 å¼€å§‹

`dp[i][j]`çš„å«ä¹‰æ˜¯ï¼šå¯¹äº`s1[1..i]`å’Œ`s2[1..j]`ï¼Œå®ƒä»¬çš„ LCS é•¿åº¦æ˜¯`dp[i][j]`ã€‚

### åˆå§‹åŒ–

ç´¢å¼•ä¸º 0 çš„è¡Œå’Œåˆ—è¡¨ç¤ºç©ºä¸²ï¼Œ`dp[0][..]`å’Œ`dp[..][0]`éƒ½åº”è¯¥åˆå§‹åŒ–ä¸º 0ï¼Œè¿™å°±æ˜¯ base caseã€‚  ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå…¶ä¸­ä¸€ä¸ªä¸ºç©ºä¸²`""`ï¼Œä»–ä»¬çš„LCSé•¿åº¦è‡ªç„¶æ˜¯0ã€‚

### çŠ¶æ€è½¬ç§»

**ç”¨ä¸¤ä¸ªæŒ‡é’ˆ`i`å’Œ`j`éå†`s1`å’Œ`s2`ï¼Œå¦‚æœ`s1[i]==s2[j]`ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸€å®šåœ¨`lcs`ä¸­ï¼›å¦åˆ™çš„è¯ï¼Œ`s1[i]`å’Œ`s2[j]`è¿™ä¸¤ä¸ªå­—ç¬¦è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨`lcs`ä¸­ï¼Œéœ€è¦ä¸¢å¼ƒä¸€ä¸ªã€‚**

**ä¹Ÿå°±æ˜¯`d[i][j]`ä¸`d[i-1][j-1] d[i][j-1] d[i-1][j]`æœ‰å…³**

**é€’å½’dp**+memo

```cpp
class Solution {
public:
    vector<vector<int>> memo;//å¤‡å¿˜å½•ä¼˜åŒ–æ€§èƒ½
    int dp(string&s1, int i, string&s2, int j){
        if(i == s1.size() || j == s2.size()) return 0;
        if(memo[i][j] != -1) return memo[i][j];
        if(s1[i] == s2[j]) return memo[i][j] = 1 + dp(s1, i+1, s2, j+1);//æ‰¾åˆ°ä¸€ä¸ªlcså­—ç¬¦ï¼Œç»§ç»­å¾€å‰æ‰¾
        else return memo[i][j] = max(dp(s1, i+1, s2, j), dp(s1, i, s2, j+1));//çœ‹è°çš„é•¿
    }
    int longestCommonSubsequence(string text1, string text2) {
        //åˆå§‹åŒ–å¤‡å¿˜å½•
        for(int i = 0; i < text1.size(); i++) memo.emplace_back(vector<int>(text2.size(), -1));
        return dp(text1, 0, text2, 0);//å¼€å§‹é€’å½’
    }
};
```

**DP Table**

```cpp
class Solution {
public:
    vector<vector<int>> dp;//å¤‡å¿˜å½•ä¼˜åŒ–æ€§èƒ½
 
    int longestCommonSubsequence(string text1, string text2) {
        //åˆå§‹åŒ–å¤‡å¿˜å½•
        int m = text1.size(), n = text2.size();
        for(int i = 0; i < m + 1; i++) dp.emplace_back(vector<int>(n + 1, 0));
        for(int i = 1; i < m + 1; i++){
            for(int j = 1; j < n + 1; j++){
                if(text1[i - 1] == text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];
                else dp [i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[m][n];
        
    }
};
```

ç”¨DP Table åœ¨åŠ›æ‰£åˆ¤é¢˜ç³»ç»Ÿä¸Šä¼šæ¯”é€’å½’ä¼šå¿«å¾ˆå¤šã€‚

## [72. ç¼–è¾‘è·ç¦»](https://leetcode-cn.com/problems/edit-distance/)| dp

ä¸¤ä¸ªæŒ‡é’ˆåœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸Šï¼Œè¿›è¡Œæ¯”è¾ƒï¼š

### çŠ¶æ€è½¬ç§»

- å­—ç¬¦ç›¸ç­‰ï¼Œskipï¼Œä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶ç§»åŠ¨
- ä¸ç›¸ç­‰ï¼šä¸‰ç§æ–¹æ³•éƒ½è¯•ä¸€éï¼Œæ‰¾æœ€ç¼–è¾‘è·ç¦»æœ€çŸ­çš„
  - æ’å…¥
  - åˆ é™¤
  - æ›¿æ¢
- å…¶ä¸­æœ‰ä¸€ä¸ªæŒ‡é’ˆèµ°å®Œäº†ï¼Œé‚£å°±æ˜¯æŠŠå‰©ä¸‹çš„å…¨éƒ¨æ’å…¥â€”â€”è¿”å›å‰©ä½™çš„é•¿åº¦

`dp[i-1][j-1]` å­˜å‚¨ s1[0..i] å’Œ s2[0..j] çš„æœ€å°ç¼–è¾‘è·ç¦»

### åˆå§‹åŒ–

`d[i][j]`ä¸­ï¼Œiï¼Œjæœ‰ä¸€ä¸ªä¸º0å°±è¯´æ˜ æœ‰ä¸€ä¸ªå•è¯ä¸º`""`ï¼Œå…¶æ“ä½œæ¬¡æ•°è‡ªç„¶ç­‰äºå¦ä¸€ä¸ªå•è¯çš„é•¿åº¦ã€‚

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m =word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        //åˆå§‹åŒ–dp Table
        for(int i = 1; i <= m; i++) dp[i][0] = i;
        for(int j = 1; j <= n; j++) dp[0][j] = j;
        //çŠ¶æ€è½¬ç§»
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];//ä¸éœ€è¦ä»»ä½•æ“ä½œ å‰ç§»å³å¯
                else dp[i][j] = min(dp[i-1][j-1],
                             min(dp[i-1][j], //æŠŠ s[i] è¿™ä¸ªå­—ç¬¦åˆ æ‰ å‰ç§» iï¼Œç»§ç»­è·Ÿ j å¯¹æ¯”
                              dp[i][j-1]))//åœ¨ s1[i] æ’å…¥ä¸€ä¸ªå’Œ s2[j] ä¸€æ ·çš„å­—ç¬¦,s2[j] å°±è¢«åŒ¹é…äº†ï¼Œå‰ç§» jï¼Œç»§ç»­è·Ÿ i å¯¹æ¯”
                               + 1;
            }
        }
        return dp[m][n];
    }
};
```

## [234. å›æ–‡é“¾è¡¨](https://leetcode-cn.com/problems/palindrome-linked-list/)

å•é“¾è¡¨æ— æ³•å€’ç€éå†ï¼Œæ— æ³•ä½¿ç”¨åŒæŒ‡é’ˆæŠ€å·§ã€‚

ç›´æ¥åè½¬å•é“¾è¡¨åå†è¿›è¡Œæ¯”è¾ƒ...ä¹Ÿå¯è¡Œ

ä½†è¿˜æ˜¯æ¥ç‚¹ä¸åŒçš„â€”â€”åƒäºŒå‰æ ‘éå†æ€æƒ³ä¸€æ ·å€’åºéå†

> æ ‘ç»“æ„ä¸è¿‡æ˜¯é“¾è¡¨çš„è¡ç”Ÿã€‚é‚£ä¹ˆï¼Œ**é“¾è¡¨å…¶å®ä¹Ÿå¯ä»¥æœ‰å‰åºéå†å’Œååºéå†** â€”â€”labuladong

å®é™…ä¸Šå°±æ˜¯è½®æµå°†é“¾è¡¨èŠ‚ç‚¹è½®æµæ”¾å…¥ä¸€ä¸ªæ ˆä¸­ï¼Œå†ä¾æ¬¡æ‹¿å‡ºæ¥ï¼Œé¡ºåºè‡ªç„¶å°±æ˜¯åçš„ã€‚

ä½†æ˜¯è¿™æ ·çš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ä¸ç›´æ¥é€ ä¸€æ¡åè½¬é“¾è¡¨ä¸€æ ·éƒ½æ˜¯O(N)ã€‚

---

æ›´å¥½çš„æ€è·¯ï¼š

- ç”¨å¿«æ…¢æŒ‡é’ˆæ³•æ¥å…ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹

  ```cpp
  while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
  }
  // slow æŒ‡é’ˆç°åœ¨æŒ‡å‘é“¾è¡¨ä¸­ç‚¹
  ```

  

  - fast æŒ‡å‘ null å°±è¯´æ˜é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼Œslowè¿˜è¦æ›´è¿›ä¸€èŠ‚

    ```cpp
    if(fast != nullptr){
        slow = slow->next;
    }
    ```

  - å¦åˆ™è¯´æ˜ä¸ºå¶æ•°ï¼Œæ— éœ€å¤šä½™æ“ä½œ

- å†åè½¬slowä¸ºå¤´çš„ååºé“¾è¡¨

- æ¯”è¾ƒä¸¤è¾¹çš„é“¾è¡¨

æ—¶é—´å¤æ‚åº¦ä¸ºO(N)ã€ç©ºé—´å¤æ‚åº¦ä¸ºO(N)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //åè½¬é“¾è¡¨
    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, *cur = head, *next;
        while(cur!=nullptr){
            next = cur->next;
            cur->next  = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        ListNode *fast, *slow;
        fast= slow = head;
        while(fast != nullptr &&fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        if(fast != nullptr) slow = slow->next;
        //æ­¤æ—¶slowå°±æ˜¯ä¸­ç‚¹
        ListNode *left = head, *right = reverse(slow);
        while(right != nullptr){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }
};
```



