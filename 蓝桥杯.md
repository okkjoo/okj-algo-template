> 
>
> 准备三四月份蓝桥杯的笔记

# 说在前面的套路

时间限制：C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过108,则可能会超时

- **由数据范围反推算法复杂度以及算法内容**——来自y神

![image-20211210112521113](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

- 若输入输出 范围 小于 105 推荐用 `cin / cout` 否则用 `scanf / printf` 输入时间会快一倍左右

# 题目

## DFS

### 116. 飞行员兄弟|DFS|位运算|暴力枚举

- 矩阵
- 变一个位置就是变一个十字
- 先级整体从上到下，同行从左到右打开——先看第一行...

=>

- 暴力枚举——位运算 （这个看起来更聪明点🐶）
  - 也可以DFS+直接操作字符数组

- 用一个十六位的二进制数模拟棋盘状态：0~2^16-1
  - 解题思路：这道题目解题思路大致是，首先我们可以构造一个16位的二进制数，然后呢，二进制数的每一位代表4*4矩阵中的一位，例如1代表(1,1),2代表(1,2),3代表(1,3),4代表(1,4),5代表(2,1)。既然这样的话，那么我们只需要枚举这个16位的二进制数，就可以确定我们的方案，因为题目只需要最优解方案，所以时间复杂度大约是O(16 * 2^16)
- get 获得位数
- change 通过**异或**操作进行反转开关操作
  - 01互相反转 == 与1异或

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

/*  DFS+直接操作字符数组
typedef pair<int,int> PII;
PII ans[20],cur[20];
char c[6][6];
int sum;
void turn(int x,int y)
{       for(int i=0;i<4;i++)
        {
            if(c[i][y]=='+') c[i][y]='-';
            else  c[i][y]='+';
        }
        for(int i=0;i<4;i++)
        {
            if(c[x][i]=='+') c[x][i]='-';
            else  c[x][i]='+';
        }
         if(c[x][y]=='+') c[x][y]='-';
            else  c[x][y]='+';
}
bool check(char c[][6])
{   for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
        if(c[i][j]=='+')
           return false; 

     return true; 

}
void dfs(int x,int y,int res){
        if(x==4)
        {
            if(check(c)&&res<sum)
            {   memcpy(ans,cur,sizeof(ans));
                sum=res;
            }
            return;
        }
        int dx=x,dy=y+1;
        if(dy==4){
            dx++,dy=0;
        }
        turn(x,y);
        cur[res+1]={x,y};
        dfs(dx,dy,res+1);
        turn(x,y);
        dfs(dx,dy,res);


}
int main()
{   for(int i=0;i<4;i++)  cin>>c[i];
    sum=0x3f3f3f3f;
    dfs(0,0,0);
    cout<<sum<<endl;
    for(int i=1;i<=sum;i++)
    {
        cout<<ans[i].first+1<<" "<<ans[i].second+1<<endl;
    }


    return 0;
}
 */


int change[4][4];
int get(int x, int y){//获取位数
	return x*4 + y;
}
int main(){
	int state = 0;//棋盘状态
	for(int i =0 ; i<4; i++){
		string line;
		cin>>line;
		for(int j = 0;j<4;j++){
			if(line[j] == '+')
				state += 1 << get(i,j);			
		}
	} 

	//预处理
	for(int i = 0; i < 4; i++)
	for(int j =0; j<4; j++){
		for(int k=0; k < 4; k++){
			change[i][j] += 1<<get(i, k);
			change[i][j] += 1<<get(k, j);
		}
		change[i][j] -= 1<<get(i, j);//行列操作后多操作了一次，要减去
	}
	vector<PII> res;
	for(int k = 0;k< 1<<16; k++){//暴力遍历
		int now = state;//存一下当前局面
		vector<PII> path;
		for(int i =0; i<16; i++){//如果k的某一位是1，就表示需要操作
			if(k >>i & 1){
				//对编号是i的格子进行操作
				int x = i/4, y = i%4;//找到他的行列位置
				now ^= change[x][y];
				path.push_back({x, y});
			}
			if(!now && (res.empty()|| res.size() >path.size())){
			//全0说明合法 && （原先res为空 || 新的方法步骤更少）
				res = path;
			}
		}
	}
	cout<<res.size()<<endl;
	for(auto p:res)cout<< p.first+1<<" "<<p.second+1<<endl;
}
```

## 二分

### [AcWing789.数的范围](https://www.acwing.com/problem/content/791/)|二分

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, q, x;
int a[100005];
int main(){
	scanf("%d%d",&n,&q);
	for(int i =0 ;i<n;i++){
		scanf("%d",&a[i]);
	}
	while(q--){
		scanf("%d",&x);
		int l = 0, r = n;
		//搜左边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) r = mid;//找到了收缩右边以达到找到左边界的效果
			else if(a[mid] < x) l = mid + 1;
			else if(a[mid] > x) r = mid;
		}
		if(a[l] != x) {printf("-1 -1\n");continue;}
		int left = l;
		r = n;
		//搜右边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) l = mid+1;//收缩左边以达到找到右边界的效果
			else if( a[mid] < x) l = mid + 1;
			else if( a[mid] > x) r = mid;
		}
		printf("%d %d\n",left,l-1);
		//因为l = mid+1; 退出来时l在mid+1上，而需要返回mid即mid-1
	}
}
```

### [AcWing790.数的三次方根](https://www.acwing.com/problem/content/792/)|二分

> 给定一个浮点数 n ，求它的三次方根。
>
> #### 输入格式
>
> 共一行，包含一个浮点数 n。
>
> #### 输出格式
>
> 共一行，包含一个浮点数，表示问题的解。
>
> 注意，结果保留 6位小数。
>
> #### 数据范围
>
> −10000≤n≤10000

直接二分搜索一个mid满足`mid*mid*mid`最接近n的——最接近就是误差小于`1e-8`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

double x;

int main(){
  cin>>x;
  double l = -10000, r = 10000;
  while(r-l > 1e-8){//精度还不够的话
    double mid = (l+r)/2;
    if(mid*mid*mid >= x) r = mid;
    else l = mid;
  }
  printf("%.6lf",l);
}
```

- 使用cbrt函数也是可以的
- 或者pow——要先处理一下负数

```cpp
int main(){
    double a;
    scanf("%lf",&a);
    //if(x<0) printf("-") ,x=-x;
    //printf("%.6lf",pow(x,1/3.0));  // pow不能处理负数
    printf("%.6lf",cbrt(a));
    return 0;
}
```

### [AcWing1221.四平方和](https://www.acwing.com/problem/content/1223/)|二分

> 四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多 4个正整数
> 的平方和。如果把 0包括进去，就正好可以表示为 4个数的平方和。比如：
>     5=0^2+0^2+1^2+2^2
>     7=1^2+1^2+1^2+2^2
> 对于一个给定的正整数，可能存在多种平方和的表示法。要求你对 4个数排序：0≤a≤b≤c≤d
> 并对所有的可能表示法按 a,b,c,d为联合主键升序排列，最后输出第一个表示法。

**四重循环优化为三重循环**

此时时间复杂度为O(N^3)——(5\*10^6)^3>>10^8，数据强的时候就过不了了。所以循环最多二重

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()  
{  
    int n,a,b,c,d;  
    scanf("%d",&n);   
    int sqn = int(sqrt(n));
    for(a=0;a<=sqn;++a)  
    {  
        for(b=a;b<=sqn;++b)  
        {  
            for(c=b;c<=sqn;++c)  
            {  
                d=sqrt(n-a*a-b*b-c*c); //这里减少一重循环 
                if(n==a*a+b*b+c*c+d*d)  
                {  
                    if(c>d)swap(d,c);
                    printf("%d %d %d %d\n",a,b,c,d);  
                    return 0;  
                }   
            }   
        }   
    }   
}

```

**优化循环为二重+利用二分**

预处理c、d且存下来

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 25e5 + 10;

struct Sum
{
    int s, c, d; // s表示c和d的平方
    bool operator<(const Sum& t) const //返回较小的那个
    {
        if(s != t.s) return s < t.s;
        if(c != t.c) return c < t.c;
        return d < t.d;
    }
} sum[N];

int n, m;

int main(void)
{
    scanf("%d", &n);

    for(int c = 0; c * c <= n; c++)
        for(int d = c; c * c + d * d <= n; d++) sum[m++] = {c * c + d * d, c, d};

    sort(sum, sum + m);

    for(int a = 0; a <= n; a++)
        for(int b = 0; b * b + a * a <= n; b++)
        {
            int t = n - a * a - b * b;
            int l = 0, r = m - 1;
            while(l < r)
            {
                int mid = l + r >> 1;
                if(sum[mid].s >= t) //要找一个最小的 所以是>=
                    r = mid;
                else
                    l = mid + 1;
            }
            if(sum[l].s == t)
            {
                printf("%d %d %d %d\n", a, b, sum[l].c, sum[l].d);
                return 0;
            }
        }
    return 0;
}

```



**优化循环为二重：优化枚举：哈希+枚举**

> 减少枚举次数
> 确定枚举范围：
> a 0–sqrt(510^6/4)  : a a a a
> b 0–sqrt(510^6/3)  : 0 b b b 
> c 0–sqrt(510^6/2)  : 0 0 c c
> d 0–sqrt(510^6)	 : 0 0 0 d
>
> 预先求出R=c^2+d^2的解 用**哈希表unordered_map**来保存一个R对应的c

利用哈希表存储预处理的c、d，后面直接拿来操作——封装好的unordered_map 中的查询函数效率肯定不必自己写的二分差的。

**但这个会超时——我不理解，这时间复杂度不是O(N^2)吗**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n;
unordered_map<int, PII> mp;
int main(){
  cin>>n;
  for(int c =0;c*c<=n/2; c++) //c的枚举范围优化
    for(int d = c; d*d+c*c <= n; d++){//d>=c所以直接从c开始
      int t = c*c + d*d;
      if(mp.count(t) == 0) mp[t] = {c, d};//没有就存；有了的话，顺序也排在后面，没必要存
    }

  for(int a = 0; a*a <= n/4; a++){//优化枚举范围
    for(int b = a; a*a+b*b<=n/2; b++){//这里同样可以优化枚举范围
      int t = n - a*a-b*b;
      if(mp.count(t)){
        cout<<a<<" "<<b<<" "<<mp[t].first<<" "<<mp[t].second;
        //输出第一个就可以了
        return 0;
      }
    }
  }
}
```

**优化循环+优化枚举+数组打表代替哈希表**

感觉两个原理差不多，不知道为什么上面那个复杂度会超，有懂的吗。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
const int N = 1e8 + 10;
int h[N];
int main() {
    int n;
    cin >> n;
    //打表 
    for (int c = 0; c * c * 2<= n; c++) {    //优化了枚举范围
        for (int d = c; d * d + c * c <= n; d++) {
            if (!h[c * c + d * d])//之前没记录过
                h[c * c + d * d] = c + 1;//标记，防止i = 0时在后面判断查找跳过 i = 0的情况
        }
    }
      
    for (int a = 0; a * a * 4 <= n; a++) {     //优化了枚举范围
        for (int b = a; b * b + a * a <= n / 2; b++) {
            int t = n - a * a - b * b;
            if (h[t]) {
                int c = h[t] - 1;   //恢复标记
                //防止开根号后因为精度关系,向下取整,例:25 开根号得到4.99999向下取整为4;
                int d = (sqrt(t - c * c) + 1e-4);
                printf("%d %d %d %d", a, b, c, d);
                return 0;
            }
        }
    }
    return 0;
}

```



---

## 前缀和

**一维前缀和**

![image-20211211210344450](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211210344450.png)

### [AcWing795.前缀和](https://www.acwing.com/problem/content/797/)

> 输入一个长度为n的整数序列。
>
> 接下来再输入m个询问，每个询问输入一对l, r。
> 对于每个询问，输出原序列中从第l个数到第r个数的和。
>
> 输入格式
> 第一行包含两个整数n和m。
>
> 第二行包含n个整数，表示整数数列。
>
> 接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。
>
> 输出格式
> 共m行，每行输出一个询问的结果。
>
> 数据范围
> 1≤l≤r≤n,
> 1≤n,m≤100000,
> −1000≤数列中元素的值≤1000

<img src="https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211211040800.png" alt="image-20211211211040800" style="zoom:80%;" />

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)\

const int N = 1e5+10;
int a[N], sum[N];
int main(){
  int n, m;
  cin>>n>>m;
  for(int i =1;i<=n;i++){
    cin>>a[i];
    sum[i] = a[i] + sum[i-1];    
  }
  while(m--){
    int l, r;
    cin>>l>>r;
    cout<<sum[r] - sum[l-1]<<endl;
  }
}
```

**二维前缀和**

<img src="https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211212444311.png" alt="image-20211211212444311" style="zoom:80%;" />

### AcWing 796.子矩阵的和

> 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。
>
> 对于每个询问输出子矩阵中所有数的和。
>
> #### 输入格式
>
> 第一行包含三个整数n，m，q。
>
> 接下来n行，每行包含m个整数，表示整数矩阵。
>
> 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。
>
> #### 输出格式
>
> 共q行，每行输出一个询问的结果。
>
> #### 数据范围
>
> 1≤n,m≤1000,
> 1≤q≤200000,
> 1≤x1≤x2≤n,
> 1≤y1≤y2≤m,
> −1000≤矩阵内元素的值≤1000



```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e3+10;
int a[N][N], s[N][N];
int main(){
  int  n, m , q;
  cin>>n>>m>>q;
  for(int i =1;i<=n;i++)
    for(int j = 1;j<=m;j++)
      cin>>a[i][j];
  
  for(int i = 1; i<= n; i++)
    for(int j = 1;j <=m; j++)
      s[i][j] = s[i-1][j]+s[i][j-1] - s[i-1][j-1]  + a[i][j];//注意减去重叠导致的多余部分

  int x1, y1, x2, y2;
  while(q--){
    cin>>x1>>y1>>x2>>y2;
    int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];//画个图就知道了
    cout<<res<<endl;
  }
}
```

### [AcWing1230.K倍区间](https://www.acwing.com/problem/content/1232/)|前缀和

1. sum[i]表示第1个元素到第i个元素
2. sum[r] - sum[l-1]就是区间[l,r]的和
3. 区间[l,r]的和是k的倍数即(sum[r] - sum[l-1])%k == 0
4. **sum[r]%k == sum[l-1]%k**

所以在求 sum 时就进行取模，最后有**两个**相等的**前缀和%k**区间就可以形成一个 **K倍区间**。——如共有5个前缀和%k==1的，可以从里面选任意两个的组合数就是**前缀和%k==1 的K倍区间数**。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5+10;
ll s[N];//前缀和数组
int cnt[N];//cnt[x]： 前缀和%k 为x 的个数
ll res = 0;//最后的答案

int main(){
  int  n, k;
  cin>>n>>k;
  for(int i = 1; i<=n; i++){
    cin>>s[i];
    s[i] += s[i-1];
  }
  cnt[0]++;//s[0]放进去
    //后面再有s[i]%k==0 的时候，前面这个s[0]就可以认为是该区间的左端点。
  //这一步的目的是当[1,i]区间累加成的数，也就是s[i]是k的倍数。那么区间[1，i]也是一个k倍区间，但是需要前面有一个点作为这个区间的左端点。而此时s[i]%k进行取余等于0，所以将cnt[0]++;
    
  for(int i = 1; i<=n; i++){
    res += cnt[s[i] % k];
    cnt[s[i]%k] ++;
  }
  cout<<res;
}
```

