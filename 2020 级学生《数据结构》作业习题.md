# 这个学期需要完成以下的全部作业习题。
作业习题列表：

## 第2章

1. 设线性表存储在数组A[1..arrsize]的前elenum个分量中，且递增有序。试编写一个算法：将线性表中的元素x删除，以保持线性表的有序性，并且分析算法的时间复杂度。

   ```cpp
   //没有就返回 -1
   int deletex(int A[],int &elenum, int x){
   	int del_idx = -1;
       for(int i = 0; i < elenum; i++){
           if(A[i] == x){
               del_idx = i;
               break;
           }
       }
       if(del_idx == -1) return -1;
       for(int i = del_idx; i < elenum; i++){
           A[i] = A[i + 1];
       }
       elenum--;
       return 1;
   }
   ```

   

2. 已知单链表L中的结点是按值非递减有序排列的，试编写一算法将链表L中值为X的结点删除，使得L仍然有序。

   ```cpp
   int deleteXinL(LNode* head, int x){
   	if(head == nullptr) return -1;
       LNOde *cur = head, *tmp;
       while(cur->next != nullptr && cur->next->val != x){
           cur = cur->next;
       }
       if(cur->next == nullptr) return -1;
       tmp = cur->next;
       cur->next = cur->next->next;
       delete tmp;
       return 1;
   }
   ```

   

3. 用单链表作存储结构，编写一个实现线性表中元素逆置的算法。

   ```cpp
   LNode* reverseL(LNode* head){
       LNode* cur = head, nxt, pre;
       while(cur!= nullptr){
           nxt = cur->next;
           cur->next = pre;
           pre = cur;
           cur = nxt;
       }
       return pre;
   }
   ```

4. 已知一个单链表中的数据元素含有三类字符（即字母字符，数字字符和其它字符），试编写算法，构造三个循环链表，使每个循环链表中只含有同一类的字符，且利用原表中的结点空间作为这三个表的结点空间。

   ```cpp
   ```

   

5. 试编写一个算法，找出一个循环链表中的最小值并删除。

   ```cpp
   LNode* deleteMin(LNode* head){
       LNode *cur = head->next, *pre = head,
       	  *minp = head->next, *minPre = head;
       while(cur != head){
           if(cur->val < minp->val){
               minp = cur;
               minPre = pre;
           }
           pre = cur;
           cur = cur->next;
       }
       minpre->next = minp->next;
       return minp;
   }
   ```

   

## 第5章

1. 以二叉链表作存储结构，编写一个算法将二叉树左、右子树进行交换的算法。

   ```cpp
   typedef struct BiTNode{
       char data;
       struct BiTNode *lchild,*rchild;
   }BiTNode,*BiTree;
   
   void exchange(BiTree &T){
   	if(T){
           if(T->lchild == nullptr && T->rchild == nullptr)return;
           else {
               BiTree tmp;
               tmp = T->lchild;
               T->lchild =T->rchild;
               T->rchild = tmp;
           }
           exchange(T->lchild);
           exchange(T->rchild);
       }    
   }
   ```

   

2. 一棵具有n个结点的**完全二叉树**存放在二叉树的**顺序存储**结构中，试编写**非递归**算法对该树进行**中序**遍历。

   前序：方法一，用栈来模拟递归——**递归是左递归，右递归。但是利用栈要相反**,先放右节点进栈，再放左节点进栈——取节点时就会先取到左节点，达到与递归一样的效果。

   ```cpp
   //前序 迭代
   void preOrd(int T[], int n){
       stack<int> st;
       int root = 0, lchild, rchild;
       s.push(root);
       while(!s.empty()){
           root = s.top();
           s.pop();
           cout<<T[root]<<" ";
           lchild = root * 2 + 1;
           rchild = root * 2 + 2;
           if(rchild < n) s.push(rchild);
           if(lchild < n) s.push(lchild);
       }
   }
   //另一种写法 : 与中序同样写法
   void preOrd(int T[], int n){
       stack<int> st;
       int root = 0;
       while(!st.empty() || root < n){
        	if(root < n){
               cout<<T[root]<<" ";.//根
               st.push(root);
               root = root * 2 + 1;//左
           }else{
               root = st.top();
               st.pop();
               root = root * 2 + 2;//右
           }        
       }
   }
   ```

   中序：中序排列的顺序是：`左节点，根节点，右节点`。那么我们在经过根节点的前面节点 不能释放

   - 栈`依次存入左节点所有点`，直到最左侧在栈顶。
   - 开始`抛出栈顶并访问`。(例如第一个抛出2)。如果有右节点。那么将`右节点加入栈中`，然后右节点一致左下遍历直到尾部。

   ```cpp
   void inOrd(int T[], int n){
       stack<int> st;
       int root = 0;
       while(!st.empty() || root < n){
           if(root < n){
               st.psuh(root);
               root = root * 2 + 1;//左
           }else{
               root = st.top();
               st.pop();
               cout<<T[root]<<" ";//根
               root = root * 2 + 2; //右
           }
       }
   }
   ```

   后序也有和前面差不多的方法，但需要额外的标记——一个节点访问第二次时才能输出——访问：

   - 第一次是入栈时
   - 第二次是子树解决完毕，**即将**出栈时。

   ```cpp
   void postOrd(int T[], int n){
       stack<int> st;
       map<int, int> mp;
       int root = 0;
       while(!st.empty() || root < n){
           if(root < n){
               st.push(root);
               map[root]++;
               root = root * 2 + 1;
           }else{
               root = st.top();
               if(map[root] == 2){//第二次访问时，抛出
                   st.pop();
                   cout<<T[root]<<" ";
                   root = n;//为了下个循环往上走
               }else{
                   map[root]++;
                   root = root * 2 + 2;
               }
           }
       }
   }
   ```

   

   **总结：**

   - 前序: 

     - `中入栈`——>`左入栈`——>左出栈——>中出栈——>`右入栈`——>右孩子入出——>右出栈 ,在**入栈**时候操作即可

   - 中序: 

     - 中入栈——>左入栈——>`左出栈`——>`中出栈`——>右入栈 ——>右孩子入出——>`右出栈`,按照**出栈**顺序即可

   - 后序：

     - 入栈，第一次访问
     - `即将出栈`。第二次访问，
     - 如果有右孩子，先不出栈把右孩子压入栈。**如果没右孩子，输出并从栈中弹出。**
     - 循环重复，直到栈为空

     

3. 试编写算法判别两棵二叉树是否等价。如果T1和T2都是空二叉树，或T1和T2的根结点的值相同，并且T1的左子树与T2的左子树是等价的；T1的右子树与T2的右子树是等价的。

   ### 递归写法：

   非常简单

   ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       //递归
       bool isSameTree(TreeNode* p, TreeNode* q) {
           if(p == nullptr && q == nullptr) return true;
           if(p == nullptr || q == nullptr) return false;
           if(p->val != q->val) return  false;
           return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
       }
   };
   ```

   ### 迭代写法： 借助栈

   ```cpp
   bool isSameTree(TreeNode* p, TreeNode* q) {
           stack<TreeNode*> st; //与队列差不多，但是用栈处理指针的顺序和队列相反
           st.push(p);
           st.push(q);
           while(!st.empty()){
               TreeNode* root1 = st.top();st.pop();
               TreeNode* root2 = st.top();st.pop();
               
               if(root1 == nullptr && root2 == nullptr) continue;            
               if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
               
               st.push(root1->left);
               st.push(root2->left);
               st.push(root1->right);
               st.push(root2->right);
           }
           return true;
       }
   ```

   ### 用队列也是一样的

   ```cpp
    bool isSameTree(TreeNode* p, TreeNode* q) {
       queue<TreeNode*> que;  
       que.push(p);
       que.push(q);
       while(!que.empty()){
           TreeNode* root1 = que.front();que.pop();
           TreeNode* root2 = que.front();que.pop();
           
           if(root1 == nullptr && root2 == nullptr)continue;
           if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
    
           que.push(root1->left);
           que.push(root2->left);
           que.push(root1->right);
           que.push(root2->right);
       }
       return true;
   }
   
   ```

   

4. 设计一个实现一棵二叉树复制的算法。

   ```cpp
   TNode* copyBitTree(TNode* head){
       TNode* ansHead;
       if(head == nullptr){
           return nullptr;
       }
       TNode* leftc = copyBitTree(head->left);
       TNode* rightc = copyBitTree(head->right);
       ansHead->left = leftc;
       ansHead->right = rightc;
       return ansHead;
   }
   ```

   

5. 编写一个将二叉树的所有叶子结点从左向右链接成单链表的算法。

   ```cpp
   void leafLink(TNode* root, TNode*&first, TNode*&pre){
       if(root == nullptr)return;
       if(root->right == nullptr && root->left == nullptr){
           if(first == nullptr){
               first = root; //保存的第一个叶子节点
               pre = first;
           }else{
    			pre->right = root;
               pre = pre->right;
           }
       }
       if(root->left) leafLink(root->left);
       if(root->right) leafLink(root->right);
   }
   ```

   

6. 设具有n个结点的完全二叉树采用顺序存储结构，试写一个算法将该顺序存储结构转换为二叉链式存储结构。

   ```cpp
   TNode* seqToBit(int &t[], int root, int tSize){
       if(root < tSize) return nullptr;
       TNode* head;head->val = t[root];
       head->left = seqToBit(t, root*2+1);
       head->righgt = seqToBit(t, root*2+2);
       return head;
   }
   ```

   

7. 设具有n个结点的二叉树采用二叉链式存储结构，试写出一个算法将该二叉链式存储结构转换为顺序存储结构。

   ```cpp
   void BitToSeq(int &t[], TNode* node, int i){
       if(node){
           t[i] = node->val;
           BitToSeq(t, node->left, i*2+1);
           BitToSeq(t, node->right, i*2+2);
       }else{
           t[i] = '/';
       }
   }
   ```

   

## 第7章

1. 设二叉树采用二叉链式结构存储，试写出一个算法判断该二叉树是否为二叉查找树。
2. 编写一个采用二叉链式结构做存储结构的二叉排序树建立和查找算法。
3. 用线性探测方法解决冲突的散列存储、查找以及删除操作。【散列函数自定义】
4. 用拉链方法解决冲突的散列存储、查找以及删除操作。【散列函数自定义】

## 第8章

1. 分别写出用邻接矩阵和邻接表做图的存储结构，并分别实施广度优先遍历和深度优先遍历。
2. 写出求最小生成树的算法。
3. 写出求一点顶点到其余各个顶点的最短路径的算法 

4. 写出求有向图拓扑序列的算法。

## 第9章

1. 写出以单链表做存储结构的直接插入排序算法。
2. 写出快速排序算法。
3. 写出堆排序算法。