

# 说在前面

## 小tips

 

![ ](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

**各数据类型取值范围与10的数量级对照**

>   类型名称                                                     取值范围
>    int                                                         		-2^31~（2^31-1）
>   unsigned int       										      0~（2^32-1）
>   2^31=2,147,483,648 				 10^9数量级
>   2^32=4,294,967,296  				10^9数量级
>
>   类型名称                                                        取值范围
>   long long (_int64)                                     -2\^63~(2\^63-1）
>
>   unsigned long long (unsigned_int64)     0~(2^64-1)
>   2^63=9,223,372,036,854,775,808      10^18数量级
>   2^64=18,446,744,073,709,551,616  	 10^19数量级

## 天梯总结

L1 , L2 大多是模拟题目，L3很多是搜索图论计算几何题目。

**后面的L3比前面的L3难很多**

# L1

## L1-064 估值一亿的AI核心代码 (20 分)

> - 无论用户说什么，首先把对方说的话在一行中原样打印出来；
> - 消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；
> - 把原文中所有大写英文字母变成小写，除了 `I`；
> - 把原文中所有独立的 `can you`、`could you` 对应地换成 `I can`、`I could`—— 这里“独立”是指被空格或标点符号分隔开的单词；
> - 把原文中所有独立的 `I` 和 `me` 换成 `you`；
> - 把原文中所有的问号 `?` 换成惊叹号 `!`；
> - 在一行中输出替换后的句子作为 AI 的回答。

使用`regex_replace`的正则语句来处理，非常好用（之前学 `js` 时学过规则，还记得一点..）

- `R`表示对原生字符串操作
- `\s+`来表示若干个空格
- `^`表示开头，`$`表示结尾，`\W`是非数字、字母的字符
- 将`I`暂时用 `mar_k` 代替，以防后续转换后出现的 `I`与原句中的 `I` 混淆，`\b`匹配单词的边界

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
string s;
int main() {
  int n;
  cin >> n;
  getchar();
  FOR(i, 0, n) {
    getline(cin, s);
    cout << s << "\n"
         << "AI: ";                              //输出原句以及 "AI: "
    s = regex_replace(s, regex(R"(\s+)"), " ");  //将多个空格换为一个
    s = regex_replace(s, regex(R"(^\s+|\s+$|\s+(?=\W))"),
                      "");  //删掉行首行尾空格、标点符号前空格
    s = regex_replace(s, regex(R"(\bI\b)"), "mar_k");  //先把I换了
    FOR(i, 0, s.size())
    if (s[i] != 'I') s[i] = tolower(s[i]);  //除了I以外都小写
    s = regex_replace(s, regex(R"(\bcan you\b)"), "I can");
    s = regex_replace(s, regex(R"(\bcould you\b)"), "I could");
    s = regex_replace(s, regex(R"(\bmar_k\b|\bme\b)"), "you");
    s = regex_replace(s, regex(R"(\?)"), "!");  // 把问号都换成感叹号
    cout << s << "\n";
  }
  system("pause");
  return 0;
}
```

# L2



## L2-001 紧急救援 (25 分)|Dijkstra

**注释：**

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e8;
// N<500
int saveTeam[505];  //各点的存储的救援人数
int st[505];        //按路径能召集到的最多人数
int mm[505][505];   //地图
int number[505];    //到该点最短路径的数量
int vis[505];       //是否标记为node过
int dis[505];       //起点到该点的距离
int father[505];    //最短路径中，该点的上一个节点
int n, m, s, d;     //城市数量、路线数量、起点、终点

void Dijkstra() {
  //初始化
  fill(dis, dis + n, INF);
  fill(vis, vis + n, 0);
  fill(number, number + n, 0);
  dis[s] = 0;
  st[s] = saveTeam[s];
  number[s] = 1;
  for (int i = 0; i < n; i++) {
    int minn = INF, node = -1;
    for (int j = 0; j < n; j++) {
      if (!vis[j] && dis[j] < minn) {
        minn = dis[j];
        node = j;
      }
    }
    vis[node] = 1;
    if (node == -1) return;
    for (int j = 0; j < n; j++) {
      if (vis[j] == 0 && mm[node][j] != -1 &&
          (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        father[j] = node;
        number[j] = number[node];
      } else if (vis[j] == 0 && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j]) == dis[j]) {
        if ((st[node] + saveTeam[j]) > st[j]) {
          st[j] = st[node] + saveTeam[j];
          father[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  for (int i = 0; i < n; i++) {
    cin >> saveTeam[i];
  }
  //初始化地图
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      mm[i][j] = -1;
    }
  }
  //读入地图
  for (int i = 0; i < m; i++) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val;
    mm[n2][n1] = val;
  }
  Dijkstra();
  int p = d;
  while (1) {
    if (father[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = father[p];  //在这里使得起点 father[p] == p
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1) {
      cout << pathV[i];
    } else {
      cout << " " << pathV[i];
    }
  }
```

**无注释：**

```cpp


#include <bits/stdc++.h>
using namespace std;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 505, INF = 1e8;
int st[N], saveTeam[N], vis[N], dis[N], number[N], mm[N][N], fa[N], n, m, s, d;
void dj() {
  fill(vis, vis + N, 0), fill(dis, dis + N, INF), fill(number, number + N, 0);
  dis[s] = 0, st[s] = saveTeam[s];
  number[s] = 1;
  FOR(i, 0, n) {
    int minn = INF, node = -1;
    FOR(j, 0, n) {
      if (!vis[j] && dis[j] < minn) minn = dis[j], node = j;
    }
    if (node == -1) return;
    vis[node] = 1;
    FOR(j, 0, n) {
      if (!vis[j] && mm[node][j] != -1 && (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        fa[j] = node;
        number[j] = number[node];
      } else if (!vis[j] && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j] == dis[j])) {
        if ((st[node] + saveTeam[j] > st[j])) {
          st[j] = st[node] + saveTeam[j];
          fa[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  FOR(i, 0, n) { cin >> saveTeam[i]; }
  FOR(i, 0, n) FOR(j, 0, n) mm[i][j] = -1;
  FOR(i, 0, m) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val, mm[n2][n1] = val;
  }
  dj();
  int p = d;
  while (1) {
    if (fa[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = fa[p];
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1)
      cout << pathV[i];
    else
      cout << " " << pathV[i];
  }
}
```



## **L2-002 链表去重** 

- 主要在于用结构体存储
- 两个数组充当两个链表 ， `t1 t2`分别作为两个指针下标并且代表链表的长度，数组中存储对应的地址
- ` ad1 = node[ad1].nxt;`通过访问结构体中nxt 进行指针跳转
- ==node下标作为当前结点的坐标，很妙==

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5 + 10;
struct Node {
  int key, nxt;
} node[N];         // node[i]:地址为i，键值为node[i].key
int p1[N], p2[N];  //去重后的链表、被删除的链表
int flag[N];       //记录其绝对值是否出现过
int main() {
  int ad1, n;  // ad1:头地址
  cin >> ad1 >> n;
  int a, b, c;
  FOR(i, 0, n) {
    cin >> a >> b >> c;
    node[a].key = b, node[a].nxt = c;
  }
  int t1 = 0, t2 = 0;            //分别是两个链表的指针
  while (n--) {                  //枚举每个节点
    int k = abs(node[ad1].key);  // ad1开始充当头指针
    if (!flag[k]) {
      flag[k] = 1, p1[t1++] = ad1;
    } else
      p2[t2++] = ad1;
    ad1 = node[ad1].nxt;
    if (ad1 == -1) break;
  }
  FOR(i, 0, t1) {
    ad1 = p1[i];
    if (i == t1 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p1[i + 1]);
  }
  FOR(i, 0, t2) {
    ad1 = p2[i];
    if (i == t2 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p2[i + 1]);
  }
}
```



## L2-003 月饼 (25 分)|简单模拟|贪心

根据月饼的总价和数量计算出每一种月饼的单价，然后将月饼数组==按照单价从大到小排序==，根据需求量need的大小，从单价最大的月饼开始售卖，将销售掉这种月饼的价格累加到result

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

struct node {
  double num, price;
} a[1005];
bool cmp(node a, node b) { return a.price / a.num > b.price / b.num; }
int n, d;
int main() {
  while (cin >> n >> d) {
    FOR(i, 0, n) { cin >> a[i].num; }
    FOR(i, 0, n) { cin >> a[i].price; }
    sort(a, a + n, cmp);
    double res = 0;
    FOR(i, 0, n) {
      if (a[i].num < d) {
        res += a[i].price;
      } else {
        res += a[i].price / a[i].num * d;
        break;
      }
      d = d - a[i].num;
    }
    printf("%.2f", res);
  }
  return 0;
}
```

## L2-004 这是二叉搜索树吗？ (25 分)|二叉搜索树性质：前序遍历->后序遍历

- 其左子树中所有结点的键值小于该结点的键值；
- 其右子树中所有结点的键值大于等于该结点的键值；
- 其左右子树都是二叉搜索树。

相关笔记：https://www.yuque.com/qzhou/learning/sw1t80

> 假设它是二叉搜索树，一开始`isMirror`为FALSE，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设`isMirror`为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出NO否则输出YES
>
> 原文链接：https://blog.csdn.net/liuchuo/article/details/52160484

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, pre[1005];
vector<int> resv;
bool is_mir = 0;

void solve(int root, int tail) {
  if (root > tail) return;
  int i = root + 1, j = tail;  // 用双指针是因为不能确定他是二叉搜索树，单指针可能误判
  if (!is_mir) {
    while (i <= tail && pre[i] < pre[root]) i++;  //找该节点的左子树
    while (j > root && pre[j] >= pre[root]) j--;  //找该节点的右子树
  } else {
    while (i <= tail && pre[i] >= pre[root]) i++;
    while (j > root && pre[j] < pre[root]) j--;
  }
  solve(root + 1, i - 1);//左
  solve(j + 1, tail);//右
  resv.push_back(pre[root]);//中
}

int main() {
  cin >> n;
  FOR(i, 0, n) cin >> pre[i];
  solve(0, n - 1);
  if (resv.size() != n) {
    resv.clear();
    is_mir = 1;
    solve(0, n - 1);
  }
  if (resv.size() != n) {
    cout << "NO" << endl;
  } else {
    cout << "YES" << endl;
    FOR(i, 0, resv.size()) {
      if (i != 0) cout << " ";
      cout << resv[i];
    }
  }
  return 0;
}
```

## L2-005 集合相似度 (25 分|简单模拟|set

集合，它们的相似度定义为：*N~c~*/*N~t~*×100%。其中*N~c~*是两个集合都有的不相等整数的个数（都有的：即交集大小），*N~t~*是两个集合一共有的不相等整数的个数（a 并 b 得到的集合的大小），借助 set 可以很简单的完成：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, n, m) for (int i = n; i < m; i++)

const int N = 55;
set<int> st[N];

int main() {
  int n, m, x;
  cin >> n;
  FOR(i, 1, n + 1) {  //注意集合下标从1开始
    cin >> m;
    FOR(j, 0, m) {
      cin >> x;
      st[i].insert(x);
    }
  }
  int k;
  cin >> k;
  FOR(i, 0, k) {
    int a, b;
    cin >> a >> b;
    int cnt = 0;  //共有cnt个数相同，即交集的大小
    for (auto it = st[a].begin(); it != st[a].end(); ++it) {
      if (st[b].count(*it)) cnt++;
    }
    printf("%.2f%\n", cnt * 1.0 / (st[a].size() + st[b].size() - cnt) * 100);
  }
  return 0;
}
```



## L2-006 树的遍历 (25 分)|二叉树：后序+中序 => 层序

层序遍历利用 map 的有序性来完成。

递归传入左孩子、右孩子下标即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post, in;
map<int, int> level;
void pre(int root, int start, int end, int index) {
  if (start > end) return; //千万记得要有退出条件
  int i = start;
  while (i < end && in[i] != post[root]) i++;
  level[index] = post[root];
  pre(root - 1 - end + i, start, i - 1, 2 * index + 1);	//左
  pre(root - 1, i + 1, end, 2 * index + 2);				//右
}
int main() {
  int n;
  cin >> n;
  post.resize(n);
  in.resize(n);
  FOR(i, 0, n) cin >> post[i];
  FOR(i, 0, n) cin >> in[i];
  pre(n - 1, 0, n - 1, 0);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
  return 0;
}
```



## **L2-007 家庭房产 (25 分)**|并查集|

- pair存边
- 自定义结构体以及其排序规则
- 要注意家里只有自己一个人与根本没这家人要区别

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;
int f[N], avN[N], peo[N], avS[N];
bool st[N];  //家里只有自己的和没参与统计的 都有 f[i]==i, 所以需要特殊标记
int find(int x) { return x == f[x] ? f[x] : f[x] = find(f[x]); }
int cntme = 0;
void merge(int a, int b) {  //在merge里将相关属性传递好
  // int x = f[a], y = f[b];        //这里写错好多次！！有点rz
  int x = find(a), y = find(b);
  cntme++;
  if (x != y) {
    int mx = max(x, y), mn = min(x, y);
    f[mx] = mn;          // id小的作为家庭代表
    peo[mn] += peo[mx];  //家庭人数
    avN[mn] += avN[mx];  //家庭房子套数
    avS[mn] += avS[mx];  //家庭总面积
  }
}
vector<PII> e;   //存储关系，方便操作
struct Family {  // id, num, aN, aS
  int id, num, aN, aS;
};
bool cmp(Family a, Family b) {
  if (a.aS * 1.0 / a.num == b.aS * 1.0 / b.num) {
    return a.id < b.id;
  }
  return a.aS * 1.0 / a.num > b.aS * 1.0 / b.num;
}
int cnt = 0;
int main() {
  FOR(i, 0, N) { f[i] = i, peo[i] = 1; }
  int n;
  cin >> n;
  int me, fa, mo, k, ch;
  FOR(i, 0, n) {
    cin >> me >> fa >> mo >> k;
    if (fa != -1) e.push_back({me, fa});
    if (mo != -1) e.push_back({me, mo});
    st[me] = 1;  //有统计的标记

    FOR(j, 0, k) {
      cin >> ch;
      e.push_back({me, ch});
    }
    cin >> avN[me] >> avS[me];
  }
  FOR(i, 0, e.size()) {
    int fir = e[i].first, sec = e[i].second;
    merge(fir, sec);
    st[e[i].first] = st[e[i].second] = 1;  //有统计的标记
  }
  vector<Family> ans;
  int cntst = 0, cntf = 0;
  FOR(i, 0, N) {
    if (st[i]) cntst++;
    if (f[i] == i) cntf++;
    if (st[i] && f[i] == i) {  //有这个家庭并且他是代表
      ans.push_back({i, peo[i], avN[i], avS[i]});
    }
  }

  sort(ans.begin(), ans.end(), cmp);
  cout << ans.size() << endl;
  for (auto it : ans) {
    printf("%04d %d %.3lf %.3lf\n", it.id, it.num, it.aN * 1.0 / it.num,
           it.aS * 1.0 / it.num);
  }
}

```





## L2-8 最长对称子串|马拉车算法|⭐

使用到马拉车算法，算法主要思想就是利用回文的特性——知道左边的回文长度一定程度上就能知道右边的回文长度

以前记过[笔记](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8) 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

string mnc(string x) {
  string s = expendS(x);
  int Len[10000], idd = 0, maxx = 0, maxLen = 0, start = 0;
  FOR(i, 0, s.size()) {
    if (i < maxx)
      Len[i] = min(Len[2 * idd - i], maxx); // min(i 关于 idd 对称的点的最长距离, 能到达的最右边)
    else
      Len[i] = 1;                 				//没得优化就只能等待暴力
  //不论优化没有 都要暴力一下看看
    while (i + Len[i] < s.size() && i - Len[i] > 0 && //下标范围合法
           s[i + Len[i]] == s[i - Len[i]]) {			//对称
      Len[i]++;
    }
  //是否更新状态
    if (Len[i] + i > maxx) maxx = Len[i] + i, idd = i;
    if (Len[i] - 1 > maxLen) maxLen = Len[i] - 1, start = (idd - maxLen) / 2;
  }
  return s.substr(start, maxLen);
}
int main() {
  ios::sync_with_stdio(false);
  string s;
  getline(cin, s);
  cout << mnc(s).size();
  return 0;
}
```

## [L2-009 抢红包 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400)|结构体|自定义条件排序|浮点数精度缺失

给出*N*个人之间互相发红包、抢红包的记录

**疑问**：为什么提前处理 单位 `分 * 0.01 = 元` 后再记入结构体中就会出错

> **因为==涉及浮点数处理问题==，因此==不建议输入的时候就除100单位换算==，因为会==造成精度缺失问题==，这也是测试点0的坑点！**
> **建议在输出的时候再进行单位换算。**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e4 + 10;  //编号从1开始

struct P {
  int id;  //后面初始化
  int num = 0;
  double price = 0;
};
bool cmp(P a, P b) {
  if (a.price == b.price) {
    if (a.num == b.num) {
      return a.id < b.id;  //递增
    }
    return a.num > b.num;  //递减
  }
  return a.price > b.price;  //递减
}
vector<P> peo;
int main() {
  int n;
  cin >> n;
  peo.resize(n + 1);
  FOR(i, 0, n + 1) peo[i].id = i;  //初始化编号
  peo[0].price = INT_MAX;          //防止干扰
  FOR(i, 1, n + 1) {               // i是发红包人的编号
    int k;
    cin >> k;
    FOR(j, 0, k) {
      int id, prc;  //收红包人的编号以及这里收到的钱
      cin >> id;
      cin >> prc;
      peo[id].price += prc;  //读入的单位是分
      peo[id].num++;
      peo[i].price -= prc;
    }
  }
  sort(peo.begin(), peo.end(), cmp);
  FOR(i, 1, n + 1) { printf("%d %.2lf\n", peo[i].id, peo[i].price / 100); }
  return 0;
}
```

## [L2-010 排座位 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680)|并查集

> 朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的
>
> 每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出`No problem`；如果他们之间并不是朋友，但也不敌对，则输出`OK`；如果他们之间有敌对，然而也有共同的朋友，则输出`OK but...`；如果他们之间只有敌对关系，则输出`No way`。

乍一看，有点要用 `种类并查集`的意思，但实际上：

> 一般的并查集，维护的是具有==连通性、传递性==的关系，例如**亲戚的亲戚是亲戚**。但是，有时候，我们要维护另一种关系：**敌人的敌人是朋友**。种类并查集就是为了解决这个问题而诞生的。
>
> 维护的是一种**循环对称**的关系。
>
> 所以如果是三个及以上的集合，只要每个集合都是等价的，且集合间的每个关系都是等价的，就能够用种类并查集进行维护。

也就是说 只有==敌人的敌人是朋友==的情况才用种类并查集，所以这里简单存储一下 敌对关系即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 105;  //从1开始编号

int f[N], g[N][N];
int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
int query(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa == fb) {
    if (g[a][b]) return 3;
    return 1;
  } else {
    if (g[a][b]) return 4;
    return 2;
  }
}
void print(int q) {
  if (q == 1)
    cout << "No problem\n";
  else if (q == 2)
    cout << "OK\n";
  else if (q == 3)
    cout << "OK but...\n";
  else if (q == 4)
    cout << "No way\n";
}
int main() {
  FOR(i, 0, N << 1) f[i] = i;
  int n, m, k;
  cin >> n >> m >> k;
  FOR(i, 0, m) {
    int a, b, flag;
    cin >> a >> b >> flag;
    if (flag == 1)
      merge(a, b);
    else
      g[a][b] = g[b][a] = 1;
  }
  FOR(i, 0, k) {
    int a, b;
    cin >> a >> b;
    print(query(a, b));
  }
  return 0;
}
```







## [L2-011 玩转二叉树 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784)|二叉树|前序+中序=>层序

关于==镜面反转一棵树==，只需要在记录 下标时，**左孩子为2 \* index + 2， 右孩子为2 \* index + 1** 

递归完成后level数组中非-1的数就是按照下标排列的层序遍历的顺序

递归调用里传入 

1. 根节点
2. 根节点的左（右）子树起始位置
3. 根节点的左（右）子树结束位置
4. 层序数组中的下标

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;

vector<int> pre, in;
map<int, int> lev;
void level(int root, int start, int end, int index) {
  if (start > end) return;  //记得退出条件
  int i = start;
  while (i < end && in[i] != pre[root]) i++;
  lev[index] = pre[root];
  level(root + 1, start, i - 1, index * 2 + 2);
  level(root + 1 + i - start, i + 1, end, index * 2 + 1);
}
int main() {
  int n;
  cin >> n;
  pre.resize(n);
  in.resize(n);
  FOR(i, 0, n) cin >> in[i];
  FOR(i, 0, n) cin >> pre[i];
  level(0, 0, n - 1, 0);
  auto it = lev.begin();
  cout << it->second;
  while (++it != lev.end()) cout << " " << it->second;
  return 0;
}
```



## [L2-012 关于堆的判断 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805064676261888)|make_heap

`make_heap`非常方便~注意要每一次读入都操作，不然不符合题意。

主要麻烦在于处理输入的字符串

判断结点关系主要就是靠下标

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl

int n, m, x;
int heap[1001];
vector<int> a;
map<int, int> mp;  //插入的整数对应的下标：<值,下标>

int main() {
  cin >> n >> m;
  FOR(i, 0, n) {
    cin >> x;
    a.push_back(x);
    make_heap(a.begin(), a.end(), greater<int>()); //小顶堆
  }
  for (int i = 0; i < n; i++) {
    heap[i + 1] = a[i];  //使堆下标从1 开始，方便操作
  }
  for (int i = 1; i <= n; i++) mp[heap[i]] = i;
  int x, y;
  string s;
  for (int i = 0; i < m; i++) {
    cin >> x;
    cin >> s;
    //对每个命题的情况进行判断
    if (s[0] == 'a') {
      cin >> y >> s >> s;
      if (mp[x] / 2 == mp[y] / 2)  //兄弟结点就是 父节点一样
        printf("T\n");
      else
        printf("F\n");
    } else {
      cin >> s;
      cin >> s;
      if (s[0] == 'r') {
        if (mp[x] == 1)  //根节点下标为1
          printf("T\n");
        else
          printf("F\n");
      } else if (s[0] == 'p') {
        cin >> s;
        cin >> y;
        if (mp[x] == mp[y] / 2)  // x是y父节点，即x下标等于 y下标/2
          printf("T\n");
        else
          printf("F\n");
      } else if (s[0] == 'c') {
        cin >> s;
        cin >> y;
        if (mp[y] == mp[x] / 2)  // x是y的一个子结点，即y等于 x下标/2
          printf("T\n");
        else
          printf("F\n");
      }
    }
  }

  return 0;
}

```

## [L2-013 红色警报 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208)|并查集

每次被攻占都重新初始化 、计算`fa`，统计连通块数量是否减少

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1000;
int f[N];
bool lost[N];
int find(int a) { return f[a] == a ? a : f[a] = find(f[a]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
void init() { FOR(i, 0, N) f[i] = i; }

vector<PII> es;
int main() {
  int n, m;
  cin >> n >> m;
  init();
  FOR(i, 0, m) {
    int a, b;
    cin >> a >> b;
    es.push_back({a, b});
    merge(a, b);
  }
  int num = 0;
  FOR(i, 0, n) {
    if (f[i] == i) num++;
  }
  int k;
  cin >> k;
  FOR(i, 0, k) {
    int numx = 0;
    init();
    int x;
    cin >> x;
    lost[x] = 1;
    FOR(j, 0, m) {
      int a = es[j].first, b = es[j].second;
      // dbg(a);
      // dbg(b);
      if (!lost[a] && !lost[b]) {
        merge(a, b);
      }
    }
    FOR(j, 0, n) {
      if (f[j] == j && !lost[j]) numx++;
    }
    // dbg(numx);
    if (numx > num) {
      cout << "Red Alert: City " << x << " is lost!\n";
    } else {
      cout << "City " << x << " is lost.\n";
    }
    if (numx == 0) {
      cout << "Game Over.\n";
    }
    num = numx;
  }
  return 0;
}
```





## [**L2-014 列车调度 (25 分)**|](https://pintia.cn/problem-sets/994805046380707840/problems/994805063166312448)set|upper_bound

如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨；否则，选择一个**最接近（比他大）它车号的尾部车号**的队伍进入

只需要保存每一队的队尾车号，并且每一次都需要排序，那么可以选用 `set`来存储

其中最大值就是 `*st.rbegin()`

- 待插入的小于最大值：选择一个**最接近它车号的尾部车号**的队伍进入——移出第一个比他大的（最接近的），再插入
  - `s.upper_bound(t)`返回的是`第一个大于t`的迭代器的位置
    在前面加星号表示取这个位置的值
    所以`s.erase(*(s.upper_bound(t)));`表示删除当前这个刚好大于t的位置处的值
- 待插入的大于最大值：直接插入一个新的，作为新的队伍

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;
set<int> st;
int main() {
  int n;
  cin >> n;
  st.insert(0);  //方便一开始有 st.rbegin()
  FOR(i, 0, n) {
    int t;
    cin >> t;
    if (t < *st.rbegin()) st.erase(*(st.upper_bound(t))); // 只要小于最小值就行
    st.insert(t);
  }
  cout << st.size() - 1;
  return 0;
}
```

## L2-015 互评成绩 (25 分)|自定义排序

简单模拟，本质就是获取排序后的 1~k-1 个成绩之和以及自定义排序

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;

struct stu {
  vector<int> goal;
  int avgSum = 0;
};
bool cmp(stu a, stu b) { return a.avgSum > b.avgSum; }
vector<stu> vs;

int n, k, m;
int main() {
  cin >> n >> k >> m;
  vs.resize(n);
  FOR(i, 0, n) {
    vs[i].goal.resize(k);
    FOR(j, 0, k) { cin >> vs[i].goal[j]; }
    sort(vs[i].goal.begin(), vs[i].goal.end());
    FOR(j, 1, k - 1) { vs[i].avgSum += vs[i].goal[j]; }
  }
  sort(vs.begin(), vs.end(), cmp);
  printf("%.3lf", vs[m - 1].avgSum * 1.0 / (k - 2));
  for (int i = m - 2; i >= 0; i--) {
    printf(" %.3lf", vs[i].avgSum * 1.0 / (k - 2)); //最后再转换为 double，防止浮点数精度缺失带来的问题
  }
  return 0;
}
```

## **[L2-016 愿天下有情人都是失散多年的兄妹 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805061769609216)**|DFS|BFS|⭐

- 共同祖先 
  - 往上搜的时候，要么嵌套搜；要么分开两次搜，第一次搜a，并记录下来，第二次搜b 并对照搜a 时候获取的数据—— ==st 是否标记过了==
- 题目虽然说的是祖父母，但是不只是爷爷奶奶 还有 外公外婆，递归的时候要注意
- 还有就是  ==需要查询的 不一定是给出的本人id 还可能是 上面数据中的父母==——所以还需要记录父母性别。（这个还真有点ex）

DFS：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)
const int N = 1e5 + 10;  // n范围是1e4，但是 id是五位数

struct people {
  int sex, fa = -1, mo = -1;
} peo[N];

bool st[N], flag;
void dfsA(int cur, int generation) {
  if (generation > 5 || cur == -1) return;
  st[cur] = 1;  //标记
  dfsA(peo[cur].fa, generation + 1);
  dfsA(peo[cur].mo, generation + 1);
}
void dfsB(int cur, int generation) {
  if (generation > 5 || cur == -1) return;
  if (st[cur]) {  //查询标记
    flag = 1;
    return;
  }
  dfsB(peo[cur].fa, generation + 1);
  dfsB(peo[cur].mo, generation + 1);
}
int main() {
  ios::sync_with_stdio(false);
  int n;
  cin >> n;
  FOR(i, 0, n) {
    int id;
    char s;
    cin >> id >> s;
    peo[id].sex = s == 'M' ? 1 : 0;
    cin >> peo[id].fa >> peo[id].mo;
    //父母性别也要记录
    peo[peo[id].fa].sex = 1;
    peo[peo[id].mo].sex = 0;
  }
  cin >> n;
  int a, b;
  FOR(i, 0, n) {
    cin >> a >> b;
    if (peo[a].sex == peo[b].sex)
      puts("Never Mind");
    else {
      memset(st, 0, sizeof st);  //记得重置
      dfsA(a, 1);
      flag = 0;
      dfsB(b, 1);
      if (flag)
        puts("No");
      else
        puts("Yes");
    }
  }
  return 0;
}
```

BFS 也是可以的：

- 把每个人和他们的祖先们压入一个set里面，==判断set前后有没有大小改变==，如果没改变说明重复了，所以有相同祖先，所以就输出No 。（当然这里像上面简单的用数组标记也可以）
- 用level数组标记他们当前的层数在push一层的时候令他们的层数为上一层+1，一直到五层判断结束。
- 如果结束了还没有输出过No，那么就输出yes。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)
using namespace std;
const int N = 1e5 + 5;
struct man {
  int f = -1, m = -1, sex;
} peo[N];
int level[N];  

int main() {
  int n, m, id, father, mother, a, b;
  cin >> n;
  char c;
  for (int i = 0; i < n; i++) {
    cin >> id >> c >> father >> mother;
    peo[id].f = father, peo[id].m = mother;
    peo[id].sex = c == 'M' ? 0 : 1;
    peo[father].sex = 0;
    peo[mother].sex = 1;
  }
  cin >> m;
  for (int i = 0; i < m; i++) {
    fill(level, level + N, 0);  //重置
    cin >> a >> b;
    if (peo[a].sex == peo[b].sex) {
      printf("Never Mind\n");
      continue;
    }
    queue<int> q;
    q.push(a);
    q.push(b);
    level[a] = 1;
    level[b] = 1;
    set<int> s;  //通过比照这个标记来判断是否有共同祖先
    int flag = 0;
    while (!q.empty()) {
      int top = q.front();
      q.pop();
      int size = s.size();
      s.insert(top);
      if (size == s.size()) {  //有共同祖先
        printf("No\n");
        flag = 1;
        break;  //跳出
      }
      if (level[top] <= 4) {  //在五代之内的话才判断
        int fa = peo[top].f;
        int mo = peo[top].m;
        if (fa != -1) {
          q.push(fa);
          level[fa] = level[top] + 1;
        }
        if (mo != -1) {
          q.push(mo);
          level[mo] = level[top] + 1;
        }
      }
    }
    if (flag == 0) printf("Yes\n");  //一切正常，Yes
  }
  return 0;
}
```

## L2-017 人以群分 (25 分)|EASY

要求两类人群的规模尽可能接近，而他们的总活跃度差距尽可能拉开。

题目保证这些数字以及它们的和都不会超过2^31^。——也就是 int 范围

排序后特判一下n为奇数的情况就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 100005;

vector<int> peo;
int main() {
  int n;
  cin >> n;
  peo.resize(n);
  FOR(i, 0, n) { cin >> peo[i]; }
  sort(peo.begin(), peo.end(), less<int>());
  int front = 0, back = 0;
  // n=7,[0,2],[3,6]
  FOR(i, 0, n / 2) { front += peo[i]; }
  FOR(i, n / 2, n) { back += peo[i]; }
  int tmp = abs(front - back);
  if (n % 2 == 0) {  // n为偶数没什么好考虑的
    printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2, n / 2, tmp);
  } else {
    //分割线换一下试试
    front += peo[n / 2 + 1];
    back -= peo[n / 2 + 1];
    // dbg(abs(front - back));
    if (abs(front - back) > tmp) {
      printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2, n / 2 + 1,
             abs(front - back));
    } else {
      // dbg(tmp);
      printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2 + 1, n / 2,
             tmp);
    }
  }
  system("pause");
  return 0;
}
```

## L2-018 多项式A除以B (25 分)|==数学|不会写==

==我自己是写不出来的==

对于两个多项式A和B，题目给出的必定不会是连续降幂的，根据**多项式的除法原理**，我们需要缺幂项补零

题中给出的==x^4^-3x^2^-x-1==是缺3次幂的，将缺幂项补上之后，就变成了 ==x^4^+0x^3^-3x^2^+x-1==

用一个数组来保存一个多项式，即数组的`下标对应多项式的指数`，下标对应的单元表示多项式的系数，如数组`[-1, -1, -3, 0, 1]。`。

![Screenshot_20220306_210513_com.jideos.jnotes](https://gitee.com/okkjoo/image-bed/raw/master/imgs/Screenshot_20220306_210513_com.jideos.jnotes.png)

即每次除法`商`的最高次幂 `t1-t2`，系数为`A[t1] / B[t2]`，每次都放变化后的`A、B`最高次幂以及对应系数。下方式子的变化`A[i] -= B[i – (t1 – t2)] * A[t1] / B[t2]`, 其中`i`从A的最高次幂`t1`到大于等于`t1 – t2`, 这样就算完成了`一行的`除法。**重复上面的步骤, 直到A的最高项幂次小于B的最高项幂次, 此时的`A就是余项`。**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl

//返回 c[]式子里有几个非零项，start:最高次幂
int nonNegativeNum(double c[], int start) {
    int cnt = 0;
    for (int i = start; i >= 0; i--)
        if (abs(c[i]) + 0.05 >= 0.1) cnt++;
    return cnt;
}
void printPoly(double c[], int start) {
    printf("%d", nonNegativeNum(c, start));
    //最后结果为0的情况，(不会写这题的话，也可以按这个点骗点分)
    if (nonNegativeNum(c, start) == 0) printf(" 0 0.0");
    for (int i = start; i >= 0; i--)  //按指数递减输出
        if (abs(c[i]) + 0.05 >= 0.1) printf(" %d %.1f", i, c[i]);
}
double c1[3000], c2[3000], c3[3000];
int main() {
    int m = 0, n = 0,                 // m、n分别为两式非零项的个数
    t = 0, max1 = -1, max2 = -1;  // max1、max2分别为两个式子的最高次幂
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> t;  //指数
        max1 = max1 > t ? max1 : t;
        cin >> c1[t];  //指数作为下标，对应的系数; 没有的就是0
    }
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> t;
        max2 = max2 > t ? max2 : t;
        cin >> c2[t];
    }
    int t1 = max1, t2 = max2;
    while (t1 >= t2) {
        double c = c1[t1] / c2[t2];  //商最高次幂项对应系数
        c3[t1 - t2] = c;  //商：t1-t1 就是最高次幂，放入对应系数
        //  for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[j] * c;
        for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[i-(t1-t2)] * c;
        while (abs(c1[t1]) < 0.000001) t1--;  //系数可以约去之和，t1 后移
    }
    printPoly(c3, max1 - max2);  //输出商
    printf("\n");
    printPoly(c1, t1);  //输出余
    return 0;
}
```

## L2-019 悄悄关注 (25 分)|

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 5000;   //用户编号从1开始
map<string, int> mp;  //<name, 赞>
set<string> att;
set<string> ans;
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    string s;
    cin >> s;
    att.insert(s);
  }
  cin >> n;
  double avg = 0;
  FOR(i, 0, n) {
    string s;
    int d;
    cin >> s >> d;
    mp[s] = d;
    avg += d;
  }
  avg /= n;
  for (auto &t : mp) {
    if (att.count(t.first) == 0 && t.second > avg) {
      ans.insert(t.first);
    }
  }
  for (auto &t : ans) {
    cout << t << endl;
  }
  if (ans.size() == 0) cout << "Bing Mei You";
  system("pause");
  return 0;
}
```

## L2-020 功夫传人 (25 分)|DFS

超时了最后一个测试点

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e5 + 5;  //从0开始 祖师爷为0
int dedao[N];           //无道就是0，得道存储其倍数
int f[N];               //其师傅
double ans = 0;
int main() {
ios::sync_with_stdio(false);
  db n, z, r;
  cin >> n >> z >> r;
  r = 1 - (0.01 * r);
  FOR(i, 0, n) {
    int k;
    cin >> k;
    if (k == 0) {
      int x;
      cin >> x;
      dedao[i] = x;
      // dbg(dedao[i]);
    }
    FOR(j, 0, k) {
      int x;
      cin >> x;
      f[x] = i;  //记录师傅
    }
  }
  FOR(i, 0, n) {
    if (dedao[i]) {
      int x = i, c = 0;  // c:削弱了多少次
      while (x != 0) {   //还没到祖师爷
        x = f[x];
        c++;
      }
      ans += z * pow(r, c) * dedao[i];
    }
  }
  cout << (int)ans;
  system("pause");
  return 0;
}
```

想了想可以优化的地方，其实可以就==**一次递归**，然后遇到得道者记录下来即可==

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long  
#define db double
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e5 + 5;  //从0开始 祖师爷为0
vector<db> peo[N];
int dedao[N];  //无道就是0，得道存储其倍数
// int f[N];      //其师傅
double ans = 0;
db n, z, r;
void dfs(int idx, db power) {
  if (dedao[idx]) {
    ans += dedao[idx] * power;
  }
  int sz = peo[idx].size();
  FOR(i, 0, sz) { dfs(peo[idx][i], power * (1 - r / 100)); }
}
int main() {
  cin >> n >> z >> r;
  FOR(i, 0, n) {
    int k;
    cin >> k;
    if (k == 0) {
      int x;
      cin >> x;
      dedao[i] = x;
      // dbg(dedao[i]);
    }
    FOR(j, 0, k) {
      int x;
      cin >> x;
      peo[i].push_back(x);
      // f[x] = i;  //记录师傅
    }
  }
  // FOR(i, 0, n) {
  //   if (dedao[i]) {
  //     int x = i, c = 0;  // c:削弱了多少次
  //     while (x != 0) {   //还没到祖师爷
  //       x = f[x];
  //       c++;
  //     }
  //     ans += z * pow(r, c) * dedao[i];
  //   }
  // }
  dfs(0, z);
  cout << (int)ans;
  system("pause");
  return 0;
}
```

## L2-021 点赞狂魔 (25 分)|自定义排序

- 统计每个人点赞的不同标签的数量，找出数量最大的前3名
- 如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列
- 若不足3人，则用`-`补齐缺失，例如`mike jenny -`就表示只有2人

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
// multimap<int, string> mp;  //<不同标签数量，名字> ; multimap:key可重复的map
struct node {
  string name;
  set<int> tag;
  double avg = 0;  //标签出现次数平均值
};
bool cmp(node a, node b) {
  if (a.tag.size() == b.tag.size()) {
    return a.avg < b.avg;
  }
  return a.tag.size() > b.tag.size();
}
vector<node> peo(N);
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    string s;
    int k;
    cin >> s;
    peo[i].name = s;
    cin >> k;
    double cnt = 0; //注意用 double 或者在下面赋值 avg 的时候*1.0
    FOR(j, 0, k) {
      int x;
      cin >> x;
      peo[i].tag.insert(x);
      cnt++;
    }
    peo[i].avg = cnt / peo[i].tag.size();
  }
  sort(peo.begin(), peo.end(), cmp);
  if (peo[0].avg == 0) {
    cout << "-";
  } else {
    cout << peo[0].name;
  }
  FOR(i, 1, 3) {
    // dbg(peo[i].avg);
    if (peo[i].avg == 0)
      cout << " -";
    else
      cout << " " << peo[i].name;
  }
  system("pause");
  return 0;
}
```

## L2-022 重排链表 (25 分)|复杂模拟|==有点东西==

需要三个存储结构

- 存储一开始的数据   `a`
- 整理初始数据为链表 `v`
- 最后答案的链表 `ans`
  - 使用两个指针来对 `v`重新排列后放入 `ans`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;

struct node {
  int add, data, nxt;
};
node a[N];  //下标也是地址，方便理顺链表
vector<node> v, ans;

int main() {
  int begin, n;
  cin >> begin >> n;
  FOR(i, 0, n) {
    int _add, _data, _nxt;
    cin >> _add >> _data >> _nxt;
    a[_add] = {_add, _data, _nxt};
  }
  while (begin != -1) {
    v.push_back({a[begin].add, a[begin].data, a[begin].nxt});
    begin = a[begin].nxt;
  }
  int l = 0, r = n - 1; //用 n 会有测试点3过不去的情况，用 v.size() 就不会错
  while (l < r) {//这里是有问题的，测试点1过不去
    ans.push_back({v[r].add, v[r].data, v[r].nxt});
    ans.push_back({v[l].add, v[l].data, v[l].nxt});
    l++, r--;
  }
  // dbg(ans.size());
  FOR(i, 0, ans.size()) {
    if (i != ans.size() - 1)
        //输出 ans[i + 1].add 来实现 应该有的 next， 存的 ans[i].nxt 并不是真正的 next
      printf("%05d %d %05d\n", ans[i].add, ans[i].data, ans[i + 1].add);
    else
      printf("%05d %d -1", ans[i].add, ans[i].data);
  }
  system("pause");
  return 0;
}
```

关于测试点：https://blog.csdn.net/weixin_45962741/article/details/115614608

- 测试点1：奇数个结点，自然不能两个指针同时移动后再判断是否需要跳出
- 测试点3：多余结点可还行，此时 n 就不等于 v.size() 

AC：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;

struct node {
  int add, data, nxt;
};
node a[N];  //下标也是地址，方便理顺链表
vector<node> v, ans;

int main() {
  int begin, n;
  cin >> begin >> n;
  FOR(i, 0, n) {
    int _add, _data, _nxt;
    cin >> _add >> _data >> _nxt;
    a[_add] = {_add, _data, _nxt};
  }
  while (begin != -1) {
    // v.push_back({a[begin].add, a[begin].data, a[begin].nxt});
    //其实就是
    v.push_back(a[begin]);
    begin = a[begin].nxt;
  }
  // dbg(n);
  // dbg(v.size());
  int l = 0, r = v.size() - 1;//****
  while (1) {//****
    ans.push_back(v[r]);
    r--;
    if (l > r) break;
    ans.push_back(v[l]);
    l++;
    if (l > r) break;
  }
  // dbg(ans.size());
  FOR(i, 0, ans.size()) {
    if (i != ans.size() - 1) 
      //输出 ans[i + 1].add 来得到 应该有的 next， 存的 ans[i].nxt 并不是真正的next
      printf("%05d %d %05d\n", ans[i].add, ans[i].data, ans[i + 1].add);
    else
      printf("%05d %d -1", ans[i].add, ans[i].data);
  }
  system("pause");
  return 0;
}
```

## L2-023 图着色问题 (25 分)|图的遍历

- 不会有两个相邻顶点具有同一种颜色
- ==**将所有的配色都用上**==
- 本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。

- DFS

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 505;  //编号都是从1开始
int v, e, k, n;
vector<int> m[N];  //邻接表
int c[N];          //每个点的颜色
bool flag;         //标记是否可行
void judge(int idx) {
  if (flag) return;  //已经有不合理的了
  int sz = m[idx].size();
  FOR(i, 0, sz) {
    int j = m[idx][i];
    if (c[idx] == c[j]) {
      flag = 1;
      return;
    }
  }
}

int main() {
  cin >> v >> e >> k;
  FOR(i, 0, e) {
    int a, b;
    cin >> a >> b;
    m[a].push_back(b);
    m[b].push_back(a);
  }
  cin >> n;
  FOR(i, 0, n) {
    flag = 0;
    set<int> cKind;
    FOR(j, 1, v + 1) {
      cin >> c[j];
      cKind.insert(c[j]);
    }
    if (cKind.size() != k) flag = 1;
    FOR(j, 1, v + 1) { judge(j); }
    if (flag)
      cout << "No\n";
    else
      cout << "Yes\n";
  }
  system("pause");
  return 0;
}
```

## L2-024 部落 (25 分)|并查集

- 朋友的朋友都算在一个部落 —— 太并查集了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e4 + 5;  //编号从1开始
set<int> total;
int f[N];
int find(int a) { return f[a] == a ? a : f[a] = find(f[a]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
int main() {
  FOR(i, 0, N) f[i] = i;
  int n;
  cin >> n;
  FOR(i, 0, n) {
    int k, x, y;
    cin >> k >> x;
    total.insert(x);
    FOR(j, 1, k) {
      cin >> y;
      total.insert(y);
      merge(y, x);
    }
  }
  int sz = total.size(), cnt = 0;
  //因为题目说了编号是连续的，所以直接遍历到 sz
  //不然还需要判断哪些人根本就不在社区
  FOR(i, 1, sz + 1) {
    if (f[i] == i) cnt++;
  }
  cout << sz << " " << cnt << endl;
  int q;
  cin >> q;
  FOR(i, 0, q) {
    int a, b;
    cin >> a >> b;
    if (find(a) == find(b))
      cout << "Y\n";
    else
      cout << "N\n";
  }
  system("pause");
  return 0;
}
```



## L2-025 分而治之 (25 分)|图的遍历|并查集|连通度

- 希望首先攻下敌方的部分城市，使其剩余的城市变成==孤立无援==——与其他的不连通

连通，很明显并查集可以完成：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1E4 + 5;  //从1开始
vector<PII> es;         //存储通路
bool oc[N];             //计划攻下的城市
int f[N];
int find(int a) { return f[a] == a ? a : f[a] = find(f[a]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
int main() {
  int n, m, k, p, x;
  cin >> n >> m;
  FOR(i, 0, m) {
    int a, b;
    cin >> a >> b;
    es.push_back({a, b});
  }
  cin >> k;
  while (k--) {
    fill(oc, oc + N, 0);
    FOR(i, 0, N) f[i] = i;
    cin >> p;
    FOR(i, 0, p) {
      cin >> x;
      oc[x] = 1;
    }
    FOR(i, 0, es.size()) {
      int a = es[i].first, b = es[i].second;
      if (oc[a] || oc[b]) continue;
      merge(a, b);
    }
    int cnt = 0;
    FOR(i, 1, n + 1) if (f[i] == i) cnt++;
    if (cnt == n)
      cout << "YES\n";
    else
      cout << "NO\n";
  }
  system("pause");
  return 0;
}
```

可以AC，但是不用并查集也可以，直接记录各个城市的兄弟城市数量，会快很多。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i,n,m) for(int i =n;i<m;++i)
const int N = 10010;
int n, m, k, initmp[N]={0}, //一开始各个城市的兄弟城市数量
            latemp[N];//实行计划后各个城市的兄弟城市数量
vector<vector<int>> v;//存图
void check(){
    FOR(i,1,n+1){
        if(latemp[i]>0){
            cout<<"NO\n";
            return;
        }
    }
    cout<<"YES\n";
    return;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    v.resize(n+1);//因为是从1开始编号
    FOR(i,0,m){
        int t1,t2;cin>>t1>>t2;
        v[t1].push_back(t2);
        v[t2].push_back(t1);
        initmp[t1]++;
        initmp[t2]++;
    }
    cin>>k;
    //开始实行各个方案
    FOR(i,0,k){
        //先初始化一下
        FOR(j,1,n+1){
            latemp[j]=initmp[j];
        }
        int np;cin>>np;
        FOR(j,0,np){
            int x;cin>>x;//要攻占的城市
            latemp[x] = 0;
            int sz =v[x].size();
            FOR(k,0,sz){
                latemp[v[x][k]]--;//给攻占的兄弟城市的兄弟肯定就少掉他了
            }
        }
        check();
    }
    return 0;
}
```

## L2-026 小字辈 (25 分)|BFS|DFS

>  给一个庞大家族的家谱，要请你给出最小一辈的名单。

BFS:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;  //从1开始
vector<int> peo[N];     // peo[x]:x的子女
vector<int> grades;     //每个人的辈分
bool vis[N];            //是否已经入过栈
int main() {
  int n, x;
  cin >> n;
  grades.resize(n + 1);
  FOR(i, 1, n + 1) {
    cin >> x;
    if (x == -1) x = 0;  //老祖宗的父母，辈分为0
    peo[x].push_back(i);
  }
  grades[0] = 0;
  queue<int> q;
  q.push(0);
  int mn = 1;
  while (!q.empty()) {
    int now = q.front();
    q.pop();
    int sz = peo[now].size();
    FOR(i, 0, sz) {  //搜now的子代
      if (vis[peo[now][i]]) continue;
      vis[peo[now][i]] = 1;
      q.push(peo[now][i]);
      grades[peo[now][i]] = grades[now] + 1;
      if (grades[peo[now][i]] > mn) mn = grades[peo[now][i]];
      // if (mn == 4) dbg(peo[now][i]);
    }
  }
  set<int> ans;
  FOR(i, 0, n + 1) {
    if (grades[i] == mn) ans.insert(i);
  }
  cout << mn << endl;
  for (auto it = ans.begin(); it != ans.end(); it++) {
    if (it != ans.begin()) cout << " ";
    cout << *it;
  }
  system("pause");
  return 0;
}
```



DFS:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n;                  //从1开始
vector<vector<int>> v;  //改变存储方式 提高深搜效率
int maxg = 1;
set<int> s;  //存储最小辈分

void dfs(int id, int grade) {
  if (grade > maxg) {
    maxg = grade;
    s.clear();
    s.insert(id);
  } else if (grade == maxg)
    s.insert(id);
  int sz = v[id].size();  //只搜他的孩子，而我原来是这里再遍历一遍
  FOR(i, 0, sz) { dfs(v[id][i], grade + 1); }
}
int main() {
  ios::sync_with_stdio(false);
  cin >> n;
  v.resize(n + 1);
  int id0;
  FOR(i, 1, n + 1) {
    int _p;
    cin >> _p;
    if (_p == -1) {
      id0 = i;
      continue;
    }
    v[_p].push_back(i);  // v[_p] 装着_p 的孩子
  }
  dfs(id0, 1);

  cout << maxg << endl;
  for (auto it = s.begin(); it != s.end(); it++) {
    if (it != s.begin()) cout << " ";
    cout << *it;
  }
  return 0;
}

```

## **L2-027 名人堂与代金券 (25 分)**|同分排名

- 按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩
- 成绩相同的学生享有并列的排名
- 排名并列时，按账号的字母序升序输出。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e4 + 5;
struct P {
  string name;
  int goal = 105;  //初始化，方便后面输出判断
};
bool cmp(P a, P b) {
  if (a.goal == b.goal) {
    return a.name < b.name;  //字母序递增
  }
  return a.goal > b.goal;  //分数递减
}
vector<P> peo;
int main() {
  int n, g, k;
  int ans = 0;
  cin >> n >> g >> k;
  FOR(i, 0, n) {
    string s;
    int go, gra;
    cin >> s >> go;
    if (go >= g)
      ans += 50;
    else if (go >= 60)
      ans += 20;
    peo.push_back({s, go});
  }
  cout << ans << endl;
  sort(peo.begin(), peo.end(), cmp);
  int grade = 1, tmp = 1;  // tmp:同分人数
  FOR(i, 0, n) {
    cout << grade << " " << peo[i].name << " " << peo[i].goal << endl;
    if (peo[i].goal > peo[i + 1].goal) {
      grade += tmp;
      tmp = 1;
    } else
      tmp++;
    if (grade > k) break;
  }

  system("pause");
  return 0;
}
```

## **L2-028 秀恩爱分得快 (25 分)**|==特殊处理==

- 对 `0、-0` 的特殊处理。当遇到 0 时候把此人转为1000存储, 所以读数据的时候要以字符串形式读取
- 遍历每张照片，把与男主女主对应的异性==（与男女主无关的就不理）==亲密度用`sum`数字累加起来， 并维护`maxn[1]`、 `maxn[2]`， 为男主女主的最亲密值 和 `ans[1], ans[2]`容器，为最亲密异性id
- 把0当1000存储，会导致0号人排在最后，不符题意，输出之前排个序，让1000排在最前面

```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>
using namespace std;
bool cmp(int a, int b) {
  if (abs(a) == 1000) return true;
  if (abs(b) == 1000) return false;
  return abs(a) < abs(b);
}
int main() {
  int n, m,                              // m:照片数
      num, k, sex[1010] = {0}, love[3];  // love存储那对情侣编号
  double sum[1010] = {0},                //男女主对应的异性亲密度
      maxn[3] = {0};                     //男女主最亲密值
  string s;
  cin >> n >> m;
  vector<vector<int>> v(m),  //照片
      ans(3);                //最亲密异性id
  for (int i = 0; i < m; i++) {
    cin >> k;
    for (int j = 0; j < k; j++) {
      cin >> s;
      if (s == "0") s = "1000";
      if (s == "-0") s = "-1000";
      num = stoi(s);
      sex[abs(num)] = num;  //记录编号为abs(num)这个人的性别（主要存的是这个数本身的正负）
      v[i].push_back(num);
    }
  }
  for (int i = 1; i <= 2; i++) {
    cin >> s;
    if (s == "0") s = "1000";
    if (s == "-0") s = "-1000";
    love[i] = stoi(s);
  }
  for (int k = 1; k <= 2; k++) {
    for (int i = 0; i < m; i++) {  //遍历每张照片
      int flag = 0;                //照片中是否有男女主
      for (int j = 0; j < v[i].size(); j++) {
        if (v[i][j] == love[k]) {
          flag = 1;
          break;
        }
      }
      if (flag == 1) {  //里面有男女主才计算
        for (int j = 0; j < v[i].size(); j++) {
          if (love[k] * v[i][j] < 0) {  //为异性
            sum[(int)abs(v[i][j])] += 1.0 / v[i].size();
          }
        }
      }
    }
  }
  maxn[1] = maxn[2] = -1;
  for (int k = 1; k <= 2; k++) {
    for (int i = 1; i <= 1000; i++) {
      if (love[k] * sex[i] < 0) {  //为异性
        if (sum[i] > maxn[k]) {    //大于最大值就更新
          maxn[k] = sum[i];
          ans[k].clear();  //重置 ans
          ans[k].push_back(sex[i]);
        } else if (sum[i] == maxn[k]) {  //等于最大值就加入ans
          ans[k].push_back(sex[i]);
        }
      }
    }
  }
  //互为彼此亲密度最高
  if (maxn[1] == sum[(int)abs(love[2])] && maxn[2] == sum[(int)abs(love[1])]) {
    string s1 = to_string(love[1]), s2 = to_string(love[2]);
    if (love[1] == 1000) s1 = "0";
    if (love[1] == -1000) s1 = "-0";
    if (love[2] == 1000) s2 = "0";
    if (love[2] == -1000) s2 = "-0";
    cout << s1 << " " << s2 << endl;
    return 0;
  }
  for (int k = 1; k <= 2; k++) {
    sort(ans[k].begin(), ans[k].end(), cmp);
    for (int i = 0; i < ans[k].size(); i++) {
      string s1 = to_string(love[k]), s2 = to_string(ans[k][i]);
      if (love[k] == 1000) s1 = "0";
      if (love[k] == -1000) s1 = "-0";
      if (ans[k][i] == 1000) s2 = "0";
      if (ans[k][i] == -1000) s2 = "-0";
      cout << s1 << " " << s2 << endl;
    }
  }
  return 0;
}
```

## L2-029 特立独行的幸福 (25 分)

>  其它数字虽然其实也依附于其它幸福数，但因为那些数字不在给定区间 [10, 40] 内，所以它们在给定区间内是特立独行的幸福数。

这个有点坑

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e4 + 5;
int num[N],      // num[x]:有num[x]个数依附于x
    noFirst[N];  // 1:依附于其他的数
bool isPrime(int x) {
  if (x == 1) return false;
  FOR(i, 2, sqrt(x)) {
    if (x % i == 0) return false;
  }
  return true;
}

bool isHappy(int x) {
  set<int> mark;
  int X = x, tmp;
  while (X != 1) {
    mark.insert(X); 
    tmp = 0;
    while (X) {
      tmp += pow(X % 10, 2);
      X /= 10;
    }
    num[x]++;          //依赖x的数++
    noFirst[tmp] = 1;  // tmp 是依赖别人的
    X = tmp;
    if (mark.count(X)) return false;
  }
  return true;
}
int main() {
  int a, b;
  cin >> a >> b;
  vector<int> ans;
  FOR(i, a, b + 1) {  //因为只在[A, B] 所以每个都要单独判断
    if (isHappy(i)) ans.push_back(i);  //幸福数就放进去
  }
  int flag = 0;
  FOR(i, 0, ans.size()) {
    if (isPrime(ans[i])) num[ans[i]] <<= 1;  //*2
    if (!noFirst[ans[i]]) {
      cout << ans[i] << " " << num[ans[i]] << endl;
      flag = 1;
    }
  }
  if (!flag) cout << "SAD";
  system("pause");
  return 0;
}
```





## [L2-030 冰岛人](https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858887)|模拟|map、pair

孩子的姓等于父亲的名加后缀;输入格式：` 名 姓`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

#define pis pair<int, string>

int N, M;
string fName, sName, tmp;
map<string, pis> record;  //<名字,<性别1男 0女, 姓氏> >
string check(string a, string b) {
  int cnt1 = 0, cnt2;
  while (a != "") {
    cnt2 = 0;
    string b2 = b;
    while (b2 != "") {
      //共同祖先在五代之内
      // 只有嵌套才能找到共同祖先的情况
      if (a == b2 && (cnt1 < 4 || cnt2 < 4)) return "No\n";  //找到共同祖先
      if (cnt1 >= 4 && cnt2 >= 4) return "Yes\n";
      b2 = record[b2].second;  //搜他的姓氏，即他的父亲
      cnt2++;
    }
    a = record[a].second;  //搜他的姓氏，即他的父亲
    cnt1++;
  }
  //搜到最后祖宗还是没满足退出条件 就说明可行
  return "Yes\n";
}
int main() {
  cin >> N;
  while (N--) {
    cin >> fName >> sName;  //名 姓
    if (sName.back() == 'n')
      record[fName] = {1, sName.substr(0, sName.size() - 4)};
    else if (sName.back() == 'r')
      record[fName] = {0, sName.substr(0, sName.size() - 7)};
    else if (sName.back() == 'm')
      record[fName].first = 1;
    else
      record[fName].first = 0;
  }
  cin >> M;
  while (M--) {
    cin >> fName >> tmp >> sName >> tmp;  //姓没用，名有；只读名
    if (!record.count(fName) || !record.count(sName))
      cout << "NA\n";
    else if (record[fName].first == record[sName].first)
      cout << "Whatever\n";
    else
      cout << check(fName, sName);
  }
  return 0;
}
```

## L2-031 深入虎穴 (25 分)|BFS特性

- 找出距离入口最远的那扇门。
- 但是他也没说哪个门是入口
  - 无根变有根,判断哪个是入口，然后DFS，找到这棵树的最大深度。
    - 读入地图的时候，没有通往的点就是起点（读入时“入度”为0的）
  - 直接 BFS，根据==结果唯一==以及BFS的特性：在产生新的子结点时，`深度越小的结点越先得到扩展`，即先产生它的子结点
    - ——留到队列中的最后一个就是离得最远的，也就是答案

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 10;
vector<int> v[N];
int vis[N];
//找出距离入口最远的那扇门
int main() {
  int n, k, u;
  cin >> n;
  FOR(i, 1, n + 1) {
    cin >> k;
    FOR(j, 0, k) {
      cin >> u;
      v[i].push_back(u);
      v[u].push_back(i);
    }
  }
  queue<int> q;
  q.push(1);
  vis[1] = 1;
  int one;
  while (!q.empty()) {
    one = q.front();
    q.pop();
    FOR(i, 0, v[one].size()) {
      if (vis[v[one][i]]) continue;
      q.push(v[one][i]);
      vis[v[one][i]] = 1;
    }
  }
  cout << one;
  system("pause");
  return 0;
}
```

## L2-032 彩虹瓶 (25 分)|简单栈模拟

一开始给测试点1卡了，https://blog.csdn.net/weixin_45724778/article/details/113407312。

因为一开始我这样判断：

```cpp
else {
//       if (shelf.size() < m) {
//         shelf.push(x);
//       }
        shelf.push(x);if(shelf.size() > m){cout<<"NO\n";return ;}
    }
```

这里`return`了对于该组数据的判断肯定是没问题的，但是因为我是边读入数据边操作，这里`return`了。==后面的数据就读不进去了==

AC：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
int n, m, k;
int idx = 1;  //现在需要的
void check() {
  stack<int> shelf;
  idx = 1;
  FOR(i, 1, n + 1) {
    int x;
    cin >> x;
    if (x == idx) {
      idx++;
      while (!shelf.empty() && shelf.top() == idx) {
        idx++;
        shelf.pop();
      }
    } else {
      if (shelf.size() < m) {
        shelf.push(x);
      }
    }
  }
  if (shelf.empty()) {
    cout << "YES\n";
    return;
  }
  cout << "NO\n";
  return;
}

int main() {
  cin >> n >> m >> k;
  while (k--) {
    check();
  }
  system("pause");
  return 0;
}
```

## L2-033 简单计算器 (25 分)|简单栈模拟

所有的计算都只取结果的整数部分

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i,n,m) for(int i =n;i<m;++i)

int n,In[1005];
char ope,record[1005];
int ans ;//所有的计算都只取结果的整数部分。
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    //数组模拟堆栈 所以从n-1开始输入
    for(int i = n-1;i>=0;i--)cin>>In[i];//n个数字
    for(int i = n-1;i>0;i--)cin>>record[i];//n个运算符
    ans = In[0];
    FOR(i,1,n){
        ope = record[i];
        if(ope == '+')ans = In[i] + ans;
        else if(ope == '-') ans = In[i] -ans;
        else if(ope == '*')ans = In[i]*ans;
        else {
            if(ans == 0){
                cout<<"ERROR: "<<In[i]<<"/0";
                return 0;                
            }else{
                ans = In[i]/ans;
            }
        }
    }
    cout<<(int)ans;
    return 0;
}
```

## L2-034 口罩发放 (25 分)|==复杂==模拟：考察STL容器

- 市民两次获得口罩的时间至少需要间隔 *P* 天。
- 给定的记录的提交时间不一定有序——还要自己排序
- 要求：
  - `身份证号` 必须是 18 位的**数字**
  - 若第 `i` 天申请成功，则等到第 `i+P+1` 天才能再次申请；
  - 按照提交时间的先后顺序发放，直至全部记录处理完毕或名额用完。
  - 如果提交时间相同，则按照在列表中出现的先后顺序决定
  - 对于每一天的申请记录，每行输出一位得到口罩的人的姓名及身份证号
  - 输出完发放记录后，你还需要输出有合法记录的、身体状况为 1 的申请人的姓名及身份证号
    - 顺序按照申请记录中出现的顺序确定，同一个人只需要输出一次。

tips：

- `hh:mm` ==直接用字符串存储，比较时间的效果一样==
- 抽离判断身份证是否合法函数
- 比较时间时，先比较报告时间 `time`，在比较列表中出现的先后顺序`order`

因为给口罩的时候也要实际申请时间，所以要将数据读完排序后再进行判断是否发放口罩

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
  string name, id,
      time;  // time也可以直接用字符串来存储，后面比较字符串大小与比较时间效果一样
  int illness, order;
};
bool isNotOK(const string& s) {  //判断是否合法
  if (s.size() != 18) return true;
  for (char c : s)
    if (c < '0' || c > '9') return true;
  return false;
}
bool cmp(const node& a, const node& b) {  //根据时间和列表中的顺序来排序
  if (a.time != b.time) return a.time < b.time;
  return a.order < b.order;
}
vector<node> record,  //所有申请
    ill;  //身体状况不好的，需要输出名字和id，所以干脆也放
int D, P, t, s, provideNum;
map<string, int> lastGet;  //身份证为string的最后一次拿口罩的日期为int
set<string> gotten;  //身体状况不好的中 也有可能会重复出现 需要标记名字
int main() {
  ios::sync_with_stdio(false);
  cin >> D >> P;
  for (int i = 1; i <= D; i++) {
    cin >> t >> s;
    record.resize(t);  //共t个申请人
    provideNum = 0;    //当天以及给出去的口罩数量
    for (int j = 0; j < t; j++) {
      cin >> record[j].name >> record[j].id >> record[j].illness >>
          record[j].time;
      record[j].order = j;  //列表中出现的次序
      if (isNotOK(record[j].id))
        record[j].name = "";  //检查身份证 身份证不对劲直接清除名字
      else {
        if (!lastGet.count(record[j].id))
          lastGet[record[j].id] =
              -30;  //之前没领过，就让他的最后一次领口罩的时间变为-30，保证后面发放时候可领取
        if (record[j].illness == 1 &&
            !gotten.count(record[j].id)) {  //身体状况不好的 并且之前没有标记过
          ill.push_back(record[j]);
          gotten.insert(record[j].id);
        }
      }
    }
    sort(record.begin(), record.end(), cmp);  //按时间和order排序一下
    for (int j = 0; j < t && provideNum < s; j++) {  //还有人以及多余的口罩
      if (record[j].name != "" &&
          i - lastGet[record[j].id] > P) {  //身份合法并且天数上不冲突
        lastGet[record[j].id] = i;          //更新最后一次口罩的时间
        provideNum++;                       //给出的口罩数加一
        cout << record[j].name << " " << record[j].id << endl;
      }
    }
  }
  //就是按照申请顺序记录的，所以也不需要再次排序
  for (node i : ill) cout << i.name << " " << i.id << endl;
  return 0;
}
```



## **L2-035 完全二叉树的层序遍历 (25 分)**|后序遍历->层序

详细注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post;
map<int, int> level;
int n, idx;
//后序遍历
void dfs(int levIt) {  //传入的其实是 层序数组 的指针
  if (levIt > n) return;  //层序遍历和后序遍历得到的数组大小肯定都是n
  dfs(2 * levIt);              //左, 递
  dfs(2 * levIt + 1);          //右, 递
  level[levIt] = post[idx++];  //中, 归到这里时 idx 已经到了后面
}
int main() {
  cin >> n;
  post.resize(n);
  FOR(i, 0, n) cin >> post[i];
  dfs(1);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
}
```

## L2-036 网红点打卡攻略 (25 分)|存图+模拟+判断+标记

- 检验攻略：是否能在每个网红点打卡仅一次、并且路上花费最少的攻略。
- 家的编号固定为 0
- 攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里

```cpp
#include <bits/stdc++.h>
using namespace std;
int N, M, K, u, v, w, n, flag, cost, cnt, Ansid,
    mnCost = INT_MAX, Edge[201][201], path[202], mark[201];
int main() {
  cin >> N >> M;
  for (int i = 0; i < M; i++) {
    cin >> u >> v >> w;
    Edge[u][v] = Edge[v][u] = w;
  }
  cin >> K;
  for (int i = 1; i <= K; i++) {
    fill(mark, mark + N + 1, 0);
    path[0] = path[N + 1] = flag = cost = 0;
    cin >> n;
    for (int j = 1; j <= n; j++) {
      cin >> path[j];
      if (mark[path[j]]) mark[0] = 1;
      mark[path[j]] = 1;
    }
    if (mark[0] || n != N) continue;
    for (int j = 1; j <= n + 1; j++) {
      if (Edge[path[j - 1]][path[j]] == 0) {
        flag = 1;
        break;
      }
      cost += Edge[path[j - 1]][path[j]];
    }
    if (!flag) {
      cnt++;
      if (cost < mnCost) Ansid = i, mnCost = cost;
    }
  }
  cout << cnt << '\n' << Ansid << ' ' << mnCost;
  return 0;
}
```

## L2-037 包装机 (25 分)|简单模拟

特殊情况是，因为筐的容量是有限的，当筐已经满了，但仍然有某条轨道的按钮被按下时，系统应强制启动 0 号键，先从筐里抓出一件物品，再将对应轨道的物品推落

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl

int n, m, s;
const int N = 110, M = 1010;
queue<char> q[N];
stack<char> stk;
int main() {
  cin >> n >> m >> s;
  string str;
  FOR(i, 1, n + 1) {  //****1~n
    cin >> str;
    for (int j = 0; j < m; j++) {
      q[i].push(str[j]);
    }
  }
  int x;
  while (cin >> x, x != -1) {
    if (!x) {            // x==0
      if (stk.size()) {  //筐中有东西才操作
        cout << stk.top();
        stk.pop();
      }
    } else {
      if (q[x].size()) {        //对应管道有东西才操作
        if (stk.size() == s) {  //筐满了就先拿出一个
          cout << stk.top();
          stk.pop();
        }
        stk.push(q[x].front());
        q[x].pop();
      }
    }
  }
  return 0;
}
```

## L2-038 病毒溯源 (25 分)|DFS

- 如果最长链不唯一，则输出最小序列

- ==如何判断源头？==（入度为 0 的 就是源头病毒）

  - 添加单向边`(u, v)`时，记录 `st[v]=1`，后面这样判断根节点

    ```cpp
    int root = 0;
    while (st[root]) root++;  // st[root]=0 时，root就是根
    ```

- 然后 dfs 找出最长路线，顺便存储 `son`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;
vector<int> e[N];
int son[N];
bool st[N];
bool vis[N];
int dfs(int u) {
  int res = 0;
  son[u] = -1;
  FOR(i, 0, e[u].size()) {
    int j = e[u][i];
    int d = dfs(j);
    if (res < d)
      res = d, son[u] = j;
    else if (res == d)
      son[u] = min(son[u], j);
  }
  return res + 1;
}
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    int k;
    cin >> k;
    while (k--) {
      int x;
      cin >> x;
      e[i].push_back(x);
      st[x] = 1;
    }
  }
  int root = 0;
  while (st[root]) root++;
  cout << dfs(root) << endl;
  cout << root;
  while (son[root] != -1) {
    root = son[root];
    cout << " " << root;
  }
  system("pause");
  return 0;
}
```

也可以 BFS

```cpp
queue<PII> Q;
Q.push({S, 1});
while (!Q.empty()) {
    int now = Q.front().first, D = Q.front().second;
    Q.pop();
    if (D > Long) {
        Long = D;
        ans = now;
    }
    //到最后面的 now  就已经没有子节点了，也就到了Q会empty退出的时候
    for (auto nex : Edge[now]) Q.push({nex, D + 1}); //注意这里的 D+1
}
cout << Long << '\n';

while (ans != S) {
    F.push_back(ans);
    ans = pa[ans];  // pa 在读入的时候记录
}
F.push_back(S);
for (int i = F.size() - 1; ~i; --i) {
    cout << F[i];
    if (i != 0) cout << ' ';
}

```

## L2-039 清点代码库 (25 分)

- 假设两个功能模块如果接受同样的输入，总是给出同样的输出（M个int——`巧用string`），则它们就是功能重复
- 输出：
  - 每行给出具有这个功能的模块的个数，以及这个功能的对应输出
  - 输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出

测试点4、5过不了：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e4 + 5;
map<string, int> mp;  //<模块输出, 模块个数>
struct P {
  string s;
  int cnt;
};
bool cmp(P a, P b) {
  if (a.cnt == b.cnt) return a.s < b.s;
  return a.cnt > b.cnt;
}
vector<P> v;
int main() {
  int n, m;
  cin >> n >> m;
  getchar();
  FOR(i, 0, n) {
    string s;
    getline(cin, s);
    mp[s]++;
  }
  cout << mp.size() << endl;
  for (auto it : mp) {
    v.push_back({it.first, it.second});
  }
  sort(v.begin(), v.end(), cmp);
  for (auto it : v) {
    cout << it.cnt << " " << it.s << endl;
  }
  system("pause");
  return 0;
}
```

聪明反被聪明误—— 字符串妙用？字符串白给！

```cpp
string s = "100 100 100";
string s1 = "19 19 19";
if (s1 > s) cout << "1";  //会输出1
```

原因是空格的`ASCII` 码小于数字那些东西

还是老老实实用数组存吧

AC:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
int n, m, t;
vector<int> temp;
map<vector<int>, int> A;
multimap<int, vector<int>, greater<int> > B;
int main() {
  cin >> n >> m;
  temp.resize(m);
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) cin >> temp[j];
    A[temp]++;
  }
  for (auto it : A) B.insert({it.second, it.first});
  cout << A.size() << endl;
  for (auto it : B) {
    cout << it.first;
    for (auto it2 : it.second) cout << " " << it2;
    cout << endl;
  }
  return 0;
}
```

## L2-040 哲哲打游戏 (25 分)|简单模拟

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;
vector<int> e[N];
int files[105];
int main() {
  int n, m;
  cin >> n >> m;
  FOR(i, 1, n + 1) {
    int k;
    cin >> k;
    while (k--) {
      int x;
      cin >> x;
      e[i].push_back(x);
    }
  }
  int idx = 1;  //当前剧情点
  FOR(i, 0, m) {
    int x, jj;
    cin >> x >> jj;
    if (x == 0) {
      idx = e[idx][jj - 1];
    } else if (x == 1) {
      files[jj - 1] = idx;
      cout << idx << endl;
    } else if (x == 2) {
      idx = files[jj - 1];
    }
  }
  cout << idx;
  system("pause");
  return 0;
}
```

# L3

## L3-001 凑零钱 (30 分)|==DP|路径打印==

- 是否可能精确凑出要付的款额

- 路径打印

  ```cpp
   while (m) {
        if (dp[n - 1][m - v[n]] == 1) {
          m -= v[n];
          ans.push_back(v[n]);
        }
        n--;  //不论第n块用不用，都要往前
      }
  ```

- 最小序列

  - 一开始排序的时候排成递减，取路径的时候从后往前取

一开始测试点5一直过不了，应该是排序时有第0项 `v[0]=0`的干扰，全部一起排序的话，就变成 `v[v.size()-1]=0` 了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e4 + 10;
int dp[N][N];  // dp[i][j]==1:用1~i枚硬币可以凑出金额j
vector<int> v;
vector<int> ans;
int main() {
  int n, m;
  cin >> n >> m;
  v.resize(n + 1);
  FOR(i, 1, n + 1) { cin >> v[i]; }
  //因为后面找序列的时候是从后往前找，所以要递减
  sort(v.begin() + 1, v.end(), greater<int>());  //注意排除第0项干扰
  // FOR(i, 0, v.size()) { cout << v[i]; }
  FOR(i, 0, n + 1) { dp[i][0] = 1; }  //初始化
  FOR(i, 1, n + 1) {  	//枚举硬币
    FOR(j, 1, m + 1) {	//枚举金额
      //没用第i枚硬币时，能凑出j-v[i]，用了自然能凑出j
      if (j - v[i] >= 0 && dp[i - 1][j - v[i]] == 1)
        dp[i][j] = 1;
      else
        dp[i][j] = dp[i - 1][j];
    }
  }
  if (dp[n][m] == 1) {
    while (m) {
      if (dp[n - 1][m - v[n]] == 1) {
        m -= v[n];
        ans.push_back(v[n]);
      }
      n--;  //不论第n块用不用，都要往前
    }

    FOR(i, 0, ans.size() - 1) { cout << ans[i] << " "; }
    cout << ans[ans.size() - 1] << endl;
  } else {
    cout << "No Solution\n";
  }
  system("pause");
  return 0;
}
```

## L3-002 特殊堆栈 (30 分)|二分查找|维护一个始终有序的vector

主要难点在于  取中值，取中值的时候，取得是按照大小排序后的的中值，也就是取当前栈中的中位数

也就是说：

- 要有一个有序的 （插入时就有序

  - 借助 `lower_bound`：在**指定区域内查找==不小于(>=)==目标值的第一个元素**。

  ```cpp
  if(s == "Push")
  {
      int temp;
      cin>>temp;
      stk.push_back(temp);//普通栈
      auto it = lower_bound(v.begin(),v.end(),temp);//插入时就有序
      v.insert(it,temp);//有序栈
  }
  ```

  删除时同理

  ```cpp
  auto it = lower_bound(v.begin(), v.end(), stk[stk.size() - 1]);
  v.erase(it);
  ```

  

- 还要和栈中本身的顺序联系起来

  - 插入普通栈正常插

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 10;
vector<int> v, stk;
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    string s;
    cin >> s;
    if (s == "Push") {
      int tmp;
      cin >> tmp;
      stk.push_back(tmp);
      auto it = lower_bound(v.begin(), v.end(), tmp);
      v.insert(it, tmp);
    } else if (s == "Pop") {
      if (stk.size() == 0)
        cout << "Invalid\n";
      else {
        int sz = stk.size();
        auto it = lower_bound(v.begin(), v.end(), stk[sz - 1]);
        v.erase(it);
        cout << stk[sz - 1] << endl;
        stk.pop_back();
      }
    } else if (s == "PeekMedian") {
      if (stk.size() == 0) {
        cout << "Invalid\n";
      } else {
        //注意这里如何取下标:题目给的编号从1开始，自己建立的v从0开始
        int idx = (v.size() + 1) / 2 - 1;
        cout << v[idx] << endl;
      }
    }
  }
  system("pause");
  return 0;
}
```



## L3-003 社交集群 (30 分)|并查集

一个“社交集群”是指**部分**兴趣爱好**相同**的人的**集合**——并查集

关键在于找到 ==该兴趣的第一个人，后面的人都跟随他就好了==

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1005;
int f[N];   
vector<int> ans(0);
int find(int a) { return f[a] == a ? a : f[a] = find(f[a]); }
int num[N];    //社群人数
int first[N];  //兴趣第一人
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = fb;
    num[fb] += num[fa];
  }
}
int main() {
  FOR(i, 0, N) f[i] = i;
  int n;
  cin >> n;
  FOR(i, 1, n + 1) { num[i] = 1; }
  FOR(i, 1, n + 1) {
    int k;
    char c;
    cin >> k >> c;
    while (k--) {
      int x;
      cin >> x;
      if (first[x] == 0) first[x] = i;
      merge(i, first[x]);  //跟随兴趣第一人
    }
  }
  FOR(i, 1, n + 1) {
    if (f[i] == i) {
      ans.push_back(num[i]);
    }
  }
  sort(ans.begin(), ans.end(), greater<int>());
  cout << ans.size() << endl;
  cout << ans[0];
  FOR(i, 1, ans.size()) cout << " " << ans[i];

  system("pause");
  return 0;
}
```

## L3-004 肿瘤诊断 (30 分)|三维BFS

- 主要在于 每次 `BFS`时
  - 要判断 是否满足 `cnt >= t`，大于才记入
  - 进入过队列的像素数，就是该连通块的大小

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
int mp[1300][150][100];
int vis[1300][150][100];

int X[6] = {1, 0, 0, -1, 0, 0};
int Y[6] = {0, 1, 0, 0, -1, 0};
int Z[6] = {0, 0, 1, 0, 0, -1};
int n, m, l, t;
bool judge(int x, int y, int z) {
  if (x < 0 || x >= m || y < 0 || y >= n || z < 0 || z >= l) return 0;
  if (mp[x][y][z] == 0 || vis[x][y][z] == 1) return 0;
  return 1;
}
struct node {
  int x, y, z;
};
int bfs(int x, int y, int z) {
  int cnt = 0;  //当前块的体积
  queue<node> q;
  q.push({x, y, z});
  vis[x][y][z] = 1;
  while (!q.empty()) {
    node top = q.front();
    q.pop();
    cnt++;  //记录这次总共有多少个点进入过q
    FOR(i, 0, 6) {
      int tx = top.x + X[i], ty = top.y + Y[i], tz = top.z + Z[i];
      if (judge(tx, ty, tz)) {
        vis[tx][ty][tz] = 1;
        q.push({tx, ty, tz});
      }
    }
  }
  if (cnt >= t) return cnt;
  return 0;
}
int main() {
  cin >> m >> n >> l >> t;
  FOR(i, 0, l) {
    FOR(j, 0, m) {
      FOR(k, 0, n) { cin >> mp[j][k][i]; }
    }
  }
  int ans = 0;
  FOR(i, 0, l) {
    FOR(j, 0, m) {
      FOR(k, 0, n) {
        if (mp[j][k][i] && !vis[j][k][i]) ans += bfs(j, k, i);
      }
    }
  }
  cout << ans;
  system("pause");
  return 0;
}
```



## L3-005 垃圾箱分布 (30 分)|输入处理|==dijkstra==

- 垃圾箱的位置必须选在到所有居民点的最短距离最长的地方

- 保证每个居民点都在距离它一个不太远的范围内

  - 对每个可防止垃圾箱的店都进行`dijkstra`，得到该垃圾箱到所有居住点的最短长度和平均长度
  - 外层变量存储最合适的答案

- 处理字符串 `G10`

  ```cpp
  if (s1[0] == 'G') {
      s1 = s1.substr(1); //要这样而不是 s1=s1[1]，因为还有 G10
      a = n + stoi(s1);
  } else
      a = stoi(s1);
  ```

- 要求

  - `ds`是居民点与垃圾箱之间不能超过的最大距离
  - 到所有居民点的最短距离最长
  - 如果解不唯一，则输出到所有居民点的平均距离最短的那个解
  - 如果这样的解还是不唯一，则输出编号最小的地点

无注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl

const int N = 1020, inf = INT_MAX;
int n, m, k, ds;
struct node {
  int id, l;
};
vector<node> E[N];
int dis[N];
bool vis[N];
int main() {
  cin >> n >> m >> k >> ds;
  FOR(i, 0, k) {
    int w, a, b;
    string s, t;
    cin >> s >> t >> w;
    if (s[0] == 'G') {
      s = s.substr(1);
      a = n + stoi(s);
    } else {
      a = stoi(s);
    }
    if (t[0] == 'G') {
      t = t.substr(1);
      b = n + stoi(t);
    } else {
      b = stoi(t);
    }
    E[a].push_back(node{b, w});
    E[b].push_back(node{a, w});
  }
  int ansid = -1;
  double ansdis = -1, ansaver = inf;
  FOR(index, n + 1, n + m + 1) {
    double mindis = inf, aver = 0;
    fill(dis, dis + N, inf);
    fill(vis, vis + N, 0);
    dis[index] = 0;
    FOR(i, 1, n + m + 1) {
      int u = -1, minn = inf;
      FOR(j, 1, n + m + 1) {
        if (vis[j] == 0 && dis[j] < minn) {
          u = j, minn = dis[j];
        }
      }
      if (u == -1) break;
      vis[u] = true;
      for (auto v : E[u]) {
        if (!vis[v.id] && dis[v.id] > dis[u] + v.l) {
          dis[v.id] = dis[u] + v.l;
        }
      }
    }
    FOR(i, 1, n + 1) {
      if (dis[i] > ds) {
        mindis = -1;
        break;
      }
      if (dis[i] < mindis) mindis = dis[i];  //最短路径
      aver += 1.0 * dis[i];
    }
    if (mindis == -1) continue;
    aver = aver / n;

    //判断一下
    if (mindis > ansdis) {
      ansid = index;
      ansdis = mindis;
      ansaver = aver;
    } else if (mindis == ansdis && aver < ansaver) {
      ansid = index;
      ansaver = aver;
    }
  }
  if (ansid == -1)
    printf("No Solution");
  else {
    printf("G%d\n", ansid - n);
    printf("%.1f %.1f", ansdis, ansaver);
  }
  system("pause");
  return 0;
}
```

注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl

const int N = 1020, inf = 999999999;
int n, m, k, ds, station;
int e[N][N], dis[N];
bool vis[N];
int main() {
  //初始化地图,没路的距离就是inf
  fill(e[0], e[0] + N * N, inf);
  cin >> n >> m >> k >> ds;
  FOR(i, 0, k) {
    int w, a, b;
    string s, t;
    cin >> s >> t >> w;
    if (s[0] == 'G') {
      s = s.substr(1);
      a = n + stoi(s);
    } else {
      a = stoi(s);
    }
    if (t[0] == 'G') {
      t = t.substr(1);
      b = n + stoi(t);
    } else {
      b = stoi(t);
    }
    e[a][b] = w, e[b][a] = w;
  }

  int ansid = -1;  //存储最终选择的候选编号，如果没有符合要求的 就是-1
  double ansdis = -1,  //最终的最短路径
      ansaver = inf;   //最终的平均路径长度

  //对每个候选点进行dij算法：将其作为起点，算出到各个居民的距离——存储在dis中
  FOR(index, n + 1, n + m + 1) {
    double mindis = inf, aver = 0;
    fill(dis, dis + N, inf);
    fill(vis, vis + N, 0);
    dis[index] = 0;
    FOR(i, 0, n + m + 1) {
      int u = -1, minn = inf;
      FOR(j, 1, n + m + 1) {
        if (vis[j] == 0 && dis[j] < minn) {
          u = j, minn = dis[j];
        }
      }
      if (u == -1) break;
      vis[u] = true;
      FOR(v, 1, n + m + 1) {
        if (vis[v] == 0 && dis[v] > dis[u] + e[u][v]) dis[v] = dis[u] + e[u][v];
      }
    }
    FOR(i, 1, n + 1) {
      if (dis[i] > ds) {
        mindis = -1;
        break;
      }
      if (dis[i] < mindis) mindis = dis[i];  //最短路径
      aver += 1.0 * dis[i];
    }
    if (mindis == -1) continue;
    aver = aver / n;

    //判断一下
    if (mindis > ansdis) {
      ansid = index;
      ansdis = mindis;
      ansaver = aver;
    } else if (mindis == ansdis && aver < ansaver) {
      ansid = index;
      ansaver = aver;
    }
  }
  if (ansid == -1)
    printf("No Solution");
  else {
    printf("G%d\n", ansid - n);
    printf("%.1f %.1f", ansdis, ansaver);
  }
  return 0;
}
```

## L3-006 迎风一刀斩 (30 分)|==数字计算几何学|看懂代码不会写==

题目中旋转性质——直角边肯定平行x或y轴

能拼成矩阵：

- 两个矩形
  - 简单判断是否有任一边相等
- 两个直角三角形
- 两个直角梯形
- 一个三角形+一个五边形
  - 除了长度以外还有斜率

> `k1`表示第一个图形的斜率，`k2`表示第二个图形的斜率，`SLength`中储存较短的平行于x轴的边，`LLength`中储存较长的平行于x轴的边，`SWidth`中储存较短的平行于y轴的边，`LWidth`中储存较长的平行于y轴的边，`res`表示有多少条直角边，`dif`为两点距离～
>
> ——[柳婼blog](https://blog.csdn.net/liuchuo/article/details/121026522?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164709550416780264010504%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164709550416780264010504&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121026522.nonecase&utm_term=L3-006+%E8%BF%8E%E9%A3%8E%E4%B8%80%E5%88%80%E6%96%A9+%2830+%E5%88%86%29&spm=1018.2226.3001.4450)
>
> ps：他这上面好像有些错的，详细看我下面代码里的注释吧

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k1, k2,         //坐标点
    SLength, LLength,  //较短和较长的平行于y轴的边长度
    SWidth, LWidth,    //较短和较长的平行于x轴的边长度
    res, dif,          //直角边的条数、两点距离
    D1, D2, a, b;
vector<pair<int, int>> A(10), B(10);  // PII存储坐标
//传入坐标存储体和坐标个数
void deal(const vector<pair<int, int>> &C, const int &l) {
  res = SLength = LLength = SWidth = LWidth = 0;
  for (int i = 0; i < l; i++) {
    //这样判断是否为直角边  这个(i+1)%l 很妙
    if (C[i].first == C[(i + 1) % l].first) {
      res++;
      dif = abs(C[i].second - C[(i + 1) % l].second);  // y轴差值
      if (dif > LLength)
        SLength = LLength, LLength = dif;
      else
        SLength = dif;
    } else if (C[i].second == C[(i + 1) % l].second) {
      res++;
      dif = abs(C[i].first - C[(i + 1) % l].first);  // x轴差值
      if (dif > LWidth)
        SWidth = LWidth, LWidth = dif;
      else
        SWidth = dif;
    }
  }
}
string judge() {
  if (k1 > 5 || k2 > 5) return "NO";
  if (k1 == 4 && k2 == 4) {
    deal(A, k1);
    if (res == 4) {  //矩形
      D1 = LLength, D2 = LWidth;
      deal(B, k2);
      if (res != 4) return "NO";  //要求也是矩形，并且有一条边相等
      if (D1 == LLength || D2 == LWidth || D2 == LLength || D1 == LWidth)
        return "YES";
    } else if (res == 3) {  //直角梯形
      if (SWidth == 0)
        D1 = LWidth, D2 = LLength - SLength;
      else
        D1 = LLength, D2 = LWidth - SWidth;
      deal(B, k2);
      if (res != 3) return "NO";  //要求也是直角梯形
      if (SWidth == 0 && D1 == LWidth && D2 == LLength - SLength)
        return "YES";
      else if (SLength == 0 && D1 == LLength && D2 == LWidth - SWidth)
        return "YES";
    }
    return "NO";
  }
  //将一个直角三角形和五边形的两种情况统一
  if (k2 > k1) swap(k1, k2), swap(A, B);
  deal(A, k1);
  if (res != k1 - 1) return "NO";
  D1 = LLength - SLength, D2 = LWidth - SWidth;
  deal(B, k2);
  if (res != k2 - 1) return "NO";
  if ((D1 == LLength && D2 == LWidth) || (D2 == LLength && D1 == LWidth))
    return "YES";
  return "NO";
}
int main() {
  cin >> n;
  while (n--) {
    cin >> k1;
    for (int i = 0; i < k1; i++) cin >> A[i].first >> A[i].second;
    cin >> k2;
    for (int i = 0; i < k2; i++) cin >> B[i].first >> B[i].second;
    cout << judge() << '\n';
  }
  return 0;
}
```

## **L3-007 天梯地图 (30 分)**|==dijkstra==

> 题目： https://pintia.cn/problem-sets/994805046380707840/problems/994805051153825792

- 给图找路，图中有单向边
- 一条最快中最短
- 一条最短中节点最少
  - 要求结点最少的话，先存储下来最短时所有可能的 `pre` (该上一个结点)，然后`dfs`搜索得到满足 ==最少结点数==的路径

- 有上面两条为一条的情况
- 数据量： 点数[2,500]
- 两个 Dijkstra：最快、最短
- 用一个二维数组存储所有结点的最短路径，DFS 求出结点最少的那条

> 分析：用两个`Dijkstra` + `DFS`。一个求最快路径（如果相同求路径的那条），一个求最短路径（如果相同求结点数最小的那条）求最快路径可以直接在Dijkstra里面求前驱结点`Timepre`数组 求最短路径因为==要求结点数最小==的那条，==所以要用`dispre`的二维数组存储所有结点的最短路径，然后用`DFS`求出满足条件的结点数最小的那条==
>
> 注意：
>
> 1. 一开始最后一个测试用例“答案错误”，后来发现是自己在求最短路径（第二个答案`distance`）的时候忘记了`temppath`每一次深搜结束后的pop_back();
>
> 2. 如果直接使用DFS的话，会导致最后一个测试用例“运行超时”～
>
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/52487817

无注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 505, inf = INT_MAX;
int tpre[N], vis[N], tim[N], dis[N], mnsz = inf;
vector<int> dpre[N], tmppath, dispath, timpath;
struct node {
  int id, l = inf, t = inf;
};
vector<node> E[N];
int st, fi;
void dfsDisPath(int v) {
  tmppath.push_back(v);
  if (v == st) {
    if (tmppath.size() < mnsz) {
      mnsz = tmppath.size();
      // dbg(mnsz);
      dispath = tmppath;
    }
    tmppath.pop_back();
    return;
  }
  for (auto u : dpre[v]) {
    dfsDisPath(u);
  }
  tmppath.pop_back();
}
int n, m;
int main() {
  cin >> n >> m;
  while (m--) {
    int a, b, o, l, t;
    cin >> a >> b >> o >> l >> t;
    E[a].push_back(node{b, l, t});
    if (o == 0) {
      E[b].push_back(node{a, l, t});  //一开始读数据写错了，检查其他地方检查了半天，非常sb
    }
  }
  cin >> st >> fi;
  fill(tim, tim + N, inf);
  fill(dis, dis + N, inf);
  tim[st] = 0;
  dis[st] = 0;
  FOR(i, 0, n) { tpre[i] = i; }
  // time dij
  FOR(i, 0, n) {
    int u = -1, mn = inf;
    FOR(j, 0, n) {
      if (!vis[j] && tim[j] < mn) {
        u = j;
        mn = tim[j];
      }
    }
    if (u == -1) break;
    vis[u] = 1;
    for (auto v : E[u]) {
      if (!vis[v.id]) {
        if (v.t + tim[u] < tim[v.id]) {
          tim[v.id] = v.t + tim[u];
          dis[v.id] = dis[u] + v.l;
          tpre[v.id] = u;
        } else if (v.t + tim[u] == tim[v.id] && dis[v.id] > v.l + dis[u]) {
          dis[v.id] = v.l + dis[u];
          tpre[v.id] = u;
        }
      }
    }
  }
  int tmp = fi;
  while (tmp != st) {
    timpath.push_back(tmp);
    tmp = tpre[tmp];
  }
  timpath.push_back(st);
  fill(vis, vis + N, 0);
  fill(dis, dis + N, inf);
  dis[st] = 0;
  FOR(i, 0, n) {
    int u = -1, mn = inf;
    FOR(j, 0, n) {
      if (!vis[j] && mn > dis[j]) {
        u = j, mn = dis[j];
      }
    }
    if (u == -1) break;
    vis[u] = 1;
    for (auto v : E[u]) {
      if (!vis[v.id] && dis[v.id] > dis[u] + v.l) {
        dis[v.id] = dis[u] + v.l;
        dpre[v.id].clear();  //有更短的路线就要清除
        dpre[v.id].push_back(u);
      } else if (!vis[v.id] && dis[v.id] == dis[u] + v.l) {
        dpre[v.id].push_back(u);
      }
    }
  }
  dfsDisPath(fi);
  cout << "Time = " << tim[fi];
  if (dispath == timpath) {
    cout << "; Distance = " << dis[fi] << ": ";
  } else {
    cout << ": ";
    for (int i = timpath.size() - 1; i >= 0; i--) {
      cout << timpath[i];
      if (i != 0) cout << " => ";
    }
    cout << endl;
    cout << "Distance = " << dis[fi] << ": ";
  }
  for (int i = dispath.size() - 1; i >= 0; i--) {
    cout << dispath[i];
    if (i != 0) cout << " => ";
  }
  system("pause");
  return 0;
}
```



注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)
const int inf = INT_MAX, N = 505;
int dis[N],      //起点到各点的距离
    Time[N],     //起点到各点的时间
    e[N][N],     // a->b距离
    w[N][N],     // a->b两地时间
    Timepre[N],  //时间最短路径中的每个点的前驱节点
    weight[N];   //算时间最短路径时，起点到点的长度
bool vis[N];
vector<int> timePath, disPath, tempPath, disPre[N];
int st,             //起点
    fin,            //终点
    minnode = inf;  //最短路径中最少的节点数

//查找时间最短路径
void dfstimePath(int v) {  //传入终点
  timePath.push_back(v);
  if (v == st) return;
  dfstimePath(Timepre[v]);
}
//查找路径最短路径
void dfsdisPath(int v) {
  tempPath.push_back(v);
  if (v == st) {                      //已经到最后了
    if (tempPath.size() < minnode) {  //并且结点更少
      minnode = tempPath.size();
      disPath = tempPath;
    }
    tempPath.pop_back(); // 回溯
    return;
  }
  for (int i = 0; i < disPre[v].size(); i++) {
    dfsdisPath(disPre[v][i]);
  }
  tempPath.pop_back(); // 回溯
}
int main() {
  ios::sync_with_stdio(false);
  //初始化
  fill(dis, dis + N, inf);
  fill(Time, Time + N, inf);
  fill(weight, weight + N, inf);
  fill(e[0], e[0] + N * N, inf);
  fill(w[0], w[0] + N * N, inf);

  int n, m;
  scanf("%d %d", &n, &m);
  int a, b, flag, len, t;
  for (int i = 0; i < m; i++) {
    scanf("%d %d %d %d %d", &a, &b, &flag, &len, &t);
    e[a][b] = len;
    w[a][b] = t;
    if (flag != 1) {
      e[b][a] = len;
      w[b][a] = t;
    }
  }
  scanf("%d %d", &st, &fin);  //起点终点

  Time[st] = 0;
  for (int i = 0; i < n; i++) {
    Timepre[i] = i;
  }
  //时间最短Dij
  for (int i = 0; i < n; i++) {
    int u = -1, minn = inf;
    for (int j = 0; j < n; j++) {
      if (vis[j] == false && Time[j] < minn) {
        u = j;
        minn = Time[j];
      }
    }
    if (u == -1) break;
    vis[u] = true;
    for (int v = 0; v < n; v++) {
      if (vis[v] == false && w[u][v] != inf) {
        if (w[u][v] + Time[u] < Time[v]) {
          Time[v] = w[u][v] + Time[u];
          Timepre[v] = u;
          weight[v] = weight[u] + e[u][v];
        } else if (w[u][v] + Time[u] == Time[v] &&
                   weight[v] > weight[u] + e[u][v])
        //时间相等的话就要看距离
        {
          weight[v] = weight[u] + e[u][v];
          Timepre[v] = u;
        }
      }
    }
  }

  //存储时间最短路径
  dfstimePath(fin);

  //开始查找
  fill(vis, vis + N, false);
  dis[st] = 0;
  for (int i = 0; i < n; i++) {
    int u = -1, minn = inf;
    for (int j = 0; j < n; j++) {
      if (vis[j] == false && minn > dis[j]) {
        u = j;
        minn = dis[j];
      }
    }
    if (u == -1) break;
    vis[u] = true;
    for (int v = 0; v < n; v++) {
      if (vis[v] == false && e[u][v] != inf) {
        if (e[u][v] + dis[u] < dis[v])
        //有更短的路径
        {
          dis[v] = e[u][v] + dis[u];
          disPre[v].clear();  //那之前保存的上一节点集合可以清空了
          disPre[v].push_back(u);
        } else if (e[u][v] + dis[u] == dis[v]) {
          disPre[v].push_back(u);  //如果长度相似，就都存下来，后面dfs比较节点数
        }
      }
    }
  }

  //存储最短路径
  dfsdisPath(fin);

  printf("Time = %d", Time[fin]);
  if (disPath == timePath) {
    printf("; Distance = %d: ", dis[fin]);
  } else {
    printf(": ");
    for (int i = timePath.size() - 1; i >= 0; i--) {
      printf("%d", timePath[i]);
      if (i != 0) printf(" => ");
    }
    printf("\n");
    printf("Distance = %d: ", dis[fin]);
  }
  for (int i = disPath.size() - 1; i >= 0; i--) {
    printf("%d", disPath[i]);
    if (i != 0) printf(" => ");
  }
  return 0;
}
```



## **L3-008 喊山 (30 分)**|BFS

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050709229568

- `n`（≤10000）是总的山头数
- 一个山头呼喊的声音可以被临近的山头同时听到，每个山头最多有两个能听到它的临近山头
- 给出起点山头，找出最远能传到的地方
- 如果不止一个最远山头，就输出编号最小的
- 广度优先搜索
- ==过滤起点==：直接在每次循环中初始答案id设置为 0，当没有的时候就输出0

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 100005;
vector<int> E[N];
bool vis[N];
int level[N];
int n, m, k;
int main() {
  cin >> n >> m >> k;
  FOR(i, 1, m + 1) {
    int a, b;
    cin >> a >> b;
    E[a].push_back(b);
    E[b].push_back(a);
  }
  while (k--) {
    int x;
    cin >> x;
    queue<int> q;
    fill(vis, vis + N, 0);
    fill(level, level + N, 0);
    int mx = -1, id = 0;
    q.push(x);
    vis[x] = 1;
    while (!q.empty()) {
      int top = q.front();
      q.pop();
      for (auto it : E[top]) {
        if (!vis[it]) {
          q.push(it);
          vis[it] = 1;
          level[it] = level[top] + 1;
          if (level[it] > mx) {
            mx = level[it];
            id = it;
          } else if (level[it] == mx) {
            if (it < id) {
              id = it;
            }
          }
        }
      }
    }
    cout << id << endl;
  }
  system("pause");
  return 0;
}
```



## **L3-009 长城 (30 分)**|==数学知识|计算几何+凸包==

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050277216256

- 长城，烽火台。烽火台在其折线点上
- 接收 n 个长城边缘折线点坐标——从南到北给
- 坐标 ∈[-10^9, 10^9]
- 总部在最南
- 要保证每个位置都能有南侧的烽火台能观望到
- 求烽火台最少数目

- 假设当前点为 A，他的右边有相邻点 B，C，此时若是 AC\*AB<0，即 AB 在 AC 上方，此时 B 为凸点。

![image-20211110110250589](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110110250589.png)

- 但并不是单纯的凸点记入，凹点舍弃，比如下图的情况

  ![image-20211110204916475](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110204916475.png)

  这情况明显只需要中间蓝色的圈和右边红色的圈即可

  (_其实一开始是想右边两个圈蓝色的，但是画错了，不想重新画了)_

  但是只判断凹凸的话，就会把左边红圈点也记入。

  明显用多了一个

  也就是说，每个烽火台观察的点不是连续的——那么就要用到栈来辅助判断。

- 从南到北——即从右到左依次入栈，判断栈顶点是否为凸点。是则记入，不是则舍弃。**凸点会继续参与比较，凹点会被弹出。**

- 当栈中存在大于 2 个的点时，表示 b 点为烽火

- 用 set 去重

[代码+注释](./code/L3-009.cpp)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int maxn = 1e5 + 10;
ll x[maxn], y[maxn];
int stk[maxn],  //模拟栈
    top;        //栈顶，stk[top-1]即栈顶元素：因为每次insert完 top++了
set<int> se;

//是否为凹点——即不是凸点:kab <= kac(叉乘)
bool isConcave(int a, int b, int c) {
  return (x[c] - x[a]) * (y[b] - y[a]) <= (x[b] - x[a]) * (y[c] - y[a]);
}

int main() {
  ios::sync_with_stdio(false);
  int n;
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> x[i] >> y[i];
    //如果原先栈中已有两点(top>=1)，
    //那么再加上目前遍历读入的这个点就有三个点可以叉乘了
    if (top >= 1) {
      while (top >= 2 && isConcave(i, stk[top - 1], stk[top - 2]))
        top--;                    //舍弃凹点，直到找到凸点
      if (stk[top - 1] != 0)      //总部不算
        se.insert(stk[top - 1]);  //凸点入集合
    }
    stk[top++] = i;  //将这个新点加入栈
  }
  cout << se.size() << endl;
  return 0;
}
```



## L3-010 是否完全二叉搜索树|==完全二叉搜索树性质==

- 给定二叉搜索树（定义左子树大、右子树小）
  - 自己按规则插入

- 给出层序遍历结果
- 判断是否为完全二叉搜索树
- 根据二叉树性质即可：i 节点左孩子为 `i<<1` 右孩子为 `i<<1|1`
- ==判断是否完全：输出完 n 个点前，出现空节点就不是完全==

无注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
int t[1 << 20];
int n, x;
void BST(int id) {
  if (t[id]) {
    if (x > t[id])
      BST(id * 2);
    else
      BST(id * 2 + 1);
  } else
    t[id] = x;
}
int main() {
  cin >> n;
  FOR(i, 0, n) {
    cin >> x;
    BST(1);
  }
  bool flag = 1;
  for (int cnt = 1, k = 1; cnt <= n; k++) {
    if (t[k] == 0)
      flag = 0;
    else {
      cout << t[k];
      if (cnt != n) cout << " ";
      cnt++;
    }
  }
  if (flag == 1)
    cout << "\nYES";
  else
    cout << "\nNO";
  system("pause");
  return 0;
}
```



[代码+注释](./code/L3-010.cpp)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int t[1 << 20];
int n, num;
void BST(int a) {
  //找到可放入的空节点
  if (t[a] == 0)
    t[a] = num;
  else if (t[a] < num)  // num大于该节点，放到左子树中
    BST(a << 1);
  else
    BST(a << 1 | 1);
}
int main() {
  ios::sync_with_stdio(false);
  cin >> n;
  FOR(i, 0, n) {
    cin >> num;
    BST(1);  //从根节点开始找点放入num
  }
  bool flag = 1;
  for (int cnt = 1, k = 1; cnt <= n; k++) {
    if (t[k] == 0)  //有空节点
      flag = 0;
    else {
      cout << t[k];
      if (cnt != n) cout << " ";
      cnt++;
    }
  }
  if (flag == 1)
    cout << "\nYES";
  else
    cout << "\nNO";
  return 0;
}
```



## L3-011 直捣黄龙|==最短路|多条件的Dijskra|map映射==

- 三个条件：最快>城镇最多>有效杀伤最多
- 存储：最合适路径、最快路数、最短进攻距离、歼敌总数
  - 还需要打印路径，所以还需要一个 `pre` 数组来存储每个结点的上一个结点

- 数据量：城镇数 ∈[2, 200]
- 将字符串与数字做映射，方便操作
- ==`Dijskra`: 优先队列+堆优化==

> 定义：`priority_queue<Type, Container, Functional>`
>
> `Type` 就是数据类型，`Container` 就是容器类型（`Container`必须是用数组实现的容器，比如`vector`,`deque`等等，但不能用 list。`STL`里面默认用的是`vector`），`Functional` 就是比较的方式。
>
> ==决定了容器中最大的元素会排在队列前面——优先级最大的，所以重载小于号使得 dis 大的优先级小==

无注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 205;
struct node {
  int id, dis;
  bool friend operator<(node a, node b) { return a.dis > b.dis; }
};
vector<node> E[N];
map<string, int> n2i;  //<name,id>
map<int, string> i2n;  //<id,name>
int cnt = 0;
int enemy[N], eneAll[N], vis[N], cityAll[N], sum[N], num[N], dis[N], pre[N];
int n, k, sti, fii, d;
void dij() {
  fill(vis, vis + N, 0);
  fill(dis, dis + N, INT_MAX);
  dis[sti] = 0, sum[sti] = 1;
  priority_queue<node> q;
  q.push(node{sti, 0});
  while (!q.empty()) {
    int now = q.top().id, nowd = q.top().dis;	
  //用优先级队列实际就是省去了这里本来应该有的循环枚举——用来寻找未访问过且dis最小的点
    q.pop();
    if (vis[now]) continue;
    vis[now] = 1;
    for (auto it : E[now]) {
      int v = it.id, vd = it.dis;
      if (dis[v] > nowd + vd) {
        dis[v] = nowd + vd;
        eneAll[v] = eneAll[now] + enemy[v];
        sum[v] = sum[now];
        num[v] = num[now] + 1;
        q.push(node{v, dis[v]});
        pre[v] = now;
      } else if (dis[v] == nowd + vd) {
        sum[v] += sum[now];
        if (num[v] < num[now] + 1) {
          num[v] = num[now] + 1;
          eneAll[v] = eneAll[now] + enemy[v];
          q.push(node{v, dis[v]});
          pre[v] = now;
        } else if (num[v] == num[now] + 1) {
          if (eneAll[v] < eneAll[now] + enemy[v]) {
            eneAll[v] = eneAll[now] + enemy[v];
            q.push(node{v, dis[v]});
            pre[v] = now;
          }
        }
      }
    }
  }
}
int main() {
  string sts, fis, s;
  cin >> n >> k >> sts >> fis;
  n2i[sts] = cnt;
  sti = cnt;  // 0
  i2n[cnt++] = sts;
  FOR(i, 1, n) {
    cin >> s >> d;
    n2i[s] = cnt;
    enemy[cnt] = d;
    i2n[cnt++] = s;
  }
  fii = n2i[fis];
  FOR(i, 0, k) {
    string a, b;
    int w;
    cin >> a >> b >> w;
    E[n2i[a]].push_back({n2i[b], w});
    E[n2i[b]].push_back({n2i[a], w});
  }
  dij();
  vector<int> ans;
  int x = fii;
  while (x != sti) {
    ans.push_back(x);
    x = pre[x];
  }
  cout << i2n[0];
  for (int i = ans.size() - 1; i >= 0; i--) {
    cout << "->" << i2n[ans[i]];
  }

  cout << endl;
  cout << sum[fii] << " " << dis[fii] << " " << eneAll[fii];
  system("pause");
  return 0;
}
```



[代码+注释](./code/L3-011.cpp)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)

struct node {
  int id, dis;

  //方便后面的优先队列
  bool friend operator<(const node &a, const node &b) { return a.dis > b.dis; }
};

int n, k, s, t, cnt, d,
    enemyNum[205],  //各个大本营敌军数量
    enemyAll[205],  //到该点的总共的歼敌数量
    pre[205],       //到该大本营的上一个点
    Dis[205],       //起点到各点的最短距离
    vis[205],
    sum[205],         //到该点路线数量
    liberation[205];  //到该店解放的大本营数

//映射
map<string, int> ntoi;  // name->id
map<int, string> iton;  // id->name

vector<pair<int, int>> E[205];  //存图, <u,d>:E[i]到u点,权为d
vector<int> ans;
string S, T, u, v;

void Dijskra() {
  fill(Dis, Dis + 205, 1e9);
  Dis[s] = 0;
  sum[s] = 1;
  priority_queue<node> Q;
  Q.push(node{s, 0});
  while (!Q.empty()) {
    int now = Q.top().id, nowD = Q.top().dis;
    Q.pop();
    if (vis[now]) continue;
    vis[now] = 1;
    for (auto it : E[now]) {
      int itV = it.first, itD = it.second;
      if (Dis[itV] > nowD + itD) {
        Dis[itV] = nowD + itD;
        enemyAll[itV] = enemyAll[now] + enemyNum[itV];
        sum[itV] = sum[now];
        liberation[itV] = liberation[now] + 1;
        Q.push(node{itV, Dis[itV]});
        pre[itV] = now;
      } else if (Dis[itV] == nowD + itD) {
        sum[itV] += sum[now];
        if (liberation[itV] < liberation[now] + 1) {
          liberation[itV] = liberation[now] + 1;
          enemyAll[itV] = enemyAll[now] + enemyNum[itV];
          Q.push(node{itV, Dis[itV]});
          pre[itV] = now;
        } else if (liberation[itV] == liberation[now] + 1) {
          if (enemyAll[itV] < enemyAll[now] + enemyNum[itV]) {
            enemyAll[itV] = enemyAll[now] + enemyNum[itV];
            Q.push(node{itV, Dis[itV]});
            pre[itV] = now;
          }
        }
      }
    }
  }
}
int main() {
  ios::sync_with_stdio(false);
  cin >> n >> k >> S >> T;
  for (int i = 0; i < n - 1; i++) {
    cin >> u >> d;
    ntoi[u] = ++cnt;
    iton[cnt] = u;
    enemyNum[cnt] = d;
  }
  //起点的映射
  ntoi[S] = 0, iton[0] = S;
  //终点
  t = ntoi[T];

  for (int i = 0; i < k; i++) {
    cin >> u >> v >> d;
    //存边
    E[ntoi[u]].push_back({ntoi[v], d});
    E[ntoi[v]].push_back({ntoi[u], d});
  }
  Dijskra();
  d = t;
  while (d) {
    ans.push_back(d);
    d = pre[d];
  }
  cout << iton[0];
  for (int i = ans.size() - 1; i >= 0; i--) {
    cout << "->" << iton[ans[i]];
  }
  cout << "\n" << sum[t] << " " << Dis[t] << " " << enemyAll[t] << "\n";
  return 0;
}
```

## **L3-012 水果忍者 (30 分)**|==物理计算|几何学==

[动图讲解](https://blog.csdn.net/qq_29997037/article/details/118919769)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Line {
  double x, y1, y2;
};
//按x坐标排序
bool cmp(const Line &lhs, const Line &rhs) { return lhs.x < rhs.x; }

int main() {
  int n;
  cin >> n;
  vector<Line> lines(n);
  for (int i = 0; i < n; ++i) {
    cin >> lines[i].x >> lines[i].y1 >> lines[i].y2;
  }
  sort(lines.begin(), lines.end(), cmp);
  for (int i = 0; i < n; i++) {
    double ansMaxSlope = 1e9;   // 枚举i线段时的最大斜率
    double ansMinSlope = -1e9;  // 枚举i线段时的最小斜率
    bool isMinSlope = false;    // 当前解是不是小斜率？
    Line ansLine;
    int j = 0;
    for (; j < n; j++) {
      if (i == j) continue;
      double minSlope, maxSlope;
      // 这里控制红蓝线条的上下关系
      if (i < j) {
        maxSlope = (lines[i].y2 - lines[j].y1) / (lines[i].x - lines[j].x);
        minSlope = (lines[i].y2 - lines[j].y2) / (lines[i].x - lines[j].x);
      } else {
        maxSlope = (lines[i].y2 - lines[j].y2) / (lines[i].x - lines[j].x);
        minSlope = (lines[i].y2 - lines[j].y1) / (lines[i].x - lines[j].x);
      }
      // 如果不满足条件（也就是所展示的交集关系），则停止枚举
      if (maxSlope < ansMinSlope || minSlope > ansMaxSlope) break;
      // 更新最大最小斜率
      if (maxSlope < ansMaxSlope) {
        ansMaxSlope = maxSlope;
        ansLine = lines[j];
        isMinSlope = false;
      }
      if (minSlope > ansMinSlope) {
        ansMinSlope = minSlope;
        ansLine = lines[j];
        isMinSlope = true;
      }
    }
    // 如果直到最后一条线段都能满足，就说明所有线段都能满足
    if (j == n) {
      printf("%.0f %.0f %.0f %.0f", lines[i].x, lines[i].y2, ansLine.x,
             (isMinSlope ? ansLine.y1 : ansLine.y2));
      return 0;
    }
  }
  return 0;
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;
//Fruit中存储每个水果的坐标信息，kmax表示从枚举点出发能经过所有线段的直线的最大斜率，kmin表示从枚举点出发能经过所有线段的直线的最小斜率，tkmax、tkmin为两个水果之间的最大、最小斜率～
struct node {
	double x, y1, y2;
	bool friend operator < (const node &a, const node &b) {
		return a.x < b.x;
	}
}Fruit[10000];
int n, hx, hy;
double kmax, kmin, tkmax, tkmin;
int main() {
	cin >> n;
	for (int i = 0; i < n; i++) cin >> Fruit[i].x >> Fruit[i].y1 >> Fruit[i].y2;
	sort(Fruit, Fruit + n);
	for (int i = 0, j; i < n; i++) {
		kmax = 1e9, kmin = -1e9;
		for (j = 0; j < n; j++) {
			if (i == j) continue;
			if (i < j) {
				tkmax = (Fruit[j].y1 - Fruit[i].y2) / (Fruit[j].x - Fruit[i].x);
				tkmin = (Fruit[j].y2 - Fruit[i].y2) / (Fruit[j].x - Fruit[i].x);
			} else {
				tkmax = (Fruit[i].y2 - Fruit[j].y2) / (Fruit[i].x - Fruit[j].x);
				tkmin = (Fruit[i].y2 - Fruit[j].y1) / (Fruit[i].x - Fruit[j].x);
			}
			if (tkmax < kmin || tkmin > kmax) break;
			if (tkmax < kmax) {
				kmax = tkmax;
				hx = Fruit[j].x;
				hy = Fruit[j].y1;
			}
			kmin = max(kmin, tkmin);
		}
		if (j == n) {
			cout << hx << ' ' << hy << ' ' << (int)Fruit[i].x << ' ' << (int)Fruit[i].y2;
			break;
		}
	}
	return 0;
}
```

## L3-013 非常弹的球 (30 分)|数学证明、计算

> 因为`E=1/2mv^2`，所以`v^2=2E/m`
> 当v分解为垂直方向的`vsinθ`和水平方向的`vcosθ`，所以水平方向的v为`vsinθ`，t为`vcosθ/g`，抛到最高点时通过的路程为`s = vt = vsinθvcosθ/g`，落下来同样相同的距离，`s = 2vsinθvcosθ/g`
> 因为`2sinθvcosθ=sin2θ`，`sin2θ`的最大值为1，即`2θ=90°，θ=45°`的时候s取得最大值～
> 这样==s = v^2/g==
> 又因为`v^2=2E/m`，在代码中`v^2`为变量`v2`，所以`v2 = 2 * 1000 * 100 /w`，即`E = 1000， m = w/100`
> 每次将`v2/g` 即`v2 / 9.8`的结果累加到s中，可以得到s为最后求得的总距离，每一次while循环，都要将`v2`损失百分比p，直到`v2`足够小（这里取0.000001可以通过所有测试用例，如果是0.00001会有一个测试点答案错误）的时候退出循环～
>
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/66972299

主要结论（其实高中就应该知道了）：想扔最远的角度肯定是 `45°`

```cpp
#include <cstdio>
int main() {
    double w, p, v2, s = 0;
    scanf("%lf%lf", &w, &p);
    v2 = 2 * 1000 * 100 / w;
    while (v2 > 0.000001) {
        s += v2 / 9.8;
        v2 *= (100 - p) * 0.01;
    }
    printf("%.3f", s);
    return 0;
}
```

精妙的地方是==v2足够小==，因为这样一直衰减肯定是不能真正到达0的



## L3-014 周游世界 (30 分)|最短路|DFS|==第一遍有点懵==

> 找出最顺畅的路线。所谓“最顺畅”，首先是指中途经停站最少；如果经停站一样多，则取需要换乘线路次数最少的路线。

> `DFS`过程中要维护两个变量：`minCnt`-中途经停的最少的站; `minTransfer`-需要换乘的最小次数～
>
> 0. 可以这样计算出一条线路的换乘次数：在`line[10000][10000]`的数组中保存==每两个相邻站中间的线路是几号线==～从头到尾遍历最终保存的路径，`preLine`为前一小段的线路编号，如果当前的结点和前一个结点组成的这条路的线路编号和`preLine`不同，说明有一个换乘，就将`cnt+1`，最后遍历完累加的`cnt`即是换乘的次数～
> 1. 可以这样计算出一条线路中途停站的次数：在`dfs`的时候有个变量`cnt`，表示当前路线是所需乘的第几个站，每次`dfs`时候将`cnt+1`表示向下遍历一层 `cnt`就是当前中途停站的次数～
> 2. 可以这样输出结果：和计算线路换乘次数的思路一样，每当`preLine`和当前`Line`值不同的时候就输出一句话～保存`preTransfer`表示上一个换乘站，最后不要忘记输出`preTransfer`和最后一个站之间的路即使最后一个站并不是换乘站～
>
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/68925261

- **输出一行，相邻相连怎么处理？**

```cpp
for (int i = 0; i < n; i++) {
    scanf("%d%d", &m, &pre);//读第一个点作为pre
    for (int j = 1; j < m; j++) {
      scanf("%d", &temp);
      v[pre].push_back(temp); //双向
      v[temp].push_back(pre); //链接
      line[pre][temp] = line[temp][pre] = i + 1;
      pre = temp; //每次循环都更新pre
    }
  }
```

- **怎么知道这条路线换乘了多少次？**

```cpp
//传入路线
int transferCnt(vector<int> a) {
  int cnt = -1, preLine = 0;
  for (int i = 1; i < a.size(); i++) {
  // 当前路线和上一个路线不同，就说明换乘了
    if (line[a[i - 1]][a[i]] != preLine) cnt++;
    preLine = line[a[i - 1]][a[i]];
  }
  return cnt;
}
```

​		并且这个只需要经停站数一样的时候才判断，所以抽象为一个函数，只在需要的时候调用

- **因为需要存储路径==（也就是“状态”有所变化与转移）==，并将路径作为参数传入下一个`dfs`，所以每次`dfs`后记得回溯**

---

AC：

```cpp
#include <cstdio>
#include <vector>
using namespace std;
vector<vector<int>> v(10000);
int line[10000][10000], vis[10000];
vector<int> path, tempPath;
int transferCnt(vector<int> a) {
  int cnt = -1, preLine = 0;
  for (int i = 1; i < a.size(); i++) {
    if (line[a[i - 1]][a[i]] != preLine) cnt++;
    preLine = line[a[i - 1]][a[i]];
  }
  return cnt;
}
void dfs(int node, int end, int cnt, int &minCnt, int &minTransfer) {
  if (node == end && (cnt < minCnt ||
                      (cnt == minCnt && transferCnt(tempPath) < minTransfer))) {
    minCnt = cnt;
    minTransfer = transferCnt(tempPath);
    path = tempPath;
  }
  if (node == end) return;
  for (int i = 0; i < v[node].size(); i++) {
    if (!vis[v[node][i]]) {
      vis[v[node][i]] = 1;
      tempPath.push_back(v[node][i]);
      dfs(v[node][i], end, cnt + 1, minCnt, minTransfer);
      vis[v[node][i]] = 0;
      tempPath.pop_back();
    }
  }
}
int main() {
  int n, m, k, pre, temp, a, b;
  scanf("%d", &n);
  for (int i = 0; i < n; i++) {
    scanf("%d%d", &m, &pre);
    for (int j = 1; j < m; j++) {
      scanf("%d", &temp);
      v[pre].push_back(temp);
      v[temp].push_back(pre);
      line[pre][temp] = line[temp][pre] = i + 1;
      pre = temp;
    }
  }
  scanf("%d", &k);
  for (int i = 0; i < k; i++) {
    scanf("%d%d", &a, &b);
    int minCnt = 99999, minTransfer = 99999;
    tempPath.clear();
    tempPath.push_back(a);
    vis[a] = 1;
    dfs(a, b, 0, minCnt, minTransfer);
    vis[a] = 0;
    if (minCnt == 99999) {
      printf("Sorry, no line is available.\n");
      continue;
    }
    printf("%d\n", minCnt);
    int preLine = 0, preTransfer = a;
    for (int j = 1; j < path.size(); j++) {
      if (line[path[j - 1]][path[j]] != preLine) {
        if (preLine != 0)
          printf("Go by the line of company #%d from %04d to %04d.\n", preLine,
                 preTransfer, path[j - 1]);
        preLine = line[path[j - 1]][path[j]];
        preTransfer = path[j - 1];
      }
    }
    printf("Go by the line of company #%d from %04d to %04d.\n", preLine,
           preTransfer, b);
  }
  return 0;
}
```

## L3-015 球队“食物链” (30 分)|搜索|DFS|==剪枝==

> 分析：
>
> 0. 既然是字典序最小的，而且必须包含所有的球队编号，那如果存在的话1肯定是结果数组的第一位～
> 1. 接收数据：用`v[21][21]`存储比赛结果，如果是W就将`v[i][j]`置为1，表示i战胜过j，如果是L就将`v[j][i]`置为1，表示j战胜过i，其余的不用管～
> 2. `dfs(int index, int num)`：index从1到n用来表示当前即将写入的结果数组`result`的下标，`num`表示当前的球队的编号，从1开始。
> 3. `flag`用来标记是否已经找到一个这样的结果数组，如果已经找到了`（flag == 1）`就`return`; 否则将当前下标`index`的`result`写入`num`值。
>    当index等于n的时候，并且`v[num][1]`等于true，表示已经写到了n个球员，而且这个球队`num`也曾经战胜过球队1～如果仅仅是`index == n`，就直接return不用继续向下找了～
> 4. cut标记剪枝，首先cut等于false，当所有 还没访问过 的结点中没有一个结点的`v[i][1] == true`，即没有一个球队战胜过1，就直接return，因为这条路径肯定找不到回路啦～
> 5. 然后将`num`球队编号标记为已经访问过【`visit[num] = true;`】遍历`num`所有打败过的球队，并将index + 1，直到`dfs`结束的最后将visit标记回false
> 6. 最后根据flag的值输出结果，如果flag为0说明没有满足题意的球队，就输出No Solution，如果flag = 1就输出result数组中保存的结果～
>
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/66972353

全局flag来判断是否已经找到一条路径：因为是按顺序`dfs`的，所以找到的时候自然就是字典序最小的

```cpp
#include <cstdio>
using namespace std;
int n, flag = 0; // flag：1表示已经找到了
int result[21];
bool v[21][21], vis[21];
void dfs(int index, int num) {
  if (flag == 1) return;
  result[index] = num;      //这样存查答案，每次传入的idx是当前已经进入队列的个数，num为当前球队的编号
  if (index == n && v[num][1] == 1) {
    flag = 1;
    return;
  }
  if (index == n) return;
  bool cut = 1;
  for (int i = 1; i <= n; i++) {
    if (vis[i] == 0 && v[i][1] == 1) cut = 0;
  }
  if (cut == 1) return;
  vis[num] = 1;
  for (int i = 1; i <= n; i++) {
    if (vis[i] == 0 && v[num][i] == 1) dfs(index + 1, i);
  }
  vis[num] = 0; //主要是每次上面循环调用dfs进去后需要回溯
}
int main() {
  scanf("%d", &n);
  char s[21];
  for (int i = 1; i <= n; i++) {
    scanf("%s", s + 1);
    for (int j = 1; j <= n; j++) {
      if (s[j] == 'W') v[i][j] = 1;
      if (s[j] == 'L') v[j][i] = 1;
    }
  }
  dfs(1, 1);
  if (flag == 1) {
    for (int i = 1; i <= n; i++) printf("%s%d", i == 1 ? "" : " ", result[i]);
  } else {
    printf("No Solution");
  }
  return 0;
}
```

## L3-016 二叉搜索树的结构 (30 分)|手写一个二叉搜索树插入|字符串处理

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
  int num, lchild, rchild, parent, level;
  node() { lchild = rchild = parent = -1; }
} Tree[128];
int n, m, a, b, in, cnt, root = 1, f;  // cnt：当前结点的个数，也是下标
map<int, int> Find;                    //值对应的下标
string t;
void insert(int x) {
  int now = root;
  while (Tree[now].num != x) {
    if (x < Tree[now].num) {         //小于就往左子树走
      if (Tree[now].lchild == -1) {  //左子树为空

        //插入，修改该点的属性
        Tree[cnt].num = x;
        Tree[cnt].level = Tree[now].level + 1;
        Tree[cnt].parent = now;
        Tree[now].lchild = cnt;
      }
      now = Tree[now].lchild;
    } else {
      if (Tree[now].rchild == -1) {
        Tree[cnt].num = x;
        Tree[cnt].level = Tree[now].level + 1;
        Tree[cnt].parent = now;
        Tree[now].rchild = cnt;
      }
      now = Tree[now].rchild;
    }
  }
}
int main() {
  cin >> n >> in;
  //先存第一个结点进去，方便操作
  Tree[++cnt].num = in;
  Find[in] = cnt;
  for (int i = 1; i < n; i++) {
    cin >> in;
    Find[in] = ++cnt;
    insert(in);
  }
  cin >> m;
  while (m--) {
    f = 0;
    cin >> a >> t;
    if (t == "is") {
      cin >> t >> t;
      if (t == "root") {
        if (Find[a] == root) f = 1;
      } else if (t == "parent") {
        cin >> t >> b;
        if (Tree[Find[b]].parent == Find[a]) f = 1;
      } else if (t == "left") {
        cin >> t >> t >> b;
        if (Tree[Find[b]].lchild == Find[a]) f = 1;
      } else {
        cin >> t >> t >> b;
        if (Tree[Find[b]].rchild == Find[a]) f = 1;
      }
    } else {
      cin >> b >> t >> t;
      if (t == "siblings") {
        if (Find[a] && Find[b] && Tree[Find[a]].parent == Tree[Find[b]].parent)
          f = 1;
      } else {
        cin >> t >> t >> t;
        if (Find[a] && Find[b] && Tree[Find[a]].level == Tree[Find[b]].level)
          f = 1;
      }
    }
    cout << (f ? "Yes" : "No") << '\n';
  }
  return 0;
}
```

## L3-017 森森快递 (30 分)|==贪心|区间加+区间最小值=>线段树|不会写==

 

> 分析：每个路程受到其中最小承重量限制，不同的运输路线[a, b]，[c，d]之间有3种关系 
>
> 1. [a, b]与[c，d]无交集，则可以同时进行两个运输订单 
> 2. 如果一个路线包含于另一个路线中，那么选择少的那一段显然更优
> 3. [a, b]与[c，d]存在交集，交集为[c，b]，则能最大运输货物重量为min([c，b]，[a，c] + [b，d]。 
>
> 综上，我们可以将点坐标，按照==右端点从小到大==的顺序排列，相等的情况下，按照左端点从小到大的顺序排列。只需要建立一棵具有==区间加以及区间最小值的线段树==即可，符合结分配合律，故不需要lazy数组。遍历排序后的接线信息，每个路线取到最大运输货物后，减少本线路的通货承重量，即可得到最终答案～
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/121033975

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define Lx(a) (a << 1) + 1
#define Rx(a) (a << 1) + 2
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "##" << #x << ": " << x << "\n"

int n, m, Size;
ll ans, temp;
pair<int, int> B[100000];
struct segtree {
  vector<ll> values, mins;
  void init(int n) {
    Size = 1;
    while (Size < n) Size *= 2;
    values.assign(2 * Size, 0LL);
    mins.assign(2 * Size, 0LL);
    build(0, 0, Size, n);
  }
  void build(int x, int lx, int rx, int R) {
    if (rx - lx == 1) {
      if (lx < R) {
        cin >> mins[x];
        values[x] = mins[x];
      }
      return;
    }
    int mid = lx + rx >> 1;
    build(Lx(x), lx, mid, R);
    build(Rx(x), mid, rx, R);
    mins[x] = min(mins[Lx(x)], mins[Rx(x)]) + values[x];
  }
  void modify(int l, int r, int v, int x, int lx, int rx) {
    if (lx >= r || rx <= l) return;
    if (lx >= l && rx <= r) {
      mins[x] += v;
      values[x] += v;
      return;
    }
    int mid = lx + rx >> 1;
    modify(l, r, v, Lx(x), lx, mid);
    modify(l, r, v, Rx(x), mid, rx);
    mins[x] = min(mins[Lx(x)], mins[Rx(x)]) + values[x];
    return;
  }
  ll get_min(int l, int r, int x, int lx, int rx) {
    if (lx >= r || rx <= l) return LLONG_MAX;
    if (lx >= l && rx <= r) return mins[x];
    int mid = lx + rx >> 1;
    ll s1 = get_min(l, r, Lx(x), lx, mid);
    ll s2 = get_min(l, r, Rx(x), mid, rx);
    return min(s1, s2) + values[x];
  }
} st;
bool cmp(const pair<int, int> &a, const pair<int, int> &b) {
  if (a.second != b.second) return a.second < b.second;
  return a.first < b.first;
}
int main() {
  cin >> n >> m;
  st.init(--n);
  for (int i = 0; i < m; i++) {
    cin >> B[i].first >> B[i].second;
    if (B[i].first > B[i].second) swap(B[i].first, B[i].second);
  }
  sort(B, B + m, cmp);
  for (int i = 0; i < m; i++) {
    temp = st.get_min(B[i].first, B[i].second, 0, 0, Size);
    ans += temp;
    st.modify(B[i].first, B[i].second, -temp, 0, 0, Size);
  }
  cout << ans;
  return 0;
}
```

## L3-018 森森美图 (30 分)|BFS

难点之一：读懂题目

主要是在A和B的直线的两边分别 求出其最低分数和的曲线，最后相加便能得出结果（**注意A和B只能计算一次，所以最后要减去A和B一次）。**

至于怎么求最低分数和——就是求最短路径差不多吗——用BFS

**还有一个重点：**

> 忽略正好位于连接A和B的直线（**注意不是线段**）上的像素点）。如何判断三点是否在一个直线上很关键，这里采用三角的行列式公式，即用面积表示，当面积等于0，则其共线；

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define Lx(a) (a << 1) + 1
#define Rx(a) (a << 1) + 2
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "##" << #x << ": " << x << "\n"

#define inf 0x11111111;

struct Point {
  int x, y;
  double dis;
  //重载
  bool operator!=(const Point &c) const { return x != c.x || y != c.y; }
};
queue<Point> q;
int n, m;
double fdis[105][105];   //记录从开始点到每个点的最小值
double score[105][105];  //接收题目中各点的分数
Point A, B;              //起点和终点
int xa, ya, xb, yb;      //边界
int dir1[][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};    //上下左右的方向
int dir2[][2] = {{-1, -1}, {1, -1}, {-1, 1}, {1, 1}};  //斜的方向
bool tag;  // tag=1表示上半部分，tag=0表示下半部分

//三角形行列式公式
int cross(Point a, Point b, Point c) {
  return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}

void inque(Point p) {
  //有效值判断：是否在界内
  if (p.x < 1 || p.x > n || p.y < 1 || p.y > m) {
    return;
  }
  //不用更新最小值
  if (p.dis >= fdis[p.x][p.y]) {
    return;
  }
  if (tag) {
    //上半部分，但是包含起点和终点
    if (p != A && p != B && cross(A, B, p) <= 0) {
      return;
    }
  } else {
    //下半半部分，但是包含起点和终点
    if (p != A && p != B && cross(A, B, p) >= 0) {
      return;
    }
  }
  //到这里就说明 新值比旧值小
  fdis[p.x][p.y] = p.dis;  //更新
  //到终点时，就不继续将其入队
  if (p.x == B.x && p.y == B.y) {
    return;
  }
  q.push(p);
}

void bfs() {
  //清空队列
  while (!q.empty()) {
    q.pop();
  }
  //初始化
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      fdis[i][j] = inf;
    }
  }
  inque(A);
  while (!q.empty()) {
    Point now = q.front();
    q.pop();
    Point next;
    //计算上下左右方向
    for (int i = 0; i < 4; i++) {
      next.x = now.x + dir1[i][0];
      next.y = now.y + dir1[i][1];
      next.dis = fdis[now.x][now.y] + score[next.x][next.y];
      inque(next);
    }
    //计算斜方向
    for (int i = 0; i < 4; i++) {
      next.x = now.x + dir2[i][0];
      next.y = now.y + dir2[i][1];
      next.dis = fdis[now.x][now.y] + score[next.x][next.y] +
                 (score[next.x][next.y] + score[now.x][now.y]) * (sqrt(2) - 1);
      inque(next);
    }
  }
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> score[i][j];
      fdis[i][j] = inf;
    }
  }
  cin >> A.y >> A.x >> B.y >> B.x;
  //因为每从0开始，所以都加1，并且对其表示进行了转化
  A.x++, A.y++, B.x++, B.y++;
  A.dis = score[A.x][A.y];

  double ans = 0;
  tag = false;
  bfs();
  ans += fdis[B.x][B.y];  //上半部分
  tag = true;
  bfs();
  ans += fdis[B.x][B.y];  //下半部分
  printf("%.2f\n",
         ans - score[A.x][A.y] - score[B.x][B.y]);  //最后再减去重复的起点和终点
}
```

## L3-019 代码排版 (30 分)|==字符串模拟|写不出==

> point表示当前处理的文本位置，space储存但前需要在行首加多少空格，mark表示自动补充的大括号数量，use表示是否开启了大括号自动补充。在Function函数内，集成了'跳过无效空格'、'空格输出'、'关键字匹配'以及'补充的打括号补全'功能，很好用～
>
> 刚开始我们需要将int main ()部分单独输出，因为该部分可能存在不可移出的空格。然后对于剩下的主体部分，主要分成三个模块处理——'大括号匹配整理'、'关键字匹配整理'以及'其余代码匹配整理'。特别注意在有些关键字后面添加了代码没有自带大括号，需要自己去补全并记录相关数量信息。在space为0时结束程序，剩下的就是简单的模拟即可～
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/120784596

```cpp
#include <bits/stdc++.h>
using namespace std;
int point,      // point表示当前处理的文本位置
    space = 2,  // space储存但前需要在行首加多少空格
    mark,       // mark表示自动补充的大括号数量
    use,        // use表示是否开启了大括号自动补充
    tp, cnt, temp;

string s;
int Function(int c) {
  if (c == 0)
    while (s[point] == ' ') point++;
  else if (c == 1)
    for (int i = 0; i < space; i++) cout << ' ';
  else if (c == 2) {
    if (s.substr(point, 2) == "if" &&
        (s[point + 2] == '(' || s[point + 2] == ' '))
      return 2;
    else if (s.substr(point, 3) == "for" &&
             (s[point + 3] == '(' || s[point + 3] == ' '))
      return 3;
    else if (s.substr(point, 4) == "else" &&
             (s[point + 4] == '(' || s[point + 4] == ' '))
      return 4;
    else if (s.substr(point, 5) == "while" &&
             (s[point + 5] == '(' || s[point + 5] == ' '))
      return 5;
  } else if (c == 3) {
    Function(0);
    if (Function(2) == 4) return 0;
    while (mark) {
      space -= 2;
      Function(1);
      cout << "}\n";
      mark--;
    }
  }
  return 0;
}
int main() {
  getline(cin, s);
  Function(0);
  for (int i = point; s[i] != ')'; i++) cout << s[i];
  cout << ")\n{\n";
  point = s.find('{') + 1;
  while (1) {
    Function(0);
    temp = Function(2);
    if (s[point] == '{') {
      Function(1);
      cout << "{\n";
      space += 2;
      point++;
    } else if (s[point] == '}') {
      space -= 2;
      Function(1);
      cout << "}\n";
      if (space == 0) return 0;
      Function(3);
      point++;
    } else if (temp) {
      Function(1);
      cout << s.substr(point, temp);
      point += temp;
      if (temp != 4) {
        Function(0);
        tp = point;
        cnt = 0;
        while (tp < s.size()) {
          if (s[tp] == '(')
            cnt++;
          else if (s[tp] == ')')
            cnt--;
          tp++;
          if (cnt == 0) break;
        }
        cout << ' ' << s.substr(point, tp - point);
        point = tp;
      }
      cout << " {\n";
      space += 2;
      Function(0);
      if (s[point] != '{') {
        use = 1;
        mark++;
      } else {
        use = 0;
        point++;
      }
    } else {
      Function(1);
      cnt = s.find(';', point);
      cout << s.substr(point, cnt - point + 1) << '\n';
      point = cnt + 1;
      if (use && mark) {
        space -= 2;
        Function(1);
        cout << "}\n";
        mark--;
        Function(3);
      }
    }
  }
  return 0;
}
```



## L3-020 至多删三个字符 (30 分)|==DP==

- `dp[i][j]`表示前i个字符串在删除j个字符的情况下能取到多少种情况
- 第i个字符只有删除以及不能删除两种情况，可以得到`dp[i][j] = dp[i – 1][j] + dp[i – 1][j – 1]`（第i个字符不删，前i-1个字符删除掉j个再加上当前字符能取到的个数）+（第i个字符删了，前i-1个字符删除掉j-1个能取到的个数）
- 删掉不同位置的字符也可能会**产生一样的字符串**所以还需要：
  - 记录当前（下标为i）字符上一次==出现的位置last==（存在vis数组中），并判断`i与last的差是否大于等于目前的j`（这句话自己找例子感受一下），如果更多的话，就已经不可能受到影响了，故需要减去`dp[last – 1][j – (i – last)]`的数量。 最后将所有删减情况加起来，得到最终答案
  
    - sd==a==bc==a==d  删除abc和bca结果相同，只要对 第 i 个字符，向前找到等于它的第k个字符，删除重复的就行
  
      `dp[i][j] -= dp[k-1][j-(i-k)]`; 其中**`i-k`表示间隔长度**，由于最多删除3个字符，影响长度最多为3
      k也就是last

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
long long dp[1000001][4], vis[128], last;
int main() {
	cin >> s;
	for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
	for (int i = 1; i <= s.size(); i++) {
		last = vis[s[i - 1]];
		vis[s[i - 1]] = i;
		for (int j = 1; j <= 3; j++) {
			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
			if (last && j - (i - last) >= 0) dp[i][j] -= dp[last - 1][j - (i - last)];
		}
	}
	cout << dp[s.size()][0] + dp[s.size()][1] + dp[s.size()][2] + dp[s.size()][3];
	return 0;
}
```

## L3-021 神坛 (30 分)|==数学知识|计算几何|极角排序|向量叉积==

- 三角形的面积通过 向量的叉积来求，
  - $$S=abs[(x_a×y_b - x_b×y_a)×0.5]$$

- 枚举每个点， 对每个点进行**[极角排序](https://zhuanlan.zhihu.com/p/338272449)**： 先按象限排序，再按叉积排序。
  - 然后仅计算**相邻向量**组成的三角形面积

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 5050;

struct node {
  ll x, y;
  int rel;
} a[N], b[N];
int n;
bool cmp(node x, node y) {  //极角排序
  if (x.rel != y.rel) return x.rel < y.rel;
  return x.x * y.y - x.y * y.x < 0;
}
int judge(node x) {  //返回象限
  if (x.x > 0 && x.y > 0) return 1;
  if (x.x > 0 && x.y < 0) return 2;
  if (x.x < 0 && x.y < 0) return 3;
  if (x.x < 0 && x.y > 0) return 4;
}
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y;
  double ans = -1;
  int cnt;
  FOR(i, 1, n + 1) {
    cnt = 1;
    FOR(j, 1, n + 1) {
      if (i == j) continue;
      b[cnt].x = a[j].x - a[i].x;
      b[cnt].y = a[j].y - a[i].y;
      b[cnt].rel = judge(b[cnt]);
      cnt++;
    }
    sort(b + 1, b + n, cmp);
    FOR(j, 1, n - 1) {
      if (ans == -1 ||
          fabs(b[j + 1].x * b[j].y - b[j + 1].y * b[j].x) * 0.5 < ans)
        ans = fabs(b[j + 1].x * b[j].y - b[j + 1].y * b[j].x) * 0.5;
    }
  }
  printf("%.3f\n", ans);
  return 0;
}
```

## L3-022 地铁一日游 (30 分)|图论|搜索Floyd|==想不到==

- 所有票价都有一个2的基础，所以一开始可以都不加
- 相同的两个站点也可能有不同距离的路线，所以这里需要取最小值
- `Floyd`最短路算法求出两个站点之间最短的路线
- 再遍历出每个节点到达的所有距离需要多少花费，如果该花费是最小值，说明该站点可以拍照
- `dfs`，找出一个站点能以其他可换乘的车站作为中转点，可以到达的所有站点



```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 5050;
const int Mx = 1e9;
int N, M, K, Q, from, to, dis;
int Ter[201];  // Ter[i]==1表示第i个节点是两端的站点
int Edge[201][201];
map<int, set<int>> Station;  // Station中存储站点i直接能留下认证照的站点
map<int, set<int>> Ans;  // Ans中存储站点i最终能留下认证照的站点
void DFS(int Start, int Now) {
  for (auto it : Station[Now]) {
    if (Ans[Start].count(it)) continue;
    Ans[Start].insert(it);
    DFS(Start, it);
  }
}
int main() {
  for (int i = 1; i <= 200; i++)
    for (int j = 1; j <= 200; j++) Edge[i][j] = Mx;
  scanf("%d %d %d", &N, &M, &K);
  while (M--) {
    scanf("%d", &from);
    Ter[from] = 1;
    while (1) {
      scanf("%d %d", &dis, &to);
      Edge[from][to] = Edge[to][from] = min(Edge[from][to], dis);
      from = to;
      if (getchar() == '\n') break;
    }
    Ter[to] = 1;
  }
  // FLoyd
  for (int k = 1; k <= N; k++)
    for (int i = 1; i <= N; i++)
      for (int j = 1; j <= N; j++)
        if (i != j) Edge[i][j] = min(Edge[i][j], Edge[i][k] + Edge[k][j]);
  for (int i = 1; i <= N; i++) {  //枚举每个站点
    map<int, int> Fur_Dis;  // Fur_Dis中存储每个花费下能到达的最远距离
    Ans[i].insert(i);
    for (int j = 1; j <= N; j++) {
      //枚举i站点能到达的站点
      if (Edge[i][j] != Mx) {
        //是端点的话也放进去
        if (Ter[j] == 1) Station[i].insert(j);
        if (Edge[i][j] > Fur_Dis[Edge[i][j] / K])
          Fur_Dis[Edge[i][j] / K] = Edge[i][j];
      }
    }
    for (int j = 1; j <= N; j++)
      //一定花费下能到达最远的地方
      if (Edge[i][j] == Fur_Dis[Edge[i][j] / K]) Station[i].insert(j);
  }
  for (int i = 1; i <= N; i++) DFS(i, i);
  scanf("%d", &Q);
  while (Q--) {
    scanf("%d", &from);
    for (auto it : Ans[from])
      printf("%d%c", it, (it != *Ans[from].rbegin()) ? ' ' : '\n');
  }
  return 0;
}
```

## L3-023 计算图 (30 分)|==搜索|dfs|复杂模拟|不会==

[liuchuo](https://blog.csdn.net/liuchuo/article/details/120785035?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164761267316780366589495%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164761267316780366589495&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120785035.nonecase&utm_term=L3-023+%E8%AE%A1%E7%AE%97%E5%9B%BE+%2830+%E5%88%86%29&spm=1018.2226.3001.4450)

## L3-024 Oriol和David (30 分)|无题解

-

## L3-025 那就别担心了 (30 分)|记忆化搜索

关键在`num[i]`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 505;
int n, m, a, b, st, fi, flag,
    // num[i]储存从第i个命题到 fi 命题有多少种不同的推理路径
    // num[fi]的初始值为1
    num[502];
vector<int> v[502];
int dfs(int idx) {
  // !=0 就说明已经搜过了 直接返回即可
  if (num[idx] != 0) return num[idx];
  for (int nxt : v[idx]) {
    if (num[nxt] == 0) dfs(nxt);
    num[idx] += num[nxt];
  }
  //到这个点后 没得往下搜了 说明无法自洽
  if (num[idx] == 0) flag = 1;
  return num[idx];
}
int main() {
  cin >> n >> m;
  for (int i = 0; i < m; ++i) {
    cin >> a >> b;
    v[a].push_back(b);
  }
  cin >> st >> fi;
  num[fi] = 1;
  dfs(st);
  cout << num[st] << ' ' << (flag ? "No" : "Yes");
  return 0;
}
```



## L3-026 传送门 (30 分)|==splay平衡树|不会==

-

## L3-027 可怜的复杂度 (30 分)|好像也还没题解

-

## L3-028 森森旅游 (30 分)|Dijskra|==晕==

> 分析：主体思路是，用Dijskra最短路算法分别算出:
> 1.使用现金从城市1出发，到达所有城市的最小花费（储存在cashD内）
> 2.使用旅游金从城市n出发，到达所有城市的最小花费（储存在voucherD内）
> 这样我们就能通过枚举中转点的方式，得到在第i个城市将现金换成旅游金的情况下所需要的现金总额～就是使用从城市1到达第i个城市所需要的最小现金数 + 从第i个城市到城市n所需要的最小旅游金数所转换成的现金数量，就可以得到在第i个城市兑换所需要的总现金费用，储存在tran[i]内～
> huan[i]中储存第i个城市的汇率，cashE[i]和voucherE[i]中储分别储存使用现金和旅游金到达i可下一个城市的花费。最后将所有中转点所要用的花费储存在一个可以有重复值的multiset容器 minCost 中。最后在更新汇率时，将更新前花费从 minCost 中删除，并插入新值，然后输出 minCost 中的最小值就是答案啦～
>
> 注意：如果某点使用现金或旅游金不可达，那么该点的tran值则设置为0，在更新时该点也无需操作～
> ————————————————
> 版权声明：本文为CSDN博主「柳婼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/liuchuo/article/details/118843047

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 100005;
#define pil pair<int, long long>
struct node {
  int id;
  long long dis;
  friend int operator<(const node &a, const node &b) { return a.dis > b.dis; }
};
int n, m, q, u, v, xi, vis1[N], vis2[N];
long long c, d, w, ai, huan[N], cashD[N], voucherD[N], tran[N];
vector<pil> cashE[N], voucherE[N];
multiset<long long> minCost;
priority_queue<node> Q;
void Dijskra(int s, vector<pil> E[], long long Dis[], int Vis[]) {
  fill(Dis + 1, Dis + n + 1, LLONG_MAX);
  Dis[s] = 0;
  Q.push(node{s, 0});
  while (!Q.empty()) {
    int now = Q.top().id;
    Q.pop();
    if (Vis[now]) continue;
    Vis[now] = 1;
    for (int i = 0; i < (int)E[now].size(); ++i) {
      v = E[now][i].first;
      w = E[now][i].second;
      if (Dis[v] > Dis[now] + w) {
        Dis[v] = Dis[now] + w;
        Q.push(node{v, Dis[v]});
      }
    }
  }
}
int main() {
  scanf("%d%d%d", &n, &m, &q);
  for (int i = 0; i < m; i++) {
    scanf("%d%d%lld%lld", &u, &v, &c, &d);
    cashE[u].push_back({v, c});
    voucherE[v].push_back({u, d});
  }
  for (int i = 1; i <= n; i++) scanf("%lld", &huan[i]);
  Dijskra(1, cashE, cashD, vis1);
  Dijskra(n, voucherE, voucherD, vis2);
  for (int i = 1; i <= n; i++) {
    if (cashD[i] == LLONG_MAX || voucherD[i] == LLONG_MAX) continue;
    minCost.insert(tran[i] = cashD[i] + (voucherD[i] + huan[i] - 1) / huan[i]);
  }
  for (int i = 0; i < q; i++) {
    scanf("%d%lld", &xi, &ai);
    if (!tran[xi] || huan[xi] == ai) {
      printf("%lld\n", *minCost.begin());
    } else {
      minCost.erase(minCost.find(tran[xi]));
      huan[xi] = ai;
      minCost.insert(tran[xi] =
                         cashD[xi] + (voucherD[xi] + huan[xi] - 1) / huan[xi]);
      printf("%lld\n", *minCost.begin());
    }
  }
  return 0;
}
```



## L3-029 还原文件 (30 分)|DFS

DFS从没有切碎的纸片最左端开始尝试所有纸条碎片的匹配，p表示当前所需要匹配的碎片左侧在未碎纸片上的位置，将匹配上的纸条碎片编号添加到Ans中记录，并使用vis标记是否已经匹配上了，如果Ans的容量等于纸片数量，则表示已经完成所有匹配

每个小纸片依次和缺口位置对比，感觉比有的二阶题容易。

**注意有状态的转移（路径存储）——需要回溯**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;
vector<int> v[105], ans, tmp;
int n, m, k, h, H[N], flag, vis[N];
void dfs(int pos) {
  if (pos == n || flag) {
    ans = tmp;
    flag = 1;
    return;
  }
  FOR(i, 1, m + 1) { //枚举每一张碎纸
    if (vis[i]) continue;
    bool fg = 0;
    FOR(j, 1, v[i].size()) {
      if (H[pos + j] != v[i][j]) {//比对每一个接口
        fg = 1;
        break;
      }
    }
    if (fg) continue; //有对不上的就过
    vis[i] = 1;
    tmp.push_back(i);
    dfs(pos + v[i].size() - 1);
      //回溯
    vis[i] = 0;
    tmp.pop_back();
  }
}
int main() {
  cin >> n;
  FOR(i, 1, n + 1) cin >> H[i];
  cin >> m;
  FOR(i, 1, m + 1) {
    cin >> k;
    while (k--) {
      cin >> h;
      v[i].push_back(h);
    }
  }
  dfs(1);//从半张纸的第一个口开始试
  FOR(i, 0, ans.size()) {
    if (i) cout << " ";
    cout << ans[i];
  }
  system("pause");
  return 0;
}
```



## L3-030 可怜的简单题 (30 分)|数学

-

