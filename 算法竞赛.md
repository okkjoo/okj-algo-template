> 
>
> 准备三四月份蓝桥杯的笔记

# 说在前面的套路

时间限制：C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过10^8,则可能会超时

- **由数据范围反推算法复杂度以及算法内容**

![image-20211210112521113](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

- 若输入输出 范围 小于 105 推荐用 `cin / cout` 否则用 `scanf / printf` 输入时间会快一倍左右

# 题目

## 异或的妙用

### [116. 飞行员兄弟|DFS|位运算|暴力枚举](https://www.acwing.com/problem/content/118/)

- 矩阵
- 变一个位置就是变一个十字
- 先级整体从上到下，同行从左到右打开——先看第一行...

=>

- 暴力枚举——位运算 （这个看起来更聪明点🐶）
  - 也可以DFS+直接操作字符数组

- 用一个十六位的二进制数模拟棋盘状态：0~2^16-1
  - 解题思路：这道题目解题思路大致是，首先我们可以构造一个16位的二进制数，然后呢，二进制数的每一位代表4*4矩阵中的一位，例如1代表(1,1),2代表(1,2),3代表(1,3),4代表(1,4),5代表(2,1)。既然这样的话，那么我们只需要枚举这个16位的二进制数，就可以确定我们的方案，因为题目只需要最优解方案，所以时间复杂度大约是O(16 * 2^16)
- get 获得位数
- change 通过**异或**操作进行反转开关操作
  - 01互相反转 == 与1异或

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

/*  DFS+直接操作字符数组
typedef pair<int,int> PII;
PII ans[20],cur[20];
char c[6][6];
int sum;
void turn(int x,int y)
{       for(int i=0;i<4;i++)
        {
            if(c[i][y]=='+') c[i][y]='-';
            else  c[i][y]='+';
        }
        for(int i=0;i<4;i++)
        {
            if(c[x][i]=='+') c[x][i]='-';
            else  c[x][i]='+';
        }
         if(c[x][y]=='+') c[x][y]='-';
            else  c[x][y]='+';
}
bool check(char c[][6])
{   for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
        if(c[i][j]=='+')
           return false; 

     return true; 

}
void dfs(int x,int y,int res){
        if(x==4)
        {
            if(check(c)&&res<sum)
            {   
            	memcpy(ans,cur,sizeof(ans));
                sum=res;
            }
            return;
        }
        int dx=x,dy=y+1;
        if(dy==4){
            dx++,dy=0;
        }
        turn(x,y);
        cur[res+1]={x,y};
        dfs(dx,dy,res+1);
        turn(x,y);
        dfs(dx,dy,res);


}
int main()
{   for(int i=0;i<4;i++)  cin>>c[i];
    sum=0x3f3f3f3f;
    dfs(0,0,0);
    cout<<sum<<endl;
    for(int i=1;i<=sum;i++)
    {
        cout<<ans[i].first+1<<" "<<ans[i].second+1<<endl;
    }


    return 0;
}
 */


int change[4][4];
int get(int x, int y){//获取位数
	return x*4 + y;
}
int main(){
	int state = 0;//起始棋盘状态
	for(int i =0 ; i<4; i++){
		string line;
		cin>>line;
		for(int j = 0;j<4;j++){
			if(line[j] == '+')
				state += 1 << get(i,j);			
		}
	} 

	//预处理
	for(int i = 0; i < 4; i++)
	for(int j =0; j < 4; j++){
		for(int k=0; k < 4; k++){
			change[i][j] += 1<<get(i, k);
			change[i][j] += 1<<get(k, j);
		}
		change[i][j] -= 1<<get(i, j);//行列操作后多操作了一次，要减去
	}
	vector<PII> res;
	for(int k = 0;k< 1<<16; k++){//暴力遍历 0~10^16，即全部的反转方法（不一定是能打开冰箱的）
		int now = state;//存一下当前局面
		vector<PII> path;//注意path定义在这里也就具有了重置path的方法
		for(int i =0; i<16; i++){//如果k的某一位是1，就表示需要操作
			if((k >>i)& 1){
				//对编号是i的格子进行操作
				int x = i/4, y = i%4;//找到他的行列位置
				now ^= change[x][y];
				path.push_back({x, y});
			}
			if(!now && (res.empty()|| res.size() >path.size())){
			//全0说明合法 && （原先res为空 || 新的方法步骤更少）
				res = path;
			}
		}
	}
	cout<<res.size()<<endl;
	for(auto p:res)cout<< p.first+1<<" "<<p.second+1<<endl;
}
```

## 二分

### [AcWing789.数的范围](https://www.acwing.com/problem/content/791/)|二分

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, q, x;
int a[100005];
int main(){
	scanf("%d%d",&n,&q);
	for(int i =0 ;i<n;i++){
		scanf("%d",&a[i]);
	}
	while(q--){
		scanf("%d",&x);
		int l = 0, r = n;
		//搜左边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) r = mid;//找到了收缩右边以达到找到左边界的效果
			else if(a[mid] < x) l = mid + 1;
			else if(a[mid] > x) r = mid;
		}
		if(a[l] != x) {printf("-1 -1\n");continue;}
		int left = l;
		r = n;
		//搜右边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) l = mid+1;//收缩左边以达到找到右边界的效果
			else if( a[mid] < x) l = mid + 1;
			else if( a[mid] > x) r = mid;
		}
		printf("%d %d\n",left,l-1);
		//因为l = mid+1; 退出来时l在mid+1上，而需要返回mid即mid-1
	}
}
```

### [AcWing790.数的三次方根](https://www.acwing.com/problem/content/792/)|二分

> 给定一个浮点数 n ，求它的三次方根。
>
> #### 输入格式
>
> 共一行，包含一个浮点数 n。
>
> #### 输出格式
>
> 共一行，包含一个浮点数，表示问题的解。
>
> 注意，结果保留 6位小数。
>
> #### 数据范围
>
> −10000≤n≤10000

直接二分搜索一个mid满足`mid*mid*mid`最接近n的——最接近就是误差小于`1e-8`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

double x;

int main(){
  cin>>x;
  double l = -10000, r = 10000;
  while(r-l > 1e-8){//精度还不够的话
    double mid = (l+r)/2;
    if(mid*mid*mid >= x) r = mid;
    else l = mid;
  }
  printf("%.6lf",l);
}
```

- 使用cbrt函数也是可以的
- 或者pow——要先处理一下负数

```cpp
int main(){
    double a;
    scanf("%lf",&a);
    //if(x<0) printf("-") ,x=-x;
    //printf("%.6lf",pow(x,1/3.0));  // pow不能处理负数
    printf("%.6lf",cbrt(a));
    return 0;
}
```

### [AcWing1221.四平方和](https://www.acwing.com/problem/content/1223/)|二分

> 四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多 4个正整数
> 的平方和。如果把 0包括进去，就正好可以表示为 4个数的平方和。比如：
>     5=0^2+0^2+1^2+2^2
>     7=1^2+1^2+1^2+2^2
> 对于一个给定的正整数，可能存在多种平方和的表示法。要求你对 4个数排序：0≤a≤b≤c≤d
> 并对所有的可能表示法按 a,b,c,d为联合主键升序排列，最后输出第一个表示法。

**四重循环优化为三重循环**

此时时间复杂度为O(N^3)——(5\*10^6)^3>>10^8，数据强的时候就过不了了。所以循环最多二重

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()  
{  
    int n,a,b,c,d;  
    scanf("%d",&n);   
    int sqn = int(sqrt(n));
    for(a=0;a<=sqn;++a)  
    {  
        for(b=a;b<=sqn;++b)  
        {  
            for(c=b;c<=sqn;++c)  
            {  
                d=sqrt(n-a*a-b*b-c*c); //这里减少一重循环 
                if(n==a*a+b*b+c*c+d*d)  
                {  
                    if(c>d)swap(d,c);
                    printf("%d %d %d %d\n",a,b,c,d);  
                    return 0;  
                }   
            }   
        }   
    }   
}

```

**优化循环为二重+利用二分**

预处理c、d且存下来

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 25e5 + 10;

struct Sum
{
    int s, c, d; // s表示c和d的平方
    bool operator<(const Sum& t) const //返回较小的那个
    {
        if(s != t.s) return s < t.s;
        if(c != t.c) return c < t.c;
        return d < t.d;
    }
} sum[N];

int n, m;

int main(void)
{
    scanf("%d", &n);

    for(int c = 0; c * c <= n; c++)
        for(int d = c; c * c + d * d <= n; d++) sum[m++] = {c * c + d * d, c, d};

    sort(sum, sum + m);

    for(int a = 0; a <= n; a++)
        for(int b = 0; b * b + a * a <= n; b++)
        {
            int t = n - a * a - b * b;
            int l = 0, r = m - 1;
            while(l < r)
            {
                int mid = l + r >> 1;
                if(sum[mid].s >= t) //要找一个最小的 所以是>=
                    r = mid;
                else
                    l = mid + 1;
            }
            if(sum[l].s == t)
            {
                printf("%d %d %d %d\n", a, b, sum[l].c, sum[l].d);
                return 0;
            }
        }
    return 0;
}

```



**优化循环为二重：优化枚举：哈希+枚举**

> 减少枚举次数
> 确定枚举范围：
> a 0–sqrt(510^6/4)  : a a a a
> b 0–sqrt(510^6/3)  : 0 b b b 
> c 0–sqrt(510^6/2)  : 0 0 c c
> d 0–sqrt(510^6)	 : 0 0 0 d
>
> 预先求出R=c^2+d^2的解 用**哈希表unordered_map**来保存一个R对应的c

利用哈希表存储预处理的c、d，后面直接拿来操作——封装好的unordered_map 中的查询函数效率肯定不必自己写的二分差的。

**但这个会超时——我不理解，这时间复杂度不是O(N^2)吗**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n;
unordered_map<int, PII> mp;
int main(){
  cin>>n;
  for(int c =0;c*c<=n/2; c++) //c的枚举范围优化
    for(int d = c; d*d+c*c <= n; d++){//d>=c所以直接从c开始
      int t = c*c + d*d;
      if(mp.count(t) == 0) mp[t] = {c, d};//没有就存；有了的话，顺序也排在后面，没必要存
    }

  for(int a = 0; a*a <= n/4; a++){//优化枚举范围
    for(int b = a; a*a+b*b<=n/2; b++){//这里同样可以优化枚举范围
      int t = n - a*a-b*b;
      if(mp.count(t)){
        cout<<a<<" "<<b<<" "<<mp[t].first<<" "<<mp[t].second;
        //输出第一个就可以了
        return 0;
      }
    }
  }
}
```

**优化循环+优化枚举+数组打表代替哈希表**

感觉两个原理差不多，不知道为什么上面那个复杂度会超，有懂的吗。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
const int N = 1e8 + 10;
int h[N];
int main() {
    int n;
    cin >> n;
    //打表 
    for (int c = 0; c * c * 2<= n; c++) {    //优化了枚举范围
        for (int d = c; d * d + c * c <= n; d++) {
            if (!h[c * c + d * d])//之前没记录过
                h[c * c + d * d] = c + 1;//标记，防止i = 0时在后面判断查找跳过 i = 0的情况
        }
    }
      
    for (int a = 0; a * a * 4 <= n; a++) {     //优化了枚举范围
        for (int b = a; b * b + a * a <= n / 2; b++) {
            int t = n - a * a - b * b;
            if (h[t]) {
                int c = h[t] - 1;   //恢复标记
                //防止开根号后因为精度关系,向下取整,例:25 开根号得到4.99999向下取整为4;
                int d = (sqrt(t - c * c) + 1e-4);
                printf("%d %d %d %d", a, b, c, d);
                return 0;
            }
        }
    }
    return 0;
}

```



---

## 前缀和

**一维前缀和**

![image-20211211210344450](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211210344450.png)

### [AcWing795.前缀和](https://www.acwing.com/problem/content/797/)

> 输入一个长度为n的整数序列。
>
> 接下来再输入m个询问，每个询问输入一对l, r。
> 对于每个询问，输出原序列中从第l个数到第r个数的和。
>
> 输入格式
> 第一行包含两个整数n和m。
>
> 第二行包含n个整数，表示整数数列。
>
> 接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。
>
> 输出格式
> 共m行，每行输出一个询问的结果。
>
> 数据范围
> 1≤l≤r≤n,
> 1≤n,m≤100000,
> −1000≤数列中元素的值≤1000

<img src="https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211211040800.png" alt="image-20211211211040800" style="zoom:80%;" />

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)\

const int N = 1e5+10;
int a[N], sum[N];
int main(){
  int n, m;
  cin>>n>>m;
  for(int i =1;i<=n;i++){
    cin>>a[i];
    sum[i] = a[i] + sum[i-1];    
  }
  while(m--){
    int l, r;
    cin>>l>>r;
    cout<<sum[r] - sum[l-1]<<endl;
  }
}
```

**二维前缀和**

<img src="https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211211212444311.png" alt="image-20211211212444311" style="zoom:80%;" />

### AcWing 796.子矩阵的和

> 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。
>
> 对于每个询问输出子矩阵中所有数的和。
>
> #### 输入格式
>
> 第一行包含三个整数n，m，q。
>
> 接下来n行，每行包含m个整数，表示整数矩阵。
>
> 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。
>
> #### 输出格式
>
> 共q行，每行输出一个询问的结果。
>
> #### 数据范围
>
> 1≤n,m≤1000,
> 1≤q≤200000,
> 1≤x1≤x2≤n,
> 1≤y1≤y2≤m,
> −1000≤矩阵内元素的值≤1000



```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e3+10;
int a[N][N], s[N][N];
int main(){
  int  n, m , q;
  cin>>n>>m>>q;
  for(int i =1;i<=n;i++)
    for(int j = 1;j<=m;j++)
      cin>>a[i][j];
  
  for(int i = 1; i<= n; i++)
    for(int j = 1;j <=m; j++)
      s[i][j] = s[i-1][j]+s[i][j-1] - s[i-1][j-1]  + a[i][j];//注意减去重叠导致的多余部分

  int x1, y1, x2, y2;
  while(q--){
    cin>>x1>>y1>>x2>>y2;
    int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];//画个图就知道了
    cout<<res<<endl;
  }
}
```

### [AcWing1230.K倍区间](https://www.acwing.com/problem/content/1232/)|前缀和

1. sum[i]表示第1个元素到第i个元素
2. sum[r] - sum[l-1]就是区间[l,r]的和
3. 区间[l,r]的和是k的倍数即(sum[r] - sum[l-1])%k == 0
4. **sum[r]%k == sum[l-1]%k**

所以在求 sum 时就进行取模，最后有**两个**相等的**前缀和%k**区间就可以形成一个 **K倍区间**。——如共有5个前缀和%k==1的，可以从里面选任意两个的组合数就是**前缀和%k==1 的K倍区间数**。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5+10;
ll s[N];//前缀和数组
int cnt[N];//cnt[x]： 前缀和%k 为x 的个数
ll res = 0;//最后的答案

int main(){
  int  n, k;
  cin>>n>>k;
  for(int i = 1; i<=n; i++){
    cin>>s[i];
    s[i] += s[i-1];
  }
  cnt[0]++;//s[0]放进去
    //后面再有s[i]%k==0 的时候，前面这个s[0]就可以认为是该区间的左端点。
  //这一步的目的是当[1,i]区间累加成的数，也就是s[i]是k的倍数。那么区间[1，i]也是一个k倍区间，但是需要前面有一个点作为这个区间的左端点。而此时s[i]%k进行取余等于0，所以将cnt[0]++;
    
  for(int i = 1; i<=n; i++){
    res += cnt[s[i] % k];
    cnt[s[i]%k] ++;
  }
  cout<<res;
}
```

## 差分

**一维差分**

给你一串**长度为n**的数列a1,a2,a3......an，要求**对a[L]~a[R]进行m次操作**：

操作:将a[L]~a[R]内的元素都加上c
最后再给出一个询问求a[L]-a[R]内的元素之和？

对于m次操作每次都遍历一遍a[L]~a[R],给区间里的数都加上c或减去c，最后再求一次前缀和——这样子确实也能得出正确答案，但时间复杂度却**高达O(M*n)**，对于1<=n,m<=1e5这个数据范围来说就超时了。

**差分：**我们新开一个数组d,`d[i]=a[i]-a[i-1]`，**储存每一次的修改操作**，**最后**求前缀和一次计算就能获得正确答案。**差分可以看成前缀和的逆运算**

---

```cpp
int a[N];//原数组
int d[N];//差分数组
int s[N];//前缀和数组
void insert(int l, int r, int c){
  d[l] += c;  //修改了[l,n-1]
  d[r+1] -= c; //撤销[r+1, n-1]的修改
}
```





---



### [Acwing  797. 差分](https://www.acwing.com/problem/content/description/799/)

> 输入一个长度为  n 的整数序列。
>
> 接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r][l,r] 之间的每个数加上 c。
>
> 请你输出进行完所有操作后的序列。
>
> #### 输入格式
>
> 第一行包含两个整数 nn 和 mm。
>
> 第二行包含 nn 个整数，表示整数序列。
>
> 接下来 mm 行，每行包含三个整数 l，r，cl，r，c，表示一个操作。
>
> #### 输出格式
>
> 共一行，包含 nn 个整数，表示最终序列。
>
> #### 数据范围
>
> 1≤n,m≤1000001≤n,m≤100000,
> 1≤l≤r≤n1≤l≤r≤n,
> −1000≤c≤1000−1000≤c≤1000,
> −1000≤整数序列中元素的值≤1000

```CPP
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5+10;
int a[N], d[N];
int n, m;
void insert(int l, int r, int c){
  d[l] += c;
  d[r+1] -= c;
}

int main(){
  cin>>n>>m;
  for(int i = 1; i<=n;i++){
    cin>>a[i];
    d[i] = a[i]-a[i-1];//构建差分数组，a[0] = 0
  }
  int  l, r, c;
  while(m--){
    cin>>l>>r>>c;
    insert(l, r, c);
  }
  for(int i = 1;i<=n;i++){
    a[i] = a[i-1] + d[i]; //前缀和运算
    cout<<a[i]<<" ";
  }
}
```

**二维差分**

和一维前缀和与二维前缀和的关系差不多

**给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：**

```cpp
void insert(int x1,int y1,int x2,int y2,int c){
    d[x1][y1]+=c;
    d[x1][y2+1]-=c;
    d[x2+1][y1]-=c;
    d[x2+1][y2+1]+=c;
}

//前缀和运算
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
         b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
```

## 枚举

### [AcWing1210.连号区间数](https://www.acwing.com/problem/content/1212/)

> 在 1∼N 的某个排列中有多少个连号区间呢？
>
> 这里所说的连号区间的定义是：
>
> 如果区间 `[L,R][L,R]` 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+1 的“连续”数列，则称这个区间连号区间。
>
> 当 N很小的时候，小明可以很快地算出答案，但是当 N 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

就是给出1~n但是是有顺序的，然后在里面截取一段`[l,r]`拿出来排序后从小到大是连续的，则合法；否则不。**特殊情况：l==r时也是连续的**

那么就用两层循环，i表示左端点，j表示右端点；并且要求连续，那么就是区间中最大值-最小值等于区间长度。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
  
int a[100005];
int mn, mx;
int res = 0;
int main(){
  int n;
  cin>>n;
  for(int i = 0;i <n;i++){
    cin>>a[i];
  }
  for(int i = 0; i < n; i++){
    mn = INT_MAX;
    mx = INT_MIN;
    for(int j = i;j <n; j++){
      mx = max(mx, a[j]);
      mn = min(mn, a[j]);
      if((mx - mn) == (j - i)) res++;
    }
  }
  cout<<res;
}
```

### [AcWing1236.递增三元组](https://www.acwing.com/problem/content/1238/)|枚举|二分|前缀和|双指针

这题的数据 1e5 ，显然需要复杂度小于等于 O(nlogn)的

1. 暴力：三个数组循环嵌套；n^3 ❌
2. 优化枚举：A中寻找小于B[i]的个数acnt，C中寻找大于B[i]的个数ccnt, acnt\*ccnt，那么带有B[i]的合法选择数就是acnt\*cnt；n^2 ❌
3. 再优化查找：预处理三个数组,使其具有顺序,排序时间复杂度O(nlogn)。枚举B＋二分查找A、C中的元素，O(nlogn)。

小技巧：

1. 排序直接用sort函数
2. 二分查找直接用low_bound、upper_bound(返回迭代器，与数组的第一个迭代器相减就是找到的第一个数的下标)

> 借助输出结果可以看出，upper_bound() 函数的功能和 lower_bound() 函数不同，前者查找的是大于目标值的元素，而后者查找的不小于（大于或者等于）目标值的元素。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N =1e5+10;
int a[N], b[N], c[N];
int main(){
  int n;scanf("%d",&n);
  FOR(i,0,n) scanf("%d",&a[i]);
  FOR(i,0,n) scanf("%d",&b[i]);
  FOR(i,0,n) scanf("%d",&c[i]);
  
  //排序预处理
  sort(a,a+n);
  sort(b,b+n);
  sort(c,c+n);

  ll ans = 0;

  //枚举B
  for(int i = 0 ; i < n; i++){
    int bkey = b[i];
    //找A中第一个不小于key的数的下标
    int pa = lower_bound(a, a + n, bkey) -  a;
    //找C中第一个大于key的数的下标
    int pc= upper_bound(c, c + n, bkey) - c;
    if(pa >= 0 && pc < n){
      ans += (ll)(pa)*(n-pc);
    } 
  }
  printf("%lld",ans);
}
```

**双指针**

进一步对查找进行优化，对于**排过序的数组A和B，寻找A中小于B[i]的元素的个数**可以考虑双指针算法，因为每个指针最多移动n次，故查找的时间复杂度降到O(n)，查找C与查找A同理，只是找第一个大于B的位置。

将其中的二分部分直接改成用指针从下标为0的地方开始比。但此时因为排序的时间复杂度还是为O(nlogn)，所以总的时间复杂度还是O(nlogn).

**前缀和**

排序的时间复杂度是一个瓶颈，那么就思考怎么不排序完成目标。

不排序快速找到A中小于B[i]的个数：将A中所有数出现的个数存储在一个和哈希表中，因为数据较小所以可以直接开一个cnta数组作为哈希表：cnt[i]表示A中i的个数。枚举B时直接**找小于B[i]的所有元素的总和**（找总和这一步可以**借助前缀和**）即可；找C中大于B[i]的个数也同理。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N =1e5+10;
 

int A[N], B[N], C[N];
int cnta[N], cntc[N], sa[N], sc[N];
int main(){
  int n;scanf("%d", &n);
  //每一项都要+1，相对大小不变。防止*处后面越界
  //数i在A中有cnta[i]个
  FOR(i,1,n+1){
    scanf("%d", &A[i]);
    cnta[++A[i]]++;
  }
  FOR(i,1,n+1){
    scanf("%d", &B[i]);
    ++B[i];
  }
  FOR(i,1,n+1){
    scanf("%d", &C[i]);
    cntc[++C[i]]++;
  }
  //对cnta、cntc求前缀和
  sa[0] = cnta[0], 
  sc[0] = cntc[0];
  FOR(i, 1, N+1){ sa[i] = sa[i-1] + cnta[i];}
  FOR(i, 1, N+1){ sc[i] = sc[i-1] + cntc[i];}
  //遍历B
  ll ans = 0;
  FOR(i, 1, n+1){
    int b = B[i];
    //sa[b-1]： A中小于等于b-1的个数即小于b的个数；   sc[N-1] - sc[b]：C中大于b的个数
    ans += (ll)sa[b-1]*(sc[N-1] - sc[b]); //*    sa[b-1]如果B中有个数是0，前面不预处理 加一 就会报错了
    //还有要注意的是，要先转换第一个数为longlong，相乘完再转换有一个样例过不去
  }
  printf("%lld",ans);
}
```

## 模拟、排序

### [AcWing1245.特别数的和](https://www.acwing.com/problem/content/1247/)|模拟|easy

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

ll res = 0;
int main(){
    int n;cin>>n;
    FOR(i,1,n+1){
        int x = i;
        while(x){
            int t = x%10;
            x /= 10;
            if(t == 2 | t == 0 | t == 1| t == 9){
                res += i;
                break;
            }
        }
    }
    cout<<res;
}
```

### [AcWing1204.错误票据](https://www.acwing.com/problem/content/1206/)|模拟|排序

难点主要在于这里：

>  接下来 N行，每行包含空格分开的若干个

这意味着需要处理：什么时候输入完了。

借助 stringstream 可以完美解决。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5+10;
int a[N];
int main(){
  int n;cin>>n;
  int idx = 0;//数组下标
  string line;
  getchar();//把行数后面这个回车吃了
  while(n--){
    getline(cin, line);
    stringstream ssin(line);//输入流
    while(ssin >> a[idx]) idx++;
  }
  sort(a, a+idx);//排序，方便后面查重
  int res1, res2;
  // FOR(i,0,idx)cout<<a[i]<<" ";
  // cout<<endl;
  FOR(i, 1, idx){
    if(a[i] > a[i-1] + 2) res1 = a[i]-1;//断号
    if(a[i] == a[i-1])res2 = a[i];//重号
  }
  cout<<res1<<" "<<res2;
}
```

### [AcWing466.回文日期](https://www.acwing.com/problem/content/description/468/)|枚举|模拟

**直接暴力**：最大的时候10^8\*8过不了的

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

bool isPalind(int x){
  string s = to_string(x);
  FOR(i, 0, 4){
    for(int j = 7;i>=4;j--){
      if(s[i]!=s[j])return false;
    }
  }
  return true;
}
int res = 0;
int main(){
  int a,b;
  cin>>a>>b;
  for(int i = a;i<=b;i++){
    if(isPalind(i))res++;
  }
  cout<<res;
}
```

**逆向思考：** 其实**只用枚举左半边**，也就是1000~9999总共在九千个数字
然后再判断

- 对称后构成的日期是否合法
- 是否在范围之内

判断计算量为常数，所以复杂度也只有O(9000).

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

//每个月份的天数别搞错了，二月就先默认28，后面再判断闰年
int months[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

//判断日期是否合法
bool check(int date){  
  int year = date/10000;
  int month = date%10000/100;
  int day = date%10000%100;

  if(!month || month>= 13 || !day || day >31) return false;

  if(month != 2 && day > months[month]) return false;
  if(month == 2) {
    //判断闰年特殊情况
    bool leap = year%4 == 0 && year%100 >0  || year%400 == 0;
    if(day > 28 + leap) return false;
  }
  return true;
}

int main(){
  int d1, d2;cin>>d1>>d2;
  int res = 0;
  for(int i = 1000; i <= 9999; i++){
    //构造一个回文数字串
    int x = i, tmp = i;
    for(int j = 0; j<4;j++) x = x*10 + tmp%10, tmp/=10;
    if(x >= d1 && x<=d2 && check(x)) res++;
  }
  cout<<res;
}
```



### [AcWing1219.移动距离](https://www.acwing.com/problem/content/1221/)|模拟

曼哈顿距离：`|x2-x1|+|y2-y1|`
欧几里得距离：`√[(x1-x2)^2+(y1-y2)^2]`

**奇数行是正常的, 偶数行是反向的**,行列要处理好，注意戏节。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int main(){
  int w, m, n;cin>>w>>m>>n;
  int x1 = (m-1)/w + 1, x2 = (n-1)/w + 1;//行数
  int y1 = (x1&1)?((m-1)%w + 1): (w-(m-1)%w),//列数+判断行数奇偶情况时的列数
      y2 = (x2&1)?((n-1)%w + 1): (w-(n-1)%w);

  cout<<abs(x1-x2) + abs(y1-y2);
}
```

### [AcWing1229.日期问题](https://www.acwing.com/problem/content/1231/)|模拟|枚举

> 小明知道这些日期都在1960年1月1日至2059年12月31日。
>
> 格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的
>
> 给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗
>
> #### 输入格式
>
> 一个日期，格式是”AA/BB/CC”。
>
> 即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。
>
> #### 输出格式
>
> 输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。
>
> 多个日期按从早到晚排列。

1. 完全模拟：代码量太大了，没必要
2. 直接从19600101-20591231枚举, 然后再判断日期是否合法 计算量10^7不会超时

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int months[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

bool isLeap(int year){
  if(year % 400 == 0 || (year%100 != 0 && year%4 == 0)) return true;
  return false;
}

int y, m, d;//设为全局，方便主程序里
bool judge(int date){//传入八位数
  y = date/10000;
  m = date%10000/100;
  d = date%100;
  if(d < 1 || d > 31) return false;
  if(m <1 || m > 12) return false;
  //二月之外
  if(m != 2 && d > months[m]) return false;
  //特殊情况：闰年二月
  else if(m == 2 && d > 28+isLeap(y)) return false;//注意这里必须使用大于号>而不是不等于!=  ，这与类型转换有关
  
  return true;
}

int main(){
  int a, b, c;
  scanf("%d/%d/%d", &a,&b,&c);
  for(int i = 19600101; i<= 20591231; i++){
    if(judge(i)){
      //年月日、月日年、日月年;年是后两位数
      if(        
        (y%100 == a && m == b && d == c) ||
        (d == a && m == b && y%100 == c) ||
        (m == a && d == b && y%100 == c)
      ){
        printf("%d-%02d-%02d\n",y,m,d);
      }
    }
  }
}
```

---

**日期问题总结**

写了几道题目，非常多日期问题，这里总结一下日期问题相关常用的代码

1. 查重排序

   ```cpp
   set<string> st;
   ```

2. 整型转字符串`to_string`

3. 字符串转整幸`stoi`

4. 判断闰年

   ```cpp
   bool isLeap(int year){
     if(year % 400 == 0 || (year%100 != 0 && year%4 == 0)) return true;
     return false;
   }
   ```

5. 月份数组

   ```cpp
   int months[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
   ```

6. 判断日期是否合法

   ```cpp
   bool judge(int date){//传入八位数
     y = date/10000;
     m = date%10000/100;
     d = date%100;
     if(d < 1 || d > 31) return false;
     if(m <1 || m > 12) return false;
     //二月之外
     if(m != 2 && d > months[m]) return false;
     //特殊情况：闰年二月
     else if(m == 2 && d > 28+isLeap(y)) return false;//注意这里必须使用大于号>而不是不等于!=  ，这与类型转换有关
     
     return true;
   }
   ```

7. 常用技巧：直接遍历所有可能的日期，对满足题意的操作，而不是单个查询判断后操作。

---

### [AcWing1231.航班时间](https://www.acwing.com/problem/content/1233/)|模拟|数学

> 飞机在飞，由于人为规定的时区导致好像时间变慢或者快了（实际上没有）。这里很像我们高中物理学的运动学知识，我们可以假设一个场景——**船在不平静水面行驶，船从一个点出发行驶了s路程后返回原点（期间船速不变），然后告诉我们来回整个过程回到原点的总时间是t，问船在静水中行驶s路程需要多长时间。我们可以以水为参考系，那么显然这个时间为 t/2。**

上面这个理解，非常👍

- 库函数的运用：
  - `sscanf`
  - `get_line`
  - `.c_str()`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int get_seconds(int h, int m, int s)
{
    return h * 3600 + m * 60 + s;
}

int get_time()
{
    string line;
    getline(cin, line);

    if (line.back() != ')') line += " (+0)";

    int h1, m1, s1, h2, m2, s2, d;
    sscanf(line.c_str(), "%d:%d:%d %d:%d:%d (+%d)", &h1, &m1, &s1, &h2, &m2, &s2, &d);

    return get_seconds(h2, m2, s2) - get_seconds(h1, m1, s1) + d * 24 * 3600;
}

int main()
{
    int n;
    scanf("%d", &n);
    string line;
    getline(cin, line);     // 忽略掉第一行的回车
    while (n -- )
    {
        int time = (get_time() + get_time()) / 2;
        int hour = time / 3600, minute = time % 3600 / 60, second = time % 60;
        printf("%02d:%02d:%02d\n", hour, minute, second);
    }

    return 0;
}
```

### [AcWing1241.外卖店优先级](https://www.acwing.com/problem/content/1243/)|模拟

>  由于**订单数量、店铺数量和时间达到10^5**，我们**不能通过时间来枚举每一份订单，这样必然会超时**。
> **对于一家店铺**来说，在**一条时间轴上**，必然是有**一些时间点有订单，有些点没有订单**。那么我们可以**枚举每一批次订单**，这些订单是同一时刻同一店铺的，这样的话时间复杂度就降到O(m)

关键还是那个 last 数组，存储上一次订单时间，使得减少了枚举时间的操作。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5+10;

int n, m, T;
int pr[N],//优先级
    st[N],//st[i]=1 表示i在优先缓存中
    last[N];//last[N] 表示最近一次的订单时间
PII order[N];//订单：<t, di>

int main(){
  cin>>n>>m>>T;
  for(int i = 0; i<m;i++){
    cin>>order[i].first>>order[i].second;
    // cout<<"*"<<order[i].first<<order[i].second<<endl;
  }
  // cout<<endl;
  //按时间排序
  sort(order, order+m);
  for(int i = 0; i<m;i++){
    // cout<<i<<"*"<<order[i].first<<order[i].second<<endl;
  }

// cout<<endl;
  for(int i = 0; i< m; ){//喵的一开始这里打习惯了一个 i++  ，找了半天bug
    int j = i;
    // cout<<j<<":"<<endl;
    while(order[i] == order[j] && j < m) j++;//pair的相等是key和value都要相等：也就是同一时刻一家店多个订单的情况
    int t = order[i].first, id = order[i].second, 
        cnt = j - i;//t时刻，id店有cnt个订单
    i = j;//订单指针跳转
    pr[id] -= t - last[id] - 1;
    // cout<<"-:t-last-1: "<<t<<"-"<<last[id]<<"-1"<<endl;
    if(pr[id] < 0) pr[id] = 0;
    if(pr[id] <= 3) st[id] = 0;
    // cout<<"-pr"<<id<<" "<<pr[id]<<endl;

    //以上是处理t时刻之前，下面是t时刻
    pr[id] += cnt*2;
    // cout<<"+pr"<<id<<" "<<pr[id]<<endl;
    if(pr[id] > 5) st[id] = 1;
    last[id] = t;
    // cout<<"last"<<id<<" "<<last[id]<<endl;
  }
  // 最后再处理一下
  for(int i = 1; i<= n; i++){
    if(last[i] < T){
      pr[i] -= T - last[i];
      if(pr[i] <= 3) st[i] = 0;
    }
  }
  int ans = 0;
  for(int i = 1; i <= n; i++){
    // cout<<pr[i]<<" ";
    ans += st[i];
  }
  // cout<<endl;
  cout<<ans;
  
}
```

## 双指针、BFS、DFS、图论

### [AcWing1238.日志统计](https://www.acwing.com/problem/content/1240/)|双指针|滑动窗口

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define x first
#define y second
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5 + 10;
int cnt[N];  //记录当前时间窗口内点赞次数
bool st[N];  //有成为过热帖就为1
PII win[N];  //窗口
int main() {
  int n, d, k;
  scanf("%d%d%d", &n, &d, &k);
  for (int i = 0; i < n; i++) {
    scanf("%d%d", &win[i].x, &win[i].y);
  }

  sort(win, win + n);  //对第一个关键字也就是时间进行排序方便窗口操作

    //滑动窗口
  for (int i = 0, j = 0; i < n; i++) {
    //双指针
    // i为当前指针,也就是窗口右侧
    // j为窗口左侧
    int id = win[i].y;
    cnt[id]++;
    while (win[i].x - win[j].x >= d) {  //因为是左开右闭区间
      //要把最左边的除掉了
      int id = win[j].y;
      cnt[id]--;
      j++;  //窗口右移
    }
    if (cnt[id] >= k) st[id] = 1;
  }
  for (int i = 0; i < N; i++) {
    if (st[i]) printf("%d\n", i);
  }
}
```

### [AcWing1101.献给阿尔吉侬的花束](https://www.acwing.com/problem/content/1103/)|BFS

找最短步数——BFS，广搜，按层搜索，也就是找到了直接退出。

存储

```cpp
char a[N][N];// 接收地图。
int dis[N][N];// 存储到每个点的路径长度
```

地图遍历方向数组

```cpp
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0 ,-1};
```

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 210;
int dis[N][N];
char a[N][N];
void bfs(PII start) {
  queue<PII> q;
  q.push(start);
  while (!q.empty()) {
    PII u = q.front();
    q.pop();
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    //遍历四个方向
    for (int i = 0; i < 4; i++) {
      int x = u.first + dx[i], y = u.second + dy[i];
      if (a[x][y] == '#') continue;  //是墙直接下一个
      if (a[x][y] == '.') {
        dis[x][y] = dis[u.first][u.second] + 1;
        a[x][y] = '#';  //遍历过的点直接记录为墙防止再次进入多余循环
        q.push({x, y});
      }
      if (a[x][y] == 'E') {  //找到终点
        cout << dis[u.first][u.second] + 1 << "\n";
        return;
      }
    }
  }
  cout << "oop!\n";  //没找到
}
int main() {
  int t;
  cin >> t;
  while (t--) {
    memset(a, '#', sizeof(a));  //地图全初始化为墙
    memset(dis, 0, sizeof(dis));
    int n, m;
    cin >> n >> m;
    PII start;
    //下标从1开始，这样图的边缘也就是墙
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
        if (a[i][j] == 'S') {  //记录起点
          start = {i, j};
          // start.first = i, start.second = j;
          a[i][j] = '#';  //记录为墙防止进去bfs后多余的重复遍历
        }
      }
    }
    bfs(start);
  }
  return 0;
}
```

### [AcWing1096.地牢大师](https://www.acwing.com/problem/content/1098/)|BFS

> 三维地牢
> 最快脱离
> 不含岩石障碍可以直接通过，部分包含岩石障碍无法通过
> 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。
> 向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。

**最快路线 = 最短路线 = 广搜 BFS**

还就那个广搜，只不过空间换成了三维，与二维的相比，区别在于建图时要用三维数组，控制移动方向时一共有六个方向，三个偏移量。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 110;
int l, r, c;      //层数、每层的行数、列数
char g[N][N][N];  //存图
int res[N][N][N];  //记录到该点的步数，并且初始化为-1(-1代表没访问过)

//点结构体
struct Point {
  int z, x, y;
} st, ed;  //起点、终点

//判断条件较多，就直接抽取出来当一个函数
bool check(int z, int x, int y) {
  //出界
  if (z < 1 || z > l || x < 1 || x > r || y < 1 || y > c) return false;
  //访问过
  if (res[z][x][y] != -1) return false;
  //是阻碍
  if (g[z][x][y] == '#') return false;
  return true;
}

void bfs() {
  queue<Point> Q;
  Q.push(st);
  res[st.z][st.x][st.y] = 0;  //初始化
  //偏移量:东南西北上下
  int dx[6] = {1, 0, -1, 0, 0, 0};
  int dy[6] = {0, 1, 0, -1, 0, 0};
  int dz[6] = {0, 0, 0, 0, -1, 1};

  while (Q.size()) {
    auto u = Q.front();
    Q.pop();

    //遍历各个方向
    for (int i = 0; i < 6; i++) {
      int z = u.z + dz[i], x = u.x + dx[i], y = u.y + dy[i];
      if (check(z, x, y)) {
        Q.push({z, x, y});
        res[z][x][y] = res[u.z][u.x][u.y] + 1;
      }
    }
  }
}

int main() {
  // while (scanf("%d%d%d", &l, &r, &c) && l) {  // l==0时退出
  while (cin >> l >> r >> c, l) {  // l==0时退出
    //多组输入，所以每次都要初始化数组
    memset(res, -1, sizeof(res));
    for (int i = 0; i < l; i++) {
      for (int j = 0; j < r; j++) {
        string s;
        cin >> s;
        for (int k = 0; k < c; k++) {
          //图的问题，坐标最好都从1 开始，这样默认效果就是四周有墙
          g[i + 1][j + 1][k + 1] = s[k];
          //记录起点和终点
          if (s[k] == 'S')
            st = {i + 1, j + 1, k + 1};
          else if (s[k] == 'E')
            ed = {i + 1, j + 1, k + 1};
        }
      }
    }
    bfs();
    int ans = res[ed.z][ed.x][ed.y];
    if (ans != -1)
      printf("Escaped in %d minute(s).\n", ans);
    else
      printf("Trapped!\n");
  }
  return 0;
}
```

- 每一行都是连着的，所以直接用string读入
- 并且坐标从1开始，达到默认效果四周有墙。



### [AcWing1113.红与黑](https://www.acwing.com/problem/content/1115/)|DFS|Flood Fill

> 有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。
>
> 你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。
>
> 请写一个程序，计算你总共能够到达多少块黑色的瓷砖。

> 1）‘.’：黑色的瓷砖；
> 2）‘#’：红色的瓷砖；
> 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。

计算从起点走**任意路线**能到达的黑色砖块数——搜全部的解——深搜DFS

还要注意

> 输入包括多个数据集合。
>
> 当在一行中读入的是两个零时，表示输入结束。

要知道怎么处理输入输入的数据

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;


const int N = 50;
int h, w;      //宽高,w 行 h 列
char g[N][N];  //地图
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
int cnt = 0;

void dfs(int x, int y) {
  cnt++;          //能到就说明是黑格子，记录++
  g[x][y] = '#';  //转为红格子，也就是标记为访问过
  for (int i = 0; i < 4; i++) {
    int a = x + dx[i], b = y + dy[i];
    if (a < 0 || a >= h || b < 0 || b >= w || g[a][b] == '#') continue;
    dfs(a, b);
  }
}

int main() {
  // cpp中逗号表达式的值是最后一个表达式的值，即n||m都为0时退出
  while (cin >> w >> h, h || w) {
    cnt = 0;
    for (int i = 0; i < h; i++)
      scanf("%s", g[i]);  //一次读入一行，因为输入时也没有隔空格

    int x = 0, y = 0, flag = 0;  // flag用来跳出二重循环
    for (int i = 0; i < h; i++) {
      for (int j = 0; j < w; j++) {
        if (g[i][j] == '@') {  //找到起点
          x = i, y = j;
          flag = 1;
        }
      }
      // cout << "XY" << x << " " << y << endl;
      if (flag) break;
    }
    dfs(x, y);
    cout << cnt << "\n";
  }
  return 0;
}
```

### [AcWing1233.全球变暖](https://www.acwing.com/problem/content/1235/)|DFS|Flood Fill|连通块

> 有一张某海域 N×N 像素的照片，”.”表示海洋、”#”表示陆地
>
> 如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。
>
> 连在一起的一片陆地组成一座岛屿
>
> 依照科学家的预测，照片中有多少**岛屿**会被完全淹没
>
> 照片保证第 11 行、第 11 列、第 NN 行、第 NN 列的像素都是海洋。————就是四周为海洋

一片陆地组成一座岛屿——>连通块问题——遍历一个连通块并标记已经搜索过，再遍历下一个统计一共有多少个连通块。

完全淹没：连通块中一块不剩了。

所以就是初始化时遍历得到连通块个数，然后再在搜索时统计一块不剩的连通块数量。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1010;
int n, ans;
int d[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};  //方向数组
char a[N][N];                                      //地图
int vis[N][N] = {0};                               //标记是否访问过
int flag;                                          //标记单个岛是否淹没

//对(x,y)进行深搜，找出其相连的小岛，判断该连通块是否会完全淹没
void dfs(int x, int y) {
  vis[x][y] = 1;  //标记为访问过

  //四周都是陆地不会被淹没
  if (a[x][y + 1] == '#' && a[x][y - 1] == '#' && a[x - 1][y] == '#' &&
      a[x + 1][y] == '#') {
    //只要有一个不会被淹没，跳出该轮dfs的时候flag都为1——即该连通块不会完全淹没
    flag = 1;
  }
  //继续深搜其周围的陆地
  for (int i = 0; i < 4; i++) {
    int nx = x + d[i][0], ny = y + d[i][1];
    if (vis[nx][ny] == 0 && a[nx][ny] == '#') {  //没被访问过 && 是陆地
      //继续DFS
      dfs(nx, ny);
    }
  }
}
int main() {
  cin >> n;
  //注意下标从1开始，这样四周就不是'#'-->就等于题目中说的四周为海
  FOR(i, 1, n + 1) {
    FOR(j, 1, n + 1) { cin >> a[i][j]; }
  }
  FOR(i, 1, n + 1) {
    FOR(j, 1, n + 1) {
      if (a[i][j] == '#' && vis[i][j] == 0) {  //是陆地并且没访问过
        flag = 0;
        dfs(i, j);  //遍历这个点及其连通块
        if (flag == 0) {  //出来时，flag还是0就说明该点相连的全部都淹没了
          ans++;
        }
      }
    }
  }
  cout << ans;
  return 0;
}
```





### [AcWing1224.交换瓶子](https://www.acwing.com/problem/content/1226/)|图论|环|置换群|贪心

> 至少交换多少次，才能完成排序。

举个例子：
原位置：      2 3 1 5 4
正确位置：  1 2 3 4 5
那么：
2 应该在 3 的位置
......

最后就会发现，几个数会构成一个环。：1->2->3->1，5->4->5。

三个结论：

- 改变一个环中的两个点（将其中一个点变换到正确的位置），会将一个环分为两个环，并且对其他的环没有影响。
- 改变两个环中的两个点（将其中一个点变换到正确的位置），会将这两个环合为一个。
- 正确位置时，可以看作每个数自己构成一个环——也就是 n 个环。（n 为元素个数）
- 至少 n - k 次操作。(k为原位置到正确位置的初始环数)

所以重点操作就是 **找初始环数**。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5 + 10;
int a[N];    //存初始数组
bool st[N];  //记录是否已经放进环中

int main() {
  int n, k = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    if (!st[i]) {  //位置 i 的元素还没有放入到某个环中
      k++;
      // 遍历查找 i 位置元素所在的环中的其他元素
      for (int j = i; !st[j]; j = a[j]) {  //位置 j 指向 a[j] 的元素
        st[j] = 1;                         //记录已经进到某个环中了
      }
    }
  }
  cout << n - k << endl;
  return 0;
}
```

### [AcWing1207.大臣的旅费](https://www.acwing.com/problem/content/1209/)|树的直径|树型DP|DFS

> 国修建了大量的快速路，用于连接首都和王国内的各大城市
>
> 任何一个大城市都能从首都直接或者通过其他大城市间接到达。
>
> 如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。
>
> 在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。——这里看起来很复杂，实际上就是得到最长路径长度后稍作计算罢了。——等差数列求和：(首项+末项 )*x/2
>
> 想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢
>
> **双向**高速路

1. 求一个树的最长路径d(树的直径)，

2. 计算总花费s。

   $$ \frac{(11 + (d + 10))*d}{2} = \frac{(21+d)*d}{2}$$

**求树的直径的方法：**

1. 两次DFS或BFS求最远 $$ O(2n)$$
   任取一点作为起始点k，找到距离该点最远的一个点v。
    再从点v开始搜，找到距离点v最远的一点u，则uv间的距离是树的直径。

   算法常数比DP法稍大一些，但是可以同时得知直径的具体结点。

   ```cpp
   void dfs(int u,int pa)
   {
       //dp[u]记录从u出发能到达的最远距离，rem[u]记录离u最远的结点
       rem[u]=u; dp[u]=0;
       //遍历搜索以 u 为起点的边
       for(int i=head[u];i;i=E[i].nxt)
       {
           int v=E[i].v;
           if(v==pa) continue;
           dfs(v,u);
           if(dp[u]<=dp[v]+E[i].dis){
   	        dp[u]=dp[v]+E[i].dis,rem[u]=rem[v];
           }
       }
   }
   
   dfs1(1,0); p=rem[1];
   dfs1(p,0); q=rem[p];
   //直径就是pq，直径长度就是dp[p]
   ```

   

2. 一次DFS中DP $$O(n)$$

   ```cpp
   void DP(int u,int pa)
   {
       dp[u]=0;
       for(int i=head[u];i;i=E[i].nxt)
       {
           int v=E[i].v;
           if(v==pa) continue;//回头就成环了
           DP(v,u);
           //状态转移
           mxlen=max(mxlen,dp[u]+dp[v]+E[i].dis);//这里直接用一个全部变量更新也可以
           dp[u]=max(dp[u],dp[v]+E[i].dis);
       }
   }
   ```

   ![Screenshot_20220121_112058_com.jideos.jnotes](https://gitee.com/okkjoo/image-bed/raw/master/imgs/Screenshot_20220121_112058_com.jideos.jnotes.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 100010;
//用链式前向星存图
int h[N], ne[2 * N], e[2 * N], w[2 * N],
    idx = 0;  //双向图，所以除了起点数组以外都要*2
ll ans = 0;

//加边操作
void add(int a, int b, int c) {
  e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int dp[N];
void DP(int u, int p) {
  dp[u] = 0;
  for (int i = h[u]; i != -1; i = ne[i]) {
    int v = e[i];
    if (v == p) {
      continue;
    }
    DP(v, u);
    ans = max(
        ans,
        (ll)(dp[u] + dp[v] +
             w[i]));  //直接用一个全局变量得到最大值，ll强制转换一下数据类型使得max函数不会报错
    dp[u] = max(dp[u], dp[v] + w[i]);
  }
}
int n, a, b, c;
int main() {
  memset(h, -1, sizeof h);
  ios::sync_with_stdio(false);
  cin >> n;
  for (int i = 0; i < n - 1; i++) {
    cin >> a >> b >> c;
    add(a, b, c), add(b, a, c);
  }
  DP(1, -1);  //任取一点开始搜，这里默认从1号点搜，其没有父结点，父亲为-1
  ans = (21 + ans) * ans / 2;  //计算总花费
  cout << ans;

  return 0;
}
```

## 日常刷题

### [scnu.oj魔法阵](http://csoj.scnu.edu.cn/problem/S0276)|二维前缀和|DP

> 初始位置(1,1)
>
> 地图上有障碍物，只能向右下角移动，要清除所有障碍物同时最后到达(n+1, n+1)
>
> 清除障碍的技能是一个正方形——从某段起点到终点作为左上角和右上角

- 实际上就是需要若干个首尾相连的正方形来覆盖所有障碍物。

- 任何时候(x, y) 中x, y 相等

- 任何时候都不可能能回头清除x或y比当前坐标小的障碍物

- DP：

  - dp[i] 表示 从(i, i)开始，走到(n + 1, n+1)并清除所有x值和y值都不小于i 的方案数

  - 从后往前DP，起点dp[n+1]的方案数自然只有1

  - 看下图：

    ![Screenshot_20220124_094923_com.jideos.jnotes](https://gitee.com/okkjoo/image-bed/raw/master/imgs/Screenshot_20220124_094923_com.jideos.jnotes.png)

二位前缀和预处理之后：

`int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];`

而实际上只需要 `a+b+c - a = 0`就代表b、c块没有障碍。

=>

`(s[j][n]+s[n][j]-s[j][j]-s[i][n]-s[n][i]+s[i][i]) - (s[j][j] - s[i][j]-s[j][i]+s[i][i]) == 0`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1005;
int n, a[N][N];
char mp[N][N];
const int mod = 1e9 + 7;
ll dp[N];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    scanf("%s", mp[i] + 1);
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
      if (mp[i][j] == '1') a[i][j]++;
    }
  }
  //反过来方便dp，让(0,0)是终点，(n,n)是起点,就是把上面的图对角翻过来，*注意二位前缀和即bc的方向也反过来了，最好自己画一下就理解了。
  dp[0] = 1;
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j < i; j++) {
      int t = a[i][j] + a[j][i] - 2 * a[j][j];  //(a+b)+(a+c)-2a = b+C
      if (t == 0)                               // b+c没有障碍
        (dp[i] += dp[j]) %= mod;
    }
  }
  cout << dp[n] << endl;
  return 0;
}
```

