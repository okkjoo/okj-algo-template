之前写过的还没有整理上来...会慢慢复习并整理上来的。

# 天梯学习笔记

![ ](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

**各数据类型取值范围与10的数量级对照**

>   类型名称                                                     取值范围
>    int                                                         		-2^31~（2^31-1）
>   unsigned int       										      0~（2^32-1）
>   2^31=2,147,483,648 				 10^9数量级
>   2^32=4,294,967,296  				10^9数量级
>
>   类型名称                                                        取值范围
>   long long (_int64)                                     -2\^63~(2\^63-1）
>
>   unsigned long long (unsigned_int64)     0~(2^64-1)
>   2^63=9,223,372,036,854,775,808      10^18数量级
>   2^64=18,446,744,073,709,551,616  	 10^19数量级

## L2-001 紧急救援 (25 分)|Dijkstra

**注释：**

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e8;
// N<500
int saveTeam[505];  //各点的存储的救援人数
int st[505];        //按路径能召集到的最多人数
int mm[505][505];   //地图
int number[505];    //到该点最短路径的数量
int vis[505];       //是否标记为node过
int dis[505];       //起点到该点的距离
int father[505];    //最短路径中，该点的上一个节点
int n, m, s, d;     //城市数量、路线数量、起点、终点

void Dijkstra() {
  //初始化
  fill(dis, dis + n, INF);
  fill(vis, vis + n, 0);
  fill(number, number + n, 0);
  dis[s] = 0;
  st[s] = saveTeam[s];
  number[s] = 1;
  for (int i = 0; i < n; i++) {
    int minn = INF, node = -1;
    for (int j = 0; j < n; j++) {
      if (!vis[j] && dis[j] < minn) {
        minn = dis[j];
        node = j;
      }
    }
    vis[node] = 1;
    if (node == -1) return;
    for (int j = 0; j < n; j++) {
      if (vis[j] == 0 && mm[node][j] != -1 &&
          (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        father[j] = node;
        number[j] = number[node];
      } else if (vis[j] == 0 && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j]) == dis[j]) {
        if ((st[node] + saveTeam[j]) > st[j]) {
          st[j] = st[node] + saveTeam[j];
          father[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  for (int i = 0; i < n; i++) {
    cin >> saveTeam[i];
  }
  //初始化地图
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      mm[i][j] = -1;
    }
  }
  //读入地图
  for (int i = 0; i < m; i++) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val;
    mm[n2][n1] = val;
  }
  Dijkstra();
  int p = d;
  while (1) {
    if (father[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = father[p];  //在这里使得起点 father[p] == p
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1) {
      cout << pathV[i];
    } else {
      cout << " " << pathV[i];
    }
  }
```

**无注释：**

```cpp


#include <bits/stdc++.h>
using namespace std;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 505, INF = 1e8;
int st[N], saveTeam[N], vis[N], dis[N], number[N], mm[N][N], fa[N], n, m, s, d;
void dj() {
  fill(vis, vis + N, 0), fill(dis, dis + N, INF), fill(number, number + N, 0);
  dis[s] = 0, st[s] = saveTeam[s];
  number[s] = 1;
  FOR(i, 0, n) {
    int minn = INF, node = -1;
    FOR(j, 0, n) {
      if (!vis[j] && dis[j] < minn) minn = dis[j], node = j;
    }
    if (node == -1) return;
    vis[node] = 1;
    FOR(j, 0, n) {
      if (!vis[j] && mm[node][j] != -1 && (dis[node] + mm[node][j]) < dis[j]) {
        dis[j] = dis[node] + mm[node][j];
        st[j] = st[node] + saveTeam[j];
        fa[j] = node;
        number[j] = number[node];
      } else if (!vis[j] && mm[node][j] != -1 &&
                 (dis[node] + mm[node][j] == dis[j])) {
        if ((st[node] + saveTeam[j] > st[j])) {
          st[j] = st[node] + saveTeam[j];
          fa[j] = node;
        }
        number[j] += number[node];
      }
    }
  }
}

int main() {
  vector<int> pathV;
  cin >> n >> m >> s >> d;
  FOR(i, 0, n) { cin >> saveTeam[i]; }
  FOR(i, 0, n) FOR(j, 0, n) mm[i][j] = -1;
  FOR(i, 0, m) {
    int n1, n2, val;
    cin >> n1 >> n2 >> val;
    mm[n1][n2] = val, mm[n2][n1] = val;
  }
  dj();
  int p = d;
  while (1) {
    if (fa[p] == p) {
      pathV.push_back(p);
      break;
    }
    pathV.push_back(p);
    p = fa[p];
  }
  cout << number[d] << " " << st[d] << endl;
  for (int i = pathV.size() - 1; i >= 0; i--) {
    if (i == pathV.size() - 1)
      cout << pathV[i];
    else
      cout << " " << pathV[i];
  }
}
```



## **L2-002 链表去重** 

- 主要在于用结构体存储
- 两个数组充当两个链表 ， `t1 t2`分别作为两个指针下标并且代表链表的长度，数组中存储对应的地址
- ` ad1 = node[ad1].nxt;`通过访问结构体中nxt 进行指针跳转

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

const int N = 1e5 + 10;
struct Node {
  int key, nxt;
} node[N];         // node[i]:地址为i，键值为node[i].key
int p1[N], p2[N];  //去重后的链表、被删除的链表
int flag[N];       //记录其绝对值是否出现过
int main() {
  int ad1, n;  // ad1:头地址
  cin >> ad1 >> n;
  int a, b, c;
  FOR(i, 0, n) {
    cin >> a >> b >> c;
    node[a].key = b, node[a].nxt = c;
  }
  int t1 = 0, t2 = 0;            //分别是两个链表的指针
  while (n--) {                  //枚举每个节点
    int k = abs(node[ad1].key);  // ad1开始充当头指针
    if (!flag[k]) {
      flag[k] = 1, p1[t1++] = ad1;
    } else
      p2[t2++] = ad1;
    ad1 = node[ad1].nxt;
    if (ad1 == -1) break;
  }
  FOR(i, 0, t1) {
    ad1 = p1[i];
    if (i == t1 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p1[i + 1]);
  }
  FOR(i, 0, t2) {
    ad1 = p2[i];
    if (i == t2 - 1)
      printf("%05d %d -1\n", ad1, node[ad1].key);
    else
      printf("%05d %d %05d\n", ad1, node[ad1].key, p2[i + 1]);
  }
}
```



## L2-003 月饼 (25 分)|简单模拟

根据月饼的总价和数量计算出每一种月饼的单价，然后将月饼数组按照单价从大到小排序，根据需求量need的大小，从单价最大的月饼开始售卖，将销售掉这种月饼的价格累加到result

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

struct node {
  double num, price;
} a[1005];
bool cmp(node a, node b) { return a.price / a.num > b.price / b.num; }
int n, d;
int main() {
  while (cin >> n >> d) {
    FOR(i, 0, n) { cin >> a[i].num; }
    FOR(i, 0, n) { cin >> a[i].price; }
    sort(a, a + n, cmp);
    double res = 0;
    FOR(i, 0, n) {
      if (a[i].num < d) {
        res += a[i].price;
      } else {
        res += a[i].price / a[i].num * d;
        break;
      }
      d = d - a[i].num;
    }
    printf("%.2f", res);
  }
  return 0;
}
```

## L2-004 这是二叉搜索树吗？ (25 分)|二叉搜索树性质：前序遍历->后序遍历

- 其左子树中所有结点的键值小于该结点的键值；
- 其右子树中所有结点的键值大于等于该结点的键值；
- 其左右子树都是二叉搜索树。

相关笔记：https://www.yuque.com/qzhou/learning/sw1t80

> 假设它是二叉搜索树，一开始`isMirror`为FALSE，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设`isMirror`为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出NO否则输出YES
>
> 原文链接：https://blog.csdn.net/liuchuo/article/details/52160484

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, pre[1005];
vector<int> resv;
bool is_mir = 0;

void solve(int root, int tail) {
  if (root > tail) return;
  int i = root + 1, j = tail;  // 用双指针是因为不能确定他是二叉搜索树，单指针可能误判
  if (!is_mir) {
    while (i <= tail && pre[i] < pre[root]) i++;  //找该节点的左子树
    while (j > root && pre[j] >= pre[root]) j--;  //找该节点的右子树
  } else {
    while (i <= tail && pre[i] >= pre[root]) i++;
    while (j > root && pre[j] < pre[root]) j--;
  }
  solve(root + 1, i - 1);
  solve(j + 1, tail);
  resv.push_back(pre[root]);
}

int main() {
  cin >> n;
  FOR(i, 0, n) cin >> pre[i];
  solve(0, n - 1);
  if (resv.size() != n) {
    resv.clear();
    is_mir = 1;
    solve(0, n - 1);
  }
  if (resv.size() != n) {
    cout << "NO" << endl;
  } else {
    cout << "YES" << endl;
    FOR(i, 0, resv.size()) {
      if (i != 0) cout << " ";
      cout << resv[i];
    }
  }
  return 0;
}
```

## L2-005 集合相似度 (25 分|简单模拟|set

集合，它们的相似度定义为：*N~c~*/*N~t~*×100%。其中*N~c~*是两个集合都有的不相等整数的个数（都有的：即交集大小），*N~t~*是两个集合一共有的不相等整数的个数（a 并 b 得到的集合的大小），借助 set 可以很简单的完成：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, n, m) for (int i = n; i < m; i++)

const int N = 55;
set<int> st[N];

int main() {
  int n, m, x;
  cin >> n;
  FOR(i, 1, n + 1) {  //注意集合下标从1开始
    cin >> m;
    FOR(j, 0, m) {
      cin >> x;
      st[i].insert(x);
    }
  }
  int k;
  cin >> k;
  FOR(i, 0, k) {
    int a, b;
    cin >> a >> b;
    int cnt = 0;  //共有cnt个数相同，即交集的大小
    for (auto it = st[a].begin(); it != st[a].end(); ++it) {
      if (st[b].count(*it)) cnt++;
    }
    printf("%.2f%\n", cnt * 1.0 / (st[a].size() + st[b].size() - cnt) * 100);
  }
  return 0;
}
```



## L2-006 树的遍历 (25 分)|二叉树：后序+中序 => 层序

层序遍历利用 map 的有序性来完成。

递归传入左孩子、右孩子下标即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post, in;
map<int, int> level;
void pre(int root, int start, int end, int index) {
  if (start > end) return;
  int i = start;
  while (i < end && in[i] != post[root]) i++;
  level[index] = post[root];
  pre(root - 1 - end + i, start, i - 1, 2 * index + 1);
  pre(root - 1, i + 1, end, 2 * index + 2);
}
int main() {
  int n;
  cin >> n;
  post.resize(n);
  in.resize(n);
  FOR(i, 0, n) cin >> post[i];
  FOR(i, 0, n) cin >> in[i];
  pre(n - 1, 0, n - 1, 0);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
  return 0;
}
```



## **L2-007 家庭房产 (25 分)**|并查集|

- pair存边
- 自定义结构体以及其排序规则
- 要注意家里只有自己一个人与根本没这家人要区别

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;
int f[N], avN[N], peo[N], avS[N];
bool st[N];  //家里只有自己的和没参与统计的 都有 f[i]==i, 所以需要特殊标记
int find(int x) { return x == f[x] ? f[x] : f[x] = find(f[x]); }
int cntme = 0;
void merge(int a, int b) {  //在merge里将相关属性传递好
  // int x = f[a], y = f[b];        //这里写错好多次！！有点rz
  int x = find(a), y = find(b);
  cntme++;
  if (x != y) {
    int mx = max(x, y), mn = min(x, y);
    f[mx] = mn;          // id小的作为家庭代表
    peo[mn] += peo[mx];  //家庭人数
    avN[mn] += avN[mx];  //家庭房子套数
    avS[mn] += avS[mx];  //家庭总面积
  }
}
vector<PII> e;   //存储关系，方便操作
struct Family {  // id, num, aN, aS
  int id, num, aN, aS;
};
bool cmp(Family a, Family b) {
  if (a.aS * 1.0 / a.num == b.aS * 1.0 / b.num) {
    return a.id < b.id;
  }
  return a.aS * 1.0 / a.num > b.aS * 1.0 / b.num;
}
int cnt = 0;
int main() {
  FOR(i, 0, N) { f[i] = i, peo[i] = 1; }
  int n;
  cin >> n;
  int me, fa, mo, k, ch;
  FOR(i, 0, n) {
    cin >> me >> fa >> mo >> k;
    if (fa != -1) e.push_back({me, fa});
    if (mo != -1) e.push_back({me, mo});
    st[me] = 1;  //有统计的标记

    FOR(j, 0, k) {
      cin >> ch;
      e.push_back({me, ch});
    }
    cin >> avN[me] >> avS[me];
  }
  FOR(i, 0, e.size()) {
    int fir = e[i].first, sec = e[i].second;
    merge(fir, sec);
    st[e[i].first] = st[e[i].second] = 1;  //有统计的标记
  }
  vector<Family> ans;
  int cntst = 0, cntf = 0;
  FOR(i, 0, N) {
    if (st[i]) cntst++;
    if (f[i] == i) cntf++;
    if (st[i] && f[i] == i) {  //有这个家庭并且他是代表
      ans.push_back({i, peo[i], avN[i], avS[i]});
    }
  }

  sort(ans.begin(), ans.end(), cmp);
  cout << ans.size() << endl;
  for (auto it : ans) {
    printf("%04d %d %.3lf %.3lf\n", it.id, it.num, it.aN * 1.0 / it.num,
           it.aS * 1.0 / it.num);
  }
}

```





## L2-8 最长对称子串|马拉车算法

使用到马拉车算法，算法主要思想就是利用回文的特性——知道左边的回文长度一定程度上就能知道右边的回文长度

以前记过[笔记](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8) 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

string mnc(string x) {
  string s = expendS(x);
  int Len[10000], idd = 0, maxx = 0, maxLen = 0, start = 0;
  FOR(i, 0, s.size()) {
    if (i < maxx)
      Len[i] = min(Len[2 * idd - i], maxx); // min(i 关于 idd 对称的点的最长距离, 能到达的最右边)
    else
      Len[i] = 1;                 				//没得优化就只能等待暴力
  //不论优化没有 都要暴力一下看看
    while (i + Len[i] < s.size() && i - Len[i] > 0 && //下标范围合法
           s[i + Len[i]] == s[i - Len[i]]) {			//对称
      Len[i]++;
    }
  //是否更新状态
    if (Len[i] + i > maxx) maxx = Len[i] + i, idd = i;
    if (Len[i] - 1 > maxLen) maxLen = Len[i] - 1, start = (idd - maxLen) / 2;
  }
  return s.substr(start, maxLen);
}
int main() {
  ios::sync_with_stdio(false);
  string s;
  getline(cin, s);
  cout << mnc(s).size();
  return 0;
}
```

## [L2-009 抢红包 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400)|结构体|自定义条件排序|浮点数精度缺失

给出*N*个人之间互相发红包、抢红包的记录

**疑问**：为什么提前处理 单位 `分 * 0.01 = 元` 后再记入结构体中就会出错

> **因为==涉及浮点数处理问题==，因此==不建议输入的时候就除100单位换算==，因为会==造成精度缺失问题==，这也是测试点0的坑点！**
> **建议在输出的时候再进行单位换算。**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e4 + 10;  //编号从1开始

struct P {
  int id;  //后面初始化
  int num = 0;
  double price = 0;
};
bool cmp(P a, P b) {
  if (a.price == b.price) {
    if (a.num == b.num) {
      return a.id < b.id;  //递增
    }
    return a.num > b.num;  //递减
  }
  return a.price > b.price;  //递减
}
vector<P> peo;
int main() {
  int n;
  cin >> n;
  peo.resize(n + 1);
  FOR(i, 0, n + 1) peo[i].id = i;  //初始化编号
  peo[0].price = INT_MAX;          //防止干扰
  FOR(i, 1, n + 1) {               // i是发红包人的编号
    int k;
    cin >> k;
    FOR(j, 0, k) {
      int id, prc;  //收红包人的编号以及这里收到的钱
      cin >> id;
      cin >> prc;
      peo[id].price += prc;  //读入的单位是分
      peo[id].num++;
      peo[i].price -= prc;
    }
  }
  sort(peo.begin(), peo.end(), cmp);
  FOR(i, 1, n + 1) { printf("%d %.2lf\n", peo[i].id, peo[i].price / 100); }
  return 0;
}
```

## [L2-010 排座位 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680)|并查集

> 朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的
>
> 每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出`No problem`；如果他们之间并不是朋友，但也不敌对，则输出`OK`；如果他们之间有敌对，然而也有共同的朋友，则输出`OK but...`；如果他们之间只有敌对关系，则输出`No way`。

乍一看，有点要用 `种类并查集`的意思，但实际上：

> 一般的并查集，维护的是具有==连通性、传递性==的关系，例如**亲戚的亲戚是亲戚**。但是，有时候，我们要维护另一种关系：**敌人的敌人是朋友**。种类并查集就是为了解决这个问题而诞生的。
>
> 维护的是一种**循环对称**的关系。
>
> 所以如果是三个及以上的集合，只要每个集合都是等价的，且集合间的每个关系都是等价的，就能够用种类并查集进行维护。

也就是说 只有==敌人的敌人是朋友==的情况才用种类并查集，所以这里简单存储一下 敌对关系即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 105;  //从1开始编号

int f[N], g[N][N];
int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
int query(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa == fb) {
    if (g[a][b]) return 3;
    return 1;
  } else {
    if (g[a][b]) return 4;
    return 2;
  }
}
void print(int q) {
  if (q == 1)
    cout << "No problem\n";
  else if (q == 2)
    cout << "OK\n";
  else if (q == 3)
    cout << "OK but...\n";
  else if (q == 4)
    cout << "No way\n";
}
int main() {
  FOR(i, 0, N << 1) f[i] = i;
  int n, m, k;
  cin >> n >> m >> k;
  FOR(i, 0, m) {
    int a, b, flag;
    cin >> a >> b >> flag;
    if (flag == 1)
      merge(a, b);
    else
      g[a][b] = g[b][a] = 1;
  }
  FOR(i, 0, k) {
    int a, b;
    cin >> a >> b;
    print(query(a, b));
  }
  return 0;
}
```







## [L2-011 玩转二叉树 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784)|二叉树|前序+中序=>层序

关于镜面反转一棵树，只需要在记录 下标时，**左孩子为2 \* index + 2， 右孩子为2 \* index + 1** 

递归完成后level数组中非-1的数就是按照下标排列的层序遍历的顺序

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;

vector<int> pre, in;
map<int, int> lev;
void level(int root, int start, int end, int index) {
  if (start > end) return;  //记得退出条件
  int i = start;
  while (i < end && in[i] != pre[root]) i++;
  lev[index] = pre[root];
  level(root + 1, start, i - 1, index * 2 + 2);
  level(root + 1 + i - start, i + 1, end, index * 2 + 1);
}
int main() {
  int n;
  cin >> n;
  pre.resize(n);
  in.resize(n);
  FOR(i, 0, n) cin >> in[i];
  FOR(i, 0, n) cin >> pre[i];
  level(0, 0, n - 1, 0);
  auto it = lev.begin();
  cout << it->second;
  while (++it != lev.end()) cout << " " << it->second;
  return 0;
}
```



## [L2-012 关于堆的判断 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805064676261888)|make_heap

`make_heap`非常方便~

主要麻烦在于处理输入的字符串

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl

int n, m, x;
int heap[1001];
vector<int> a;
map<int, int> mp;  //插入的整数对应的下标

int main() {
  cin >> n >> m;
  FOR(i, 0, n) {
    cin >> x;
    a.push_back(x);
    make_heap(a.begin(), a.end(), greater<int>());
  }
  for (int i = 0; i < n; i++) {
    heap[i + 1] = a[i];  //使堆下标从1 开始，方便操作
  }
  for (int i = 1; i <= n; i++) mp[heap[i]] = i;
  int x, y;
  string s;
  for (int i = 0; i < m; i++) {
    cin >> x;
    cin >> s;
    //对每个命题的情况进行判断
    if (s[0] == 'a') {
      cin >> y >> s >> s;
      if (mp[x] / 2 == mp[y] / 2)  //兄弟结点就是 父节点一样
        printf("T\n");
      else
        printf("F\n");
    } else {
      cin >> s;
      cin >> s;
      if (s[0] == 'r') {
        if (mp[x] == 1)  //根节点下标为1
          printf("T\n");
        else
          printf("F\n");
      } else if (s[0] == 'p') {
        cin >> s;
        cin >> y;
        if (mp[x] == mp[y] / 2)  // x是y父节点，即x下标等于 y下标/2
          printf("T\n");
        else
          printf("F\n");
      } else if (s[0] == 'c') {
        cin >> s;
        cin >> y;
        if (mp[y] == mp[x] / 2)  // x是y的一个子结点，即y等于 x下标/2
          printf("T\n");
        else
          printf("F\n");
      }
    }
  }

  return 0;
}

```

## [L2-013 红色警报 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208)|并查集

每次被攻占都重新初始化 、计算`fa`，统计连通块数量是否减少

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1000;
int f[N];
bool lost[N];
int find(int a) { return f[a] == a ? a : f[a] = find(f[a]); }
void merge(int a, int b) {
  int fa = find(a), fb = find(b);
  if (fa != fb) {
    f[fa] = f[fb];
  }
}
void init() { FOR(i, 0, N) f[i] = i; }

vector<PII> es;
int main() {
  int n, m;
  cin >> n >> m;
  init();
  FOR(i, 0, m) {
    int a, b;
    cin >> a >> b;
    es.push_back({a, b});
    merge(a, b);
  }
  int num = 0;
  FOR(i, 0, n) {
    if (f[i] == i) num++;
  }
  int k;
  cin >> k;
  FOR(i, 0, k) {
    int numx = 0;
    init();
    int x;
    cin >> x;
    lost[x] = 1;
    FOR(j, 0, m) {
      int a = es[j].first, b = es[j].second;
      // dbg(a);
      // dbg(b);
      if (!lost[a] && !lost[b]) {
        merge(a, b);
      }
    }
    FOR(j, 0, n) {
      if (f[j] == j && !lost[j]) numx++;
    }
    // dbg(numx);
    if (numx > num) {
      cout << "Red Alert: City " << x << " is lost!\n";
    } else {
      cout << "City " << x << " is lost.\n";
    }
    if (numx == 0) {
      cout << "Game Over.\n";
    }
    num = numx;
  }
  return 0;
}
```





## [**L2-014 列车调度 (25 分)**|](https://pintia.cn/problem-sets/994805046380707840/problems/994805063166312448)set|upper_bound

如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨；否则，选择一个**最接近（比他大）它车号的尾部车号**的队伍进入

只需要保存每一队的队尾车号，并且每一次都需要排序，那么可以选用 `set`来存储

其中最大值就是 `*st.rbegin()`

- 待插入的小于最大值：选择一个**最接近它车号的尾部车号**的队伍进入——移出第一个比他大的（最接近的），再插入
  - `s.upper_bound(t)`返回的是`第一个大于t`的迭代器的位置
    在前面加星号表示取这个位置的值
    所以`s.erase(*(s.upper_bound(t)));`表示删除当前这个刚好大于t的位置处的值
- 待插入的大于最大值：直接插入一个新的，作为新的队伍

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;
set<int> st;
int main() {
  int n;
  cin >> n;
  st.insert(0);  //方便一开始有 st.rbegin()
  FOR(i, 0, n) {
    int t;
    cin >> t;
    if (t < *st.rbegin()) st.erase(*(st.upper_bound(t)));
    st.insert(t);
  }
  cout << st.size() - 1;
  return 0;
}
```

## L2-015 互评成绩 (25 分)|自定义排序

简单模拟，本质就是获取排序后的 1~k-1 个成绩之和以及自定义排序

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 10005;

struct stu {
  vector<int> goal;
  int avgSum = 0;
};
bool cmp(stu a, stu b) { return a.avgSum > b.avgSum; }
vector<stu> vs;

int n, k, m;
int main() {
  cin >> n >> k >> m;
  vs.resize(n);
  FOR(i, 0, n) {
    vs[i].goal.resize(k);
    FOR(j, 0, k) { cin >> vs[i].goal[j]; }
    sort(vs[i].goal.begin(), vs[i].goal.end());
    FOR(j, 1, k - 1) { vs[i].avgSum += vs[i].goal[j]; }
  }
  sort(vs.begin(), vs.end(), cmp);
  printf("%.3lf", vs[m - 1].avgSum * 1.0 / (k - 2));
  for (int i = m - 2; i >= 0; i--) {
    printf(" %.3lf", vs[i].avgSum * 1.0 / (k - 2)); //最后再转换为 double，防止浮点数精度缺失带来的问题
  }
  return 0;
}
```

## **[L2-016 愿天下有情人都是失散多年的兄妹 (25 分)](https://pintia.cn/problem-sets/994805046380707840/problems/994805061769609216)**|DFS|BFS|⭐

- 共同祖先 
  - 往上搜的时候，要么嵌套搜；要么分开两次搜，第一次搜a，并记录下来，第二次搜b 并对照搜a 时候获取的数据—— ==st 是否标记过了==
- 题目虽然说的是祖父母，但是不只是爷爷奶奶 还有 外公外婆，递归的时候要注意
- 还有就是  ==需要查询的 不一定是给出的本人id 还可能是 上面数据中的父母==——所以还需要记录父母性别。（这个还真有点ex）

DFS：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)
const int N = 1e5 + 10;  // n范围是1e4，但是 id是五位数

struct people {
  int sex, fa = -1, mo = -1;
} peo[N];

bool st[N], flag;
void dfsA(int cur, int generation) {
  if (generation > 5 || cur == -1) return;
  st[cur] = 1;  //标记
  dfsA(peo[cur].fa, generation + 1);
  dfsA(peo[cur].mo, generation + 1);
}
void dfsB(int cur, int generation) {
  if (generation > 5 || cur == -1) return;
  if (st[cur]) {  //查询标记
    flag = 1;
    return;
  }
  dfsB(peo[cur].fa, generation + 1);
  dfsB(peo[cur].mo, generation + 1);
}
int main() {
  ios::sync_with_stdio(false);
  int n;
  cin >> n;
  FOR(i, 0, n) {
    int id;
    char s;
    cin >> id >> s;
    peo[id].sex = s == 'M' ? 1 : 0;
    cin >> peo[id].fa >> peo[id].mo;
    //父母性别也要记录
    peo[peo[id].fa].sex = 1;
    peo[peo[id].mo].sex = 0;
  }
  cin >> n;
  int a, b;
  FOR(i, 0, n) {
    cin >> a >> b;
    if (peo[a].sex == peo[b].sex)
      puts("Never Mind");
    else {
      memset(st, 0, sizeof st);  //记得重置
      dfsA(a, 1);
      flag = 0;
      dfsB(b, 1);
      if (flag)
        puts("No");
      else
        puts("Yes");
    }
  }
  return 0;
}
```

BFS 也是可以的：

- 把每个人和他们的祖先们压入一个set里面，==判断set前后有没有大小改变==，如果没改变说明重复了，所以有相同祖先，所以就输出No 。（当然这里像上面简单的用数组标记也可以）
- 用level数组标记他们当前的层数在push一层的时候令他们的层数为上一层+1，一直到五层判断结束。
- 如果结束了还没有输出过No，那么就输出yes。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, n, m) for (int i = n; i < m; ++i)
using namespace std;
const int N = 1e5 + 5;
struct man {
  int f = -1, m = -1, sex;
} peo[N];
int level[N];  

int main() {
  int n, m, id, father, mother, a, b;
  cin >> n;
  char c;
  for (int i = 0; i < n; i++) {
    cin >> id >> c >> father >> mother;
    peo[id].f = father, peo[id].m = mother;
    peo[id].sex = c == 'M' ? 0 : 1;
    peo[father].sex = 0;
    peo[mother].sex = 1;
  }
  cin >> m;
  for (int i = 0; i < m; i++) {
    fill(level, level + N, 0);  //重置
    cin >> a >> b;
    if (peo[a].sex == peo[b].sex) {
      printf("Never Mind\n");
      continue;
    }
    queue<int> q;
    q.push(a);
    q.push(b);
    level[a] = 1;
    level[b] = 1;
    set<int> s;  //通过比照这个标记来判断是否有共同祖先
    int flag = 0;
    while (!q.empty()) {
      int top = q.front();
      q.pop();
      int size = s.size();
      s.insert(top);
      if (size == s.size()) {  //有共同祖先
        printf("No\n");
        flag = 1;
        break;  //跳出
      }
      if (level[top] <= 4) {  //在五代之内的话才判断
        int fa = peo[top].f;
        int mo = peo[top].m;
        if (fa != -1) {
          q.push(fa);
          level[fa] = level[top] + 1;
        }
        if (mo != -1) {
          q.push(mo);
          level[mo] = level[top] + 1;
        }
      }
    }
    if (flag == 0) printf("Yes\n");  //一切正常，Yes
  }
  return 0;
}
```

## L2-017 人以群分 (25 分)|EASY

要求两类人群的规模尽可能接近，而他们的总活跃度差距尽可能拉开。

题目保证这些数字以及它们的和都不会超过2^31^。——也就是 int 范围

排序后特判一下n为奇数的情况就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 100005;

vector<int> peo;
int main() {
  int n;
  cin >> n;
  peo.resize(n);
  FOR(i, 0, n) { cin >> peo[i]; }
  sort(peo.begin(), peo.end(), less<int>());
  int front = 0, back = 0;
  // n=7,[0,2],[3,6]
  FOR(i, 0, n / 2) { front += peo[i]; }
  FOR(i, n / 2, n) { back += peo[i]; }
  int tmp = abs(front - back);
  if (n % 2 == 0) {  // n为偶数没什么好考虑的
    printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2, n / 2, tmp);
  } else {
    //分割线换一下试试
    front += peo[n / 2 + 1];
    back -= peo[n / 2 + 1];
    // dbg(abs(front - back));
    if (abs(front - back) > tmp) {
      printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2, n / 2 + 1,
             abs(front - back));
    } else {
      // dbg(tmp);
      printf("Outgoing #: %d\nIntroverted #: %d\nDiff = %d", n / 2 + 1, n / 2,
             tmp);
    }
  }
  system("pause");
  return 0;
}
```

## L2-018 多项式A除以B (25 分)|复杂模拟|==不会写==

==我自己是写不出来的==

对于两个多项式A和B，题目给出的必定不会是连续降幂的，根据**多项式的除法原理**，我们需要缺幂项补零

题中给出的==x^4^-3x^2^-x-1==是缺3次幂的，将缺幂项补上之后，就变成了 ==x^4^+0x^3^-3x^2^+x-1==

用一个数组来保存一个多项式，即数组的`下标对应多项式的指数`，下标对应的单元表示多项式的系数，如数组`[-1, -1, -3, 0, 1]。`。

![Screenshot_20220306_210513_com.jideos.jnotes](https://gitee.com/okkjoo/image-bed/raw/master/imgs/Screenshot_20220306_210513_com.jideos.jnotes.png)

即每次除法`商`的最高次幂 `t1-t2`，系数为`A[t1] / B[t2]`，每次都放变化后的`A、B`最高次幂以及对应系数。下方式子的变化`A[i] -= B[i – (t1 – t2)] * A[t1] / B[t2]`, 其中`i`从A的最高次幂`t1`到大于等于`t1 – t2`, 这样就算完成了`一行的`除法。**重复上面的步骤, 直到A的最高项幂次小于B的最高项幂次, 此时的`A就是余项`。**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl

//返回 c[]式子里有几个非零项，start:最高次幂
int nonNegativeNum(double c[], int start) {
    int cnt = 0;
    for (int i = start; i >= 0; i--)
        if (abs(c[i]) + 0.05 >= 0.1) cnt++;
    return cnt;
}
void printPoly(double c[], int start) {
    printf("%d", nonNegativeNum(c, start));
    //最后结果为0的情况，(不会写这题的话，也可以按这个点骗点分)
    if (nonNegativeNum(c, start) == 0) printf(" 0 0.0");
    for (int i = start; i >= 0; i--)  //按指数递减输出
        if (abs(c[i]) + 0.05 >= 0.1) printf(" %d %.1f", i, c[i]);
}
double c1[3000], c2[3000], c3[3000];
int main() {
    int m = 0, n = 0,                 // m、n分别为两式非零项的个数
    t = 0, max1 = -1, max2 = -1;  // max1、max2分别为两个式子的最高次幂
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> t;  //指数
        max1 = max1 > t ? max1 : t;
        cin >> c1[t];  //指数作为下标，对应的系数; 没有的就是0
    }
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> t;
        max2 = max2 > t ? max2 : t;
        cin >> c2[t];
    }
    int t1 = max1, t2 = max2;
    while (t1 >= t2) {
        double c = c1[t1] / c2[t2];  //商最高次幂项对应系数
        c3[t1 - t2] = c;  //商：t1-t1 就是最高次幂，放入对应系数
        //  for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[j] * c;
        for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[i-(t1-t2)] * c;
        while (abs(c1[t1]) < 0.000001) t1--;  //系数可以约去之和，t1 后移
    }
    printPoly(c3, max1 - max2);  //输出商
    printf("\n");
    printPoly(c1, t1);  //输出余
    return 0;
}
```

## L2-019 悄悄关注 (25 分)|

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 5000;   //用户编号从1开始
map<string, int> mp;  //<name, 赞>
set<string> att;
set<string> ans;
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    string s;
    cin >> s;
    att.insert(s);
  }
  cin >> n;
  double avg = 0;
  FOR(i, 0, n) {
    string s;
    int d;
    cin >> s >> d;
    mp[s] = d;
    avg += d;
  }
  avg /= n;
  for (auto &t : mp) {
    if (att.count(t.first) == 0 && t.second > avg) {
      ans.insert(t.first);
    }
  }
  for (auto &t : ans) {
    cout << t << endl;
  }
  if (ans.size() == 0) cout << "Bing Mei You";
  system("pause");
  return 0;
}
```

## L2-020 功夫传人 (25 分)|DFS

超时了最后一个测试点

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e5 + 5;  //从0开始 祖师爷为0
int dedao[N];           //无道就是0，得道存储其倍数
int f[N];               //其师傅
double ans = 0;
int main() {
ios::sync_with_stdio(false);
  db n, z, r;
  cin >> n >> z >> r;
  r = 1 - (0.01 * r);
  FOR(i, 0, n) {
    int k;
    cin >> k;
    if (k == 0) {
      int x;
      cin >> x;
      dedao[i] = x;
      // dbg(dedao[i]);
    }
    FOR(j, 0, k) {
      int x;
      cin >> x;
      f[x] = i;  //记录师傅
    }
  }
  FOR(i, 0, n) {
    if (dedao[i]) {
      int x = i, c = 0;  // c:削弱了多少次
      while (x != 0) {   //还没到祖师爷
        x = f[x];
        c++;
      }
      ans += z * pow(r, c) * dedao[i];
    }
  }
  cout << (int)ans;
  system("pause");
  return 0;
}
```

想了想可以优化的地方，其实可以就**一次递归**，然后遇到得到者记录下来即可

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << #x << " = " << x << endl
const int N = 1e5 + 5;  //从0开始 祖师爷为0
vector<db> peo[N];
int dedao[N];  //无道就是0，得道存储其倍数
// int f[N];      //其师傅
double ans = 0;
db n, z, r;
void dfs(int idx, db power) {
  if (dedao[idx]) {
    ans += dedao[idx] * power;
  }
  int sz = peo[idx].size();
  FOR(i, 0, sz) { dfs(peo[idx][i], power * (1 - r / 100)); }
}
int main() {
  cin >> n >> z >> r;
  FOR(i, 0, n) {
    int k;
    cin >> k;
    if (k == 0) {
      int x;
      cin >> x;
      dedao[i] = x;
      // dbg(dedao[i]);
    }
    FOR(j, 0, k) {
      int x;
      cin >> x;
      peo[i].push_back(x);
      // f[x] = i;  //记录师傅
    }
  }
  // FOR(i, 0, n) {
  //   if (dedao[i]) {
  //     int x = i, c = 0;  // c:削弱了多少次
  //     while (x != 0) {   //还没到祖师爷
  //       x = f[x];
  //       c++;
  //     }
  //     ans += z * pow(r, c) * dedao[i];
  //   }
  // }
  dfs(0, z);
  cout << (int)ans;
  system("pause");
  return 0;
}
```

## L2-021 点赞狂魔 (25 分)|自定义排序

- 统计每个人点赞的不同标签的数量，找出数量最大的前3名
- 如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列
- 若不足3人，则用`-`补齐缺失，例如`mike jenny -`就表示只有2人

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 105;
// multimap<int, string> mp;  //<不同标签数量，名字> ; multimap:key可重复的map
struct node {
  string name;
  set<int> tag;
  double avg = 0;  //标签出现次数平均值
};
bool cmp(node a, node b) {
  if (a.tag.size() == b.tag.size()) {
    return a.avg < b.avg;
  }
  return a.tag.size() > b.tag.size();
}
vector<node> peo(N);
int main() {
  int n;
  cin >> n;
  FOR(i, 0, n) {
    string s;
    int k;
    cin >> s;
    peo[i].name = s;
    cin >> k;
    double cnt = 0; //注意用 double 或者在下面赋值 avg 的时候*1.0
    FOR(j, 0, k) {
      int x;
      cin >> x;
      peo[i].tag.insert(x);
      cnt++;
    }
    peo[i].avg = cnt / peo[i].tag.size();
  }
  sort(peo.begin(), peo.end(), cmp);
  if (peo[0].avg == 0) {
    cout << "-";
  } else {
    cout << peo[0].name;
  }
  FOR(i, 1, 3) {
    // dbg(peo[i].avg);
    if (peo[i].avg == 0)
      cout << " -";
    else
      cout << " " << peo[i].name;
  }
  system("pause");
  return 0;
}
```

## L2-022 重排链表 (25 分)|复杂模拟|==有点东西==

需要三个存储结构

- 存储一开始的数据   `a`
- 整理初始数据为链表 `v`
- 最后答案的链表 `ans`
  - 使用两个指针来对 `v`重新排列后放入 `ans`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;

struct node {
  int add, data, nxt;
};
node a[N];  //下标也是地址，方便理顺链表
vector<node> v, ans;

int main() {
  int begin, n;
  cin >> begin >> n;
  FOR(i, 0, n) {
    int _add, _data, _nxt;
    cin >> _add >> _data >> _nxt;
    a[_add] = {_add, _data, _nxt};
  }
  while (begin != -1) {
    v.push_back({a[begin].add, a[begin].data, a[begin].nxt});
    begin = a[begin].nxt;
  }
  int l = 0, r = n - 1; //用 n 会有测试点3过不去的情况，用 v.size() 就不会错
  while (l < r) {//这里是有问题的，测试点1过不去
    ans.push_back({v[r].add, v[r].data, v[r].nxt});
    ans.push_back({v[l].add, v[l].data, v[l].nxt});
    l++, r--;
  }
  // dbg(ans.size());
  FOR(i, 0, ans.size()) {
    if (i != ans.size() - 1)
        //输出 ans[i + 1].add 来实现 应该有的 next， 存的 ans[i].nxt 并不是真正的 next
      printf("%05d %d %05d\n", ans[i].add, ans[i].data, ans[i + 1].add);
    else
      printf("%05d %d -1", ans[i].add, ans[i].data);
  }
  system("pause");
  return 0;
}
```

关于测试点：https://blog.csdn.net/weixin_45962741/article/details/115614608

- 测试点1：奇数个结点，自然不能两个指针同时移动后再判断是否需要跳出
- 测试点3：多余结点可还行，此时 n 就不等于 v.size() 

AC：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)
#define dbg(x) cout << "## " << #x << " = " << x << endl
const int N = 1e5 + 5;

struct node {
  int add, data, nxt;
};
node a[N];  //下标也是地址，方便理顺链表
vector<node> v, ans;

int main() {
  int begin, n;
  cin >> begin >> n;
  FOR(i, 0, n) {
    int _add, _data, _nxt;
    cin >> _add >> _data >> _nxt;
    a[_add] = {_add, _data, _nxt};
  }
  while (begin != -1) {
    // v.push_back({a[begin].add, a[begin].data, a[begin].nxt});
    //其实就是
    v.push_back(a[begin]);
    begin = a[begin].nxt;
  }
  // dbg(n);
  // dbg(v.size());
  int l = 0, r = v.size() - 1;//****
  while (1) {//****
    ans.push_back(v[r]);
    r--;
    if (l > r) break;
    ans.push_back(v[l]);
    l++;
    if (l > r) break;
  }
  // dbg(ans.size());
  FOR(i, 0, ans.size()) {
    if (i != ans.size() - 1) 
      //输出 ans[i + 1].add 来得到 应该有的 next， 存的 ans[i].nxt 并不是真正的next
      printf("%05d %d %05d\n", ans[i].add, ans[i].data, ans[i + 1].add);
    else
      printf("%05d %d -1", ans[i].add, ans[i].data);
  }
  system("pause");
  return 0;
}
```







## [L2-030 冰岛人](https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858887)|模拟|map、pair

孩子的姓等于父亲的名加后缀;输入格式：` 名 姓`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

#define pis pair<int, string>

int N, M;
string fName, sName, tmp;
map<string, pis> record;  //<名字,<性别1男 0女, 姓氏> >
string check(string a, string b) {
  int cnt1 = 0, cnt2;
  while (a != "") {
    cnt2 = 0;
    string b2 = b;
    while (b2 != "") {
      //共同祖先在五代之内
      // 只有嵌套才能找到共同祖先的情况
      if (a == b2 && (cnt1 < 4 || cnt2 < 4)) return "No\n";  //找到共同祖先
      if (cnt1 >= 4 && cnt2 >= 4) return "Yes\n";
      b2 = record[b2].second;  //搜他的姓氏，即他的父亲
      cnt2++;
    }
    a = record[a].second;  //搜他的姓氏，即他的父亲
    cnt1++;
  }
  //搜到最后祖宗还是没满足退出条件 就说明可行
  return "Yes\n";
}
int main() {
  cin >> N;
  while (N--) {
    cin >> fName >> sName;  //名 姓
    if (sName.back() == 'n')
      record[fName] = {1, sName.substr(0, sName.size() - 4)};
    else if (sName.back() == 'r')
      record[fName] = {0, sName.substr(0, sName.size() - 7)};
    else if (sName.back() == 'm')
      record[fName].first = 1;
    else
      record[fName].first = 0;
  }
  cin >> M;
  while (M--) {
    cin >> fName >> tmp >> sName >> tmp;  //姓没用，名有；只读名
    if (!record.count(fName) || !record.count(sName))
      cout << "NA\n";
    else if (record[fName].first == record[sName].first)
      cout << "Whatever\n";
    else
      cout << check(fName, sName);
  }
  return 0;
}
```

## **L2-035 完全二叉树的层序遍历 (25 分)**|后序遍历->层序

详细注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

vector<int> post;
map<int, int> level;
int n, idx;
//后序遍历
void dfs(int levIt) {  //传入的其实是 层序数组 的指针
  if (levIt > n) return;  //层序遍历和后序遍历得到的数组大小肯定都是n
  dfs(2 * levIt);              //左, 递
  dfs(2 * levIt + 1);          //右, 递
  level[levIt] = post[idx++];  //中, 归到这里时 idx 已经到了后面
}
int main() {
  cin >> n;
  post.resize(n);
  FOR(i, 0, n) cin >> post[i];
  dfs(1);
  auto it = level.begin();
  cout << it->second;
  while (++it != level.end()) cout << " " << it->second;
}
```



## **L3-007 天梯地图 (30 分)**

> 题目： https://pintia.cn/problem-sets/994805046380707840/problems/994805051153825792

- 给图招路，图中有单向边
- 一条最快中最短
- 一条最短中节点最少
- 有上面两条为一条的情况
- 数据量： 点数[2,500]

- 两个 Dijkstra：最快、最短
- 用一个二维数组存储所有结点的最短路径，DFS 求出结点最少的那条

[代码+注释](./code/L3-007.cpp)

## **L3-008 喊山 (30 分)**

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050709229568

- `n`（≤10000）是总的山头数
- 一个山头呼喊的声音可以被临近的山头同时听到，每个山头最多有两个能听到它的临近山头
- 给出起点山头，找出最远能传到的地方
- 如果不止一个最远山头，就输出编号最小的
- 广度优先搜索

[代码+注释](./code/L3-008.cpp)

## **L3-009 长城 (30 分)**

> 题目：https://pintia.cn/problem-sets/994805046380707840/problems/994805050277216256

- 长城，烽火台。烽火台在其折线点上
- 接收 n 个长城边缘折线点坐标——从南到北给
- 坐标 ∈[-10^9, 10^9]
- 总部在最南
- 要保证每个位置都能有南侧的烽火台能观望到
- 求烽火台最少数目

- 假设当前点为 A，他的右边有相邻点 B，C，此时若是 AC\*AB<0，即 AB 在 AC 上方，此时 B 为凸点。

![image-20211110110250589](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110110250589.png)

- 但并不是单纯的凸点记入，凹点舍弃，比如下图的情况

  ![image-20211110204916475](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211110204916475.png)

  这情况明显只需要中间蓝色的圈和右边红色的圈即可

  (_其实一开始是想右边两个圈蓝色的，但是画错了，不想重新画了)_

  但是只判断凹凸的话，就会把左边红圈点也记入。

  明显用多了一个

  也就是说，每个烽火台观察的点不是连续的——那么就要用到栈来辅助判断。

- 从南到北——即从右到左依次入栈，判断栈顶点是否为凸点。是则记入，不是则舍弃。**凸点会继续参与比较，凹点会被弹出。**

- 当栈中存在大于 2 个的点时，表示 b 点为烽火

- 用 set 去重

[代码+注释](./code/L3-009.cpp)

## L3-010 是否完全二叉搜索树

- 给定二叉搜索树（定义左子树大、右子树小）

- 给出层序遍历结果

- 判断是否为完全二叉搜索树

- 根据二叉树性质即可：i 节点左孩子为 i<<1 右孩子为 i<<1|1
- 判断是否完全：输出完 n 个点前，出现空节点就不是完全

[代码+注释](./code/L3-010.cpp)

## L3-011 直捣黄龙

- 三个条件：最快>城镇最多>有效杀伤最多
- 存储：最合适路径、最快路数、最短进攻距离、歼敌总数
- 数据量：城镇数 ∈[2, 200]

- 将字符串与数字做映射，方便操作
- Dijskra

[代码+注释](./code/L3-011.cpp)
