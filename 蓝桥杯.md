> 准备三四月份蓝桥杯的笔记

# 说在前面的套路

时间限制：C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过108,则可能会超时

- **由数据范围反推算法复杂度以及算法内容**——来自y神

![image-20211210112521113](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

- 若输入输出 范围 小于 105 推荐用 `cin / cout` 否则用 `scanf / printf` 输入时间会快一倍左右

# 题目

## DFS

### 116. 飞行员兄弟|DFS|位运算|暴力枚举

- 矩阵
- 变一个位置就是变一个十字
- 先级整体从上到下，同行从左到右打开——先看第一行...

=>

- 暴力枚举——位运算 （这个看起来更聪明点🐶）
  - 也可以DFS+直接操作字符数组

- 用一个十六位的二进制数模拟棋盘状态：0~2^16-1
  - 解题思路：这道题目解题思路大致是，首先我们可以构造一个16位的二进制数，然后呢，二进制数的每一位代表4*4矩阵中的一位，例如1代表(1,1),2代表(1,2),3代表(1,3),4代表(1,4),5代表(2,1)。既然这样的话，那么我们只需要枚举这个16位的二进制数，就可以确定我们的方案，因为题目只需要最优解方案，所以时间复杂度大约是O(16 * 2^16)
- get 获得位数
- change 通过**异或**操作进行反转开关操作
  - 01互相反转 == 与1异或

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

/*  DFS+直接操作字符数组
typedef pair<int,int> PII;
PII ans[20],cur[20];
char c[6][6];
int sum;
void turn(int x,int y)
{       for(int i=0;i<4;i++)
        {
            if(c[i][y]=='+') c[i][y]='-';
            else  c[i][y]='+';
        }
        for(int i=0;i<4;i++)
        {
            if(c[x][i]=='+') c[x][i]='-';
            else  c[x][i]='+';
        }
         if(c[x][y]=='+') c[x][y]='-';
            else  c[x][y]='+';
}
bool check(char c[][6])
{   for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
        if(c[i][j]=='+')
           return false; 

     return true; 

}
void dfs(int x,int y,int res){
        if(x==4)
        {
            if(check(c)&&res<sum)
            {   memcpy(ans,cur,sizeof(ans));
                sum=res;
            }
            return;
        }
        int dx=x,dy=y+1;
        if(dy==4){
            dx++,dy=0;
        }
        turn(x,y);
        cur[res+1]={x,y};
        dfs(dx,dy,res+1);
        turn(x,y);
        dfs(dx,dy,res);


}
int main()
{   for(int i=0;i<4;i++)  cin>>c[i];
    sum=0x3f3f3f3f;
    dfs(0,0,0);
    cout<<sum<<endl;
    for(int i=1;i<=sum;i++)
    {
        cout<<ans[i].first+1<<" "<<ans[i].second+1<<endl;
    }


    return 0;
}
 */


int change[4][4];
int get(int x, int y){//获取位数
	return x*4 + y;
}
int main(){
	int state = 0;//棋盘状态
	for(int i =0 ; i<4; i++){
		string line;
		cin>>line;
		for(int j = 0;j<4;j++){
			if(line[j] == '+')
				state += 1 << get(i,j);			
		}
	} 

	//预处理
	for(int i = 0; i < 4; i++)
	for(int j =0; j<4; j++){
		for(int k=0; k < 4; k++){
			change[i][j] += 1<<get(i, k);
			change[i][j] += 1<<get(k, j);
		}
		change[i][j] -= 1<<get(i, j);//行列操作后多操作了一次，要减去
	}
	vector<PII> res;
	for(int k = 0;k< 1<<16; k++){//暴力遍历
		int now = state;//存一下当前局面
		vector<PII> path;
		for(int i =0; i<16; i++){//如果k的某一位是1，就表示需要操作
			if(k >>i & 1){
				//对编号是i的格子进行操作
				int x = i/4, y = i%4;//找到他的行列位置
				now ^= change[x][y];
				path.push_back({x, y});
			}
			if(!now && (res.empty()|| res.size() >path.size())){
			//全0说明合法 && （原先res为空 || 新的方法步骤更少）
				res = path;
			}
		}
	}
	cout<<res.size()<<endl;
	for(auto p:res)cout<< p.first+1<<" "<<p.second+1<<endl;
}
```

## 二分与前缀和

### [AcWing789.数的范围](https://www.acwing.com/problem/content/791/)|二分

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

int n, q, x;
int a[100005];
int main(){
	scanf("%d%d",&n,&q);
	for(int i =0 ;i<n;i++){
		scanf("%d",&a[i]);
	}
	while(q--){
		scanf("%d",&x);
		int l = 0, r = n;
		//搜左边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) r = mid;//找到了收缩右边以达到找到左边界的效果
			else if(a[mid] < x) l = mid + 1;
			else if(a[mid] > x) r = mid;
		}
		if(a[l] != x) {printf("-1 -1\n");continue;}
		int left = l;
		r = n;
		//搜右边界
		while(l < r){
			int mid = l+r>>1;
			if(a[mid] == x) l = mid+1;//收缩左边以达到找到右边界的效果
			else if( a[mid] < x) l = mid + 1;
			else if( a[mid] > x) r = mid;
		}
		printf("%d %d\n",left,l-1);
		//因为l = mid+1; 退出来时l在mid+1上，而需要返回mid即mid-1
	}
}
```

### [AcWing790.数的三次方根](https://www.acwing.com/problem/content/792/)|二分

> 给定一个浮点数 n ，求它的三次方根。
>
> #### 输入格式
>
> 共一行，包含一个浮点数 n。
>
> #### 输出格式
>
> 共一行，包含一个浮点数，表示问题的解。
>
> 注意，结果保留 6位小数。
>
> #### 数据范围
>
> −10000≤n≤10000

直接二分搜索一个mid满足`mid*mid*mid`最接近n的——最接近就是误差小于`1e-8`

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

double x;

int main(){
  cin>>x;
  double l = -10000, r = 10000;
  while(r-l > 1e-8){//精度还不够的话
    double mid = (l+r)/2;
    if(mid*mid*mid >= x) r = mid;
    else l = mid;
  }
  printf("%.6lf",l);
}
```

- 使用cbrt函数也是可以的
- 或者pow——要先处理一下负数

```cpp
int main(){
    double a;
    scanf("%lf",&a);
    //if(x<0) printf("-") ,x=-x;
    //printf("%.6lf",pow(x,1/3.0));  // pow不能处理负数
    printf("%.6lf",cbrt(a));
    return 0;
}
```

---

**前缀和**

