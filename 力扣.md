# 力扣题解

## [206. 反转链表]单链表反转|递归|递推写法

### 递归写法

reverseList 定义：输入一个节点head，将「以head为起点」的链表反转，并返回反转之后的头结点。

那么在递归中`ListNode* last = reverseList(head->next);` 返回的 last 也就是 后面那一段的反转后的头结点。

`head->next->next = head;` 则是将原先head指向的下一个节点的next指了回来，也就是 后一段翻转过来后的尾部指向 head

`head->next = nullptr;` 则是将原先头结点指向 null ，因为此时他已经是尾部了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //base case
        if(head == nullptr || head->next == nullptr)return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};

```

### 递推写法

```cpp
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		ListNode *temp; // 保存cur的下一个节点
		ListNode *cur = head;
		ListNode *pre = NULL; //更新后的头
		while (cur)
		{
			temp = cur->next; // 保存一下 cur的下一个节点，因为接下来要改变cur->next
			cur->next = pre;  // 翻转操作
			//更新一下pre 和 cur指针
			pre = cur;	//pre移到现在cur所在
			cur = temp; //cur移到temp即原先的cur->next;
		}
		return pre;
	}
};
```

递推在时间和空间上都碾压递归，但我觉得递归的方法非常精妙——递归的魅力。



## [92.反转链表 Ⅱ]

反转一个区间的链表。怎么做呢。

我们可以先换个思考方向——**反转前n个**

```cpp
ListNode* successor = nullptr; // 后驱节点
ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            //记录第 n + 1 个节点
            successor = head->next;
            return head;
        }
    	// 以 head->next 为起点， 反转前 n - 1 个节点
        ListNode* last = reverseN(head->next, n-1);
        
        head->next->next = head;
    	// 让反转之后的 head 节点和后面的节点连起来
        head->next = successor;
        return last;        
    }
```

![image-20211115151904252](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211115151904252.png)

那么就可以开始实现反转链表的一部分了

` ListNode* reverseBetween(ListNode* head, int left, int right) `反转 [left, right], 那么当 left == 1 时，也就相当于前面的 反转前n个元素——不过这里是反转前 right 个元素罢了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next,n-1);
        
        head->next->next = head;
        head->next = successor;
        return last;
        
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1){
            //相当于反转前 right 个元素
            return  reverseN(head,right);
        }
		//前移反转起点来触发 left == 1 的情况
        head->next = reverseBetween(head->next,left-1,right-1);
        return head;
    }
};
```

递归方法非常精妙，但是效率确实低，不论是时间还是空间复杂度均为 O(N)

递推的话，至少空间是O(1)。

