> 准备三四月份蓝桥杯的笔记

# 说在前面的套路

时间限制：C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过108,则可能会超时

- **由数据范围反推算法复杂度以及算法内容**——来自y神

![image-20211210112521113](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211210112521113.png)

- 若输入输出 范围 小于 105 推荐用 `cin / cout` 否则用 `scanf / printf` 输入时间会快一倍左右

# 题目

## 116. 飞行员兄弟

- 矩阵
- 变一个位置就是变一个十字
- 先级整体从上到下，同行从左到右打开——先看第一行...

=>

- 暴力枚举——位运算 （这个看起来更聪明点🐶）
  - 也可以DFS+直接操作字符数组

- 用一个十六位的二进制数模拟棋盘状态：0~2^16-1
  - 解题思路：这道题目解题思路大致是，首先我们可以构造一个16位的二进制数，然后呢，二进制数的每一位代表4*4矩阵中的一位，例如1代表(1,1),2代表(1,2),3代表(1,3),4代表(1,4),5代表(2,1)。既然这样的话，那么我们只需要枚举这个16位的二进制数，就可以确定我们的方案，因为题目只需要最优解方案，所以时间复杂度大约是O(16 * 2^16)
- get 获得位数
- change 通过**异或**操作进行反转开关操作
  - 01互相反转 == 与1异或

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> PII;
#define FOR(i, n, m) for (int i = n; i < m; ++i)

/*  DFS+直接操作字符数组
typedef pair<int,int> PII;
PII ans[20],cur[20];
char c[6][6];
int sum;
void turn(int x,int y)
{       for(int i=0;i<4;i++)
        {
            if(c[i][y]=='+') c[i][y]='-';
            else  c[i][y]='+';
        }
        for(int i=0;i<4;i++)
        {
            if(c[x][i]=='+') c[x][i]='-';
            else  c[x][i]='+';
        }
         if(c[x][y]=='+') c[x][y]='-';
            else  c[x][y]='+';
}
bool check(char c[][6])
{   for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
        if(c[i][j]=='+')
           return false; 

     return true; 

}
void dfs(int x,int y,int res){
        if(x==4)
        {
            if(check(c)&&res<sum)
            {   memcpy(ans,cur,sizeof(ans));
                sum=res;
            }
            return;
        }
        int dx=x,dy=y+1;
        if(dy==4){
            dx++,dy=0;
        }
        turn(x,y);
        cur[res+1]={x,y};
        dfs(dx,dy,res+1);
        turn(x,y);
        dfs(dx,dy,res);


}
int main()
{   for(int i=0;i<4;i++)  cin>>c[i];
    sum=0x3f3f3f3f;
    dfs(0,0,0);
    cout<<sum<<endl;
    for(int i=1;i<=sum;i++)
    {
        cout<<ans[i].first+1<<" "<<ans[i].second+1<<endl;
    }


    return 0;
}
 */


int change[4][4];
int get(int x, int y){//获取位数
	return x*4 + y;
}
int main(){
	int state = 0;//棋盘状态
	for(int i =0 ; i<4; i++){
		string line;
		cin>>line;
		for(int j = 0;j<4;j++){
			if(line[j] == '+')
				state += 1 << get(i,j);			
		}
	} 

	//预处理
	for(int i = 0; i < 4; i++)
	for(int j =0; j<4; j++){
		for(int k=0; k < 4; k++){
			change[i][j] += 1<<get(i, k);
			change[i][j] += 1<<get(k, j);
		}
		change[i][j] -= 1<<get(i, j);//行列操作后多操作了一次，要减去
	}
	vector<PII> res;
	for(int k = 0;k< 1<<16; k++){//暴力遍历
		int now = state;//存一下当前局面
		vector<PII> path;
		for(int i =0; i<16; i++){//如果k的某一位是1，就表示需要操作
			if(k >>i & 1){
				//对编号是i的格子进行操作
				int x = i/4, y = i%4;//找到他的行列位置
				now ^= change[x][y];
				path.push_back({x, y});
			}
			if(!now && (res.empty()|| res.size() >path.size())){
			//全0说明合法 && （原先res为空 || 新的方法步骤更少）
				res = path;
			}
		}
	}
	cout<<res.size()<<endl;
	for(auto p:res)cout<< p.first+1<<" "<<p.second+1<<endl;
}
```

