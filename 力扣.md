# 力扣题解

## [206. 反转链表]单链表反转|递归|递推写法

### 递归写法

reverseList 定义：输入一个节点head，将「以head为起点」的链表反转，并返回反转之后的头结点。

那么在递归中`ListNode* last = reverseList(head->next);` 返回的 last 也就是 后面那一段的反转后的头结点。

`head->next->next = head;` 则是将原先head指向的下一个节点的next指了回来，也就是 后一段翻转过来后的尾部指向 head

`head->next = nullptr;` 则是将原先头结点指向 null ，因为此时他已经是尾部了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //base case
        if(head == nullptr || head->next == nullptr)return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};

```

### 迭代写法

```cpp
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		ListNode *temp; // 保存原本cur的下一个节点 用nxt指针或许更为合适
		ListNode *cur = head;
		ListNode *pre = NULL; //更新后的头
		while (cur)
		{
			temp = cur->next; // 保存一下 cur的下一个节点，因为接下来要改变cur->next
			cur->next = pre;  // 翻转操作
			//更新一下pre 和 cur指针
			pre = cur;	//pre移到现在cur所在
			cur = temp; //cur移到temp即原先的cur->next;
		}
		return pre;
	}
};
```

递推在时间和空间上都碾压递归，但我觉得递归的方法非常精妙——递归的魅力。



## [92.反转链表 Ⅱ]递归

反转一个区间的链表。怎么做呢。

我们可以先换个思考方向——**反转前n个**

```cpp
ListNode* successor = nullptr; // 后驱节点
ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            //记录第 n + 1 个节点
            successor = head->next;
            return head;
        }
    	// 以 head->next 为起点， 反转前 n - 1 个节点
        ListNode* last = reverseN(head->next, n-1);
        
        head->next->next = head;
    	// 让反转之后的 head 节点和后面的节点连起来
        head->next = successor;
        return last;        
    }
```

![image-20211115151904252](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20211115151904252.png)

那么就可以开始实现反转链表的一部分了

` ListNode* reverseBetween(ListNode* head, int left, int right) `反转 [left, right], 那么当 left == 1 时，也就相当于前面的 反转前n个元素——不过这里是反转前 right 个元素罢了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head,int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next,n-1);
        
        head->next->next = head;
        head->next = successor;
        return last;
        
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1){
            //相当于反转前 right 个元素
            return  reverseN(head,right);
        }
		//前移反转起点来触发 left == 1 的情况
        head->next = reverseBetween(head->next,left-1,right-1);
        return head;
    }
};
```

递归方法非常精妙，但是效率确实低，不论是时间还是空间复杂度均为 O(N)

迭代的话，至少空间是O(1)。

### 迭代法反转区间

与 第206题 类似

```cpp
//反转区间 [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //返回反转后的节点用于连接
        return pre;
    }
```



## [[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)]递归

该问题具有明显的递归性质。

如三个一组反转，那么将前三个反转后，后面的不就又是一条长度短三的链表？

1. 反转 head 开头的 k 个元素
2. 将第 k+1 个元素作为 head 参数传入递归函数
3. 将结果连接起来
4. ...重复

base case: 后面元素不足 k 个 了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //反转区间 [a, b)
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode *nxt, *pre, *cur = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        //返回反转后的节点用于连接
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)return nullptr;
        ListNode *a, *b;
        a = head, b = head;
        for(int i = 0; i < k; i++){
            //base case 
            if(b == nullptr) return head;
            b = b->next;
        }
        //反转前k个
        ListNode* newHead  =  reverse(a, b);
        //递归反转后序链表并与前面节点相连
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```

## [100.相同的树] | 二叉树

### 递归写法：

非常简单

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //递归
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr) return true;
        if(p == nullptr || q == nullptr) return false;
        if(p->val != q->val) return  false;
        return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
    }
};
```

### 迭代写法： 借助栈

```cpp
bool isSameTree(TreeNode* p, TreeNode* q) {
        stack<TreeNode*> st; //与队列差不多，但是用栈处理指针的顺序和队列相反
        st.push(p);
        st.push(q);
        while(!st.empty()){
            TreeNode* root1 = st.top();st.pop();
            TreeNode* root2 = st.top();st.pop();
            
            if(root1 == nullptr && root2 == nullptr) continue;            
            if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
            
            st.push(root1->left);
            st.push(root2->left);
            st.push(root1->right);
            st.push(root2->right);
        }
        return true;
    }
```

### 用队列也是一样的

```cpp
 bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<TreeNode*> que;  
    que.push(p);
    que.push(q);
    while(!que.empty()){
        TreeNode* root1 = que.front();que.pop();
        TreeNode* root2 = que.front();que.pop();
        
        if(root1 == nullptr && root2 == nullptr)continue;
        if(root1 == nullptr || root2 == nullptr || (root1->val != root2->val))return false;
 
        que.push(root1->left);
        que.push(root2->left);
        que.push(root1->right);
        que.push(root2->right);
    }
    return true;
}

```

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

找最长回文子串之前，先思考：怎么找回文子串？

**从中间往两边扩散来判断**,还有奇偶又怎么区分呢...

```cpp
class Solution {
public:
    //传入两个指针就不用分辨字符串长度奇偶情况
        //中心为s[l]、s[r],如果长度为奇数，l==r
    string palindrome(string&s, int l, int r){
        while(l >= 0 && r < s.size() && s[l] == s[r]){
            l--;r++;
        }
        return s.substr(l + 1, r - 1 - l);
    }
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++){
            string s1 = palindrome(s, i, i);
            string s2 = palindrome(s, i, i + 1);
            res = res.size() > s1.size()? res: s1;
            res = res.size() > s2.size()? res: s2;
        }
        return res;
    }
};
```

时间复杂度 O(N^2)，空间复杂度 O(1)。

还有一个时间复杂度为O(N)的算法，但是力扣这里并不需要，如果是竞赛可能就需要了——马拉车算法，我也写过[一篇笔记](https://www.yuque.com/qzhou/learning/dwmwl3#NTdX8)。

##  [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)



